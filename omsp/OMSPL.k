!! (SYMFILE #OMSPL 0x00030300 #OMSPL.%main 1 #OMSPL.Mod)
!! (CONST #version INTCONST 1)
!! (CONST #noerr INTCONST 0)
!! (CONST #nofile INTCONST 1)
!! (CONST #duphandler INTCONST 2)
!! (CONST #badkey INTCONST 3)
!! (CONST #badfile INTCONST 4)
!! (CONST #nospace INTCONST 5)
!! (CONST #nopar INTCONST 6)
!! (CONST #noinit INTCONST 7)
!! (CONST #notsupported INTCONST 8)
!! (CONST #RAMOrigin INTCONST 512)
!! (CONST #FlashEnd INTCONST 65536)
!! (CONST #MaxSec INTCONST 512)
!! (TYPE #Module !1 (POINTER))
!! (TARGET =1 !2 (RECORD #OMSPL.ModDesc 320 VOID
!!     (FIELD #name 0 !3 (ARRAY 32 CHAR))
!!     (FIELD #next 32 =1)
!!     (FIELD #key 36 INTEGER)
!!     (FIELD #num 40 INTEGER)
!!     (FIELD #varsto 44 INTEGER)
!!     (FIELD #flashsto 48 INTEGER)
!!     (FIELD #codeexe 52 INTEGER)
!!     (FIELD #flashsize 56 INTEGER)
!!     (FIELD #ent 60 !4 (ARRAY 64 INTEGER))
!!     (FIELD #codeseg 316 BYTE)))
!! (TYPE #Name =3)
!! (TYPE #ModDesc =2)
!! (TYPE #Segment !5 (POINTER))
!! (TARGET =5 !6 (RECORD #OMSPL.SegmentDesc 65544 VOID
!!     (FIELD #origin 0 INTEGER)
!!     (FIELD #allocPtr 4 INTEGER)
!!     (FIELD #m 8 !7 (ARRAY 65536 BYTE))))
!! (TYPE #SegmentDesc =6)
!! (TYPE #Section !8 (RECORD #OMSPL.Section 44 VOID
!!     (FIELD #segment 0 CHAR)
!!     (FIELD #name 1 =3)
!!     (FIELD #eadr 36 INTEGER)
!!     (FIELD #size 40 INTEGER)))
!! (TYPE #Depend !9 (POINTER))
!! (TARGET =9 !10 (RECORD #OMSPL.DependDesc 12 VOID
!!     (FIELD #mno 0 BYTE)
!!     (FIELD #sno 4 INTEGER)
!!     (FIELD #next 8 =9)))
!! (TYPE #DependDesc =10)
!! (TYPE #SecDep !11 (POINTER))
!! (TARGET =11 !12 (RECORD #OMSPL.SecDepDesc 12 VOID
!!     (FIELD #no 0 INTEGER)
!!     (FIELD #dep 4 =9)
!!     (FIELD #next 8 =11)))
!! (TYPE #SecDepDesc =12)
!! (TYPE #ModMaps !13 (POINTER))
!! (TARGET =13 !14 (RECORD #OMSPL.ModMapsDesc 492 VOID
!!     (FIELD #name 0 =3)
!!     (FIELD #next 32 =13)
!!     (FIELD #sections 36 =11)
!!     (FIELD #import 40 !15 (ARRAY 16 =13))
!!     (FIELD #nofimps 104 INTEGER)
!!     (FIELD #ent 108 !16 (ARRAY 64 INTEGER))
!!     (FIELD #refm 364 !17 (ARRAY 16 SET))
!!     (FIELD #tdm 428 =17)))
!! (TYPE #ModMapsDesc =14)
!! (GLOBAL #first #OMSPL.first =1)
!! (GLOBAL #last #OMSPL.last =1)
!! (GLOBAL #maps #OMSPL.maps =13)
!! (GLOBAL #RAMAllocPtr #OMSPL.RAMAllocPtr INTEGER)
!! (GLOBAL #RAMLimit #OMSPL.RAMLimit INTEGER)
!! (GLOBAL #limit #OMSPL.limit INTEGER)
!! (GLOBAL #res #OMSPL.res INTEGER)
!! (GLOBAL #Flash #OMSPL.Flash =5)
!! (GLOBAL #vector #OMSPL.vector !18 (ARRAY 32 INTEGER))
!! (GLOBAL #importing #OMSPL.importing =3)
!! (GLOBAL #imported #OMSPL.imported =3)
!! (GLOBAL #W #OMSPL.W ?19 #Texts 17 #Writer (RECORD #Texts.Writer 20 VOID
!!     (FIELD #buf* 0 ?20 #Texts 15 #Buffer (POINTER))
!!     (FIELD #col* 4 INTEGER)
!!     (FIELD #rider 8 ?21 #POFiles 6 #Rider (RECORD #POFiles.Rider 12 VOID
!!         (FIELD #eof* 0 BOOLEAN)
!!         (FIELD #res* 4 INTEGER)
!!         (FIELD #base 8 ?22 #POFiles 1 #File (POINTER))))))
!! (TARGET =22 ?23 #POFiles 2 #FileDesc (RECORD #POFiles.FileDesc 68 VOID
!!     (FIELD #file 0 ?24 #Files 1 #File (POINTER))
!!     (FIELD #tmpName 4 ?25 #POFiles 4 ANON (ARRAY 32 CHAR))
!!     (FIELD #name 36 =25)))
!! (TARGET =24 ?26 #Files 2 #FileDesc (RECORD #Files.FileDesc 8 VOID
!!     (FIELD #file- 0 SYSTEM.LONGPTR)))
!! (TARGET =20 ?27 #Texts 16 #BufDesc (RECORD #Texts.BufDesc 12 VOID
!!     (FIELD #len* 0 INTEGER)
!!     (FIELD #header 4 ?28 #Texts 1 #Piece (POINTER))
!!     (FIELD #last 8 =28)))
!! (TARGET =28 ?29 #Texts 2 #PieceDesc (RECORD #Texts.PieceDesc 24 VOID
!!     (FIELD #f 0 =22)
!!     (FIELD #off 4 INTEGER)
!!     (FIELD #len 8 INTEGER)
!!     (FIELD #col 12 INTEGER)
!!     (FIELD #prev 16 =28)
!!     (FIELD #next 20 =28)))
!! (PROCEDURE #align 118 #OMSPL.align !30 (PROC 1 VOID
!!     (VPARAM #a 12 INTEGER)))
!! (PROCEDURE #GetWordAt 123 #OMSPL.GetWordAt !31 (PROC 1 INTEGER
!!     (PARAM #adr 12 INTEGER)))
!! (PROCEDURE #PutWordAt 128 #OMSPL.PutWordAt !32 (PROC 2 VOID
!!     (PARAM #adr 12 INTEGER)
!!     (PARAM #val 16 INTEGER)))
!! (PROCEDURE #EmitByte 133 #OMSPL.EmitByte !33 (PROC 1 VOID
!!     (PARAM #val 12 BYTE)))
!! (PROCEDURE #EmitWord 140 #OMSPL.EmitWord !34 (PROC 1 VOID
!!     (PARAM #val 12 INTEGER)))
!! (PROCEDURE #padFlash 147 #OMSPL.padFlash !35 (PROC 0 VOID))
!! (DEF !36 (FLEX CHAR))
!! (DEF !37 (FLEX CHAR))
!! (PROCEDURE #MakeFileName 151 #OMSPL.MakeFileName !38 (PROC 6 VOID
!!     (VPARAM #FName 12 =36)
!!     (CPARAM #name 20 =37)
!!     (CPARAM #ext 28 =37))
!!   (LOCAL #i -4 INTEGER)
!!   (LOCAL #j -8 INTEGER))
!! (DEF !39 (FLEX CHAR))
!! (PROCEDURE #ThisFile 159 #OMSPL.ThisFile !40 (PROC 2 =22
!!     (CPARAM #name 12 =39))
!!   (LOCAL #F -4 =22)
!!   (LOCAL #filename -36 =3))
!! (DEF !41 (FLEX CHAR))
!! (PROCEDURE #error 166 #OMSPL.error !42 (PROC 3 VOID
!!     (PARAM #n 12 INTEGER)
!!     (CPARAM #name 16 =41)))
!! (DEF !43 (FLEX CHAR))
!! (PROCEDURE #Check 170 #OMSPL.Check !44 (PROC 2 VOID
!!     (CPARAM #s 12 =43))
!!   (LOCAL #i -4 INTEGER)
!!   (LOCAL #ch -5 CHAR))
!! (DEF !45 (FLEX CHAR))
!! (PROCEDURE #FindModMap 181 #OMSPL.FindModMap !46 (PROC 3 VOID
!!     (CPARAM #name 12 =45)
!!     (VPARAM #mm 20 =13)))
!! (DEF !47 (FLEX CHAR))
!! (DEF !48 (FLEX =8))
!! (PROCEDURE #LinkOne 187 #OMSPL.LinkOne !49 (PROC 7 VOID
!!     (CPARAM #name 12 =47)
!!     (VPARAM #newmod 20 =1)
!!     (VPARAM #sec 24 =48)
!!     (VPARAM #MW 32 =19))
!!   (LOCAL #mod -4 =1)
!!   (LOCAL #impmod -8 =1)
!!   (LOCAL #i -12 INTEGER)
!!   (LOCAL #k -16 INTEGER)
!!   (LOCAL #l -20 INTEGER)
!!   (LOCAL #nofimps -24 INTEGER)
!!   (LOCAL #ch -25 CHAR)
!!   (LOCAL #adr -32 INTEGER)
!!   (LOCAL #ofs -36 INTEGER)
!!   (LOCAL #sno -40 INTEGER)
!!   (LOCAL #no -44 INTEGER)
!!   (LOCAL #snor -48 INTEGER)
!!   (LOCAL #dest -52 INTEGER)
!!   (LOCAL #name1 -84 =3)
!!   (LOCAL #F -88 =22)
!!   (LOCAL #R -100 =21)
!!   (LOCAL #import -164 !50 (ARRAY 16 =1))
!!   (LOCAL #mno -165 BYTE)
!!   (LOCAL #mnor -166 BYTE)
!!   (LOCAL #vec -296 !51 (ARRAY 32 INTEGER))
!!   (LOCAL #secfpos -300 INTEGER)
!!   (LOCAL #nofsecs -304 INTEGER)
!!   (LOCAL #mm -308 =13)
!!   (LOCAL #keep -309 BOOLEAN))
!! (DEF !52 (FLEX CHAR))
!! (PROCEDURE #Mark 356 #OMSPL.Mark !53 (PROC 3 VOID
!!     (CPARAM #name 12 =52)
!!     (VPARAM #mm 20 =13))
!!   (LOCAL #im -4 =13)
!!   (LOCAL #F -8 =22)
!!   (LOCAL #R -20 =21)
!!   (LOCAL #name1 -52 =3)
!!   (LOCAL #ch -53 CHAR)
!!   (LOCAL #b -54 BYTE)
!!   (LOCAL #i -60 INTEGER)
!!   (LOCAL #w -64 INTEGER)
!!   (LOCAL #no -68 INTEGER)
!!   (LOCAL #s -72 =11)
!!   (LOCAL #d -76 =9)
!!   (LOCAL #done -77 BOOLEAN))
!! (PROCEDURE #Link* 435 #OMSPL.Link !54 (PROC 0 VOID)
!!   (LOCAL #i -4 INTEGER)
!!   (LOCAL #x -8 INTEGER)
!!   (LOCAL #vecsize -12 INTEGER)
!!   (LOCAL #isrtrap -16 INTEGER)
!!   (LOCAL #count -20 INTEGER)
!!   (LOCAL #oldcol -24 INTEGER)
!!   (LOCAL #F -28 =22)
!!   (LOCAL #R -40 =21)
!!   (LOCAL #MT -44 ?55 #Texts 8 #Text (POINTER))
!!   (LOCAL #MW -64 =19)
!!   (DEF ?56 #Texts 11 #Reader (RECORD #Texts.Reader 32 VOID
!!       (FIELD #eot* 0 BOOLEAN)
!!       (FIELD #col* 4 INTEGER)
!!       (FIELD #ref 8 =28)
!!       (FIELD #org 12 INTEGER)
!!       (FIELD #off 16 INTEGER)
!!       (FIELD #rider 20 =21)))
!!   (LOCAL #S -160 ?57 #Texts 13 #Scanner (RECORD #Texts.Scanner 96 =56
!!       (FIELD #eot* 0 BOOLEAN)
!!       (FIELD #col* 4 INTEGER)
!!       (FIELD #ref 8 =28)
!!       (FIELD #org 12 INTEGER)
!!       (FIELD #off 16 INTEGER)
!!       (FIELD #rider 20 =21)
!!       (FIELD #nextCh* 32 CHAR)
!!       (FIELD #line* 36 INTEGER)
!!       (FIELD #class* 40 INTEGER)
!!       (FIELD #i* 44 LONGINT)
!!       (FIELD #x* 52 REAL)
!!       (FIELD #c* 56 CHAR)
!!       (FIELD #len* 60 INTEGER)
!!       (FIELD #s* 64 ?58 #Texts 14 ANON (ARRAY 32 CHAR))))
!!   (LOCAL #M -164 =1)
!!   (LOCAL #p -168 =1)
!!   (LOCAL #MM -172 =13)
!!   (LOCAL #name -204 =3)
!!   (LOCAL #modlist -2252 !59 (ARRAY 64 =3))
!!   (LOCAL #nbmod -2256 INTEGER)
!!   (LOCAL #mi -2260 INTEGER)
!!   (LOCAL #sec -24788 !60 (ARRAY 512 =8)))
!! (TARGET =55 ?61 #Texts 9 #TextDesc (RECORD #Texts.TextDesc 24 VOID
!!     (FIELD #len* 0 INTEGER)
!!     (FIELD #changed* 4 BOOLEAN)
!!     (FIELD #notify* 8 ?62 #Texts 10 #Notifier (PROC 4 VOID
!!         (PARAM #T 12 =55)
!!         (PARAM #op 16 INTEGER)
!!         (PARAM #beg 20 INTEGER)
!!         (PARAM #end 24 INTEGER)))
!!     (FIELD #trailer 12 =28)
!!     (FIELD #pce 16 =28)
!!     (FIELD #org 20 INTEGER)))
!! (CHKSUM 0x0255a436)
!! 
MODULE OMSPL 0x0255a436 526
IMPORT Modules 0x2949f19d
IMPORT Display 0x6ac5a6ac
IMPORT OMSPG 0x1f97ef6a
IMPORT POFiles 0x1834a231
IMPORT FilesEx 0x20df259e
IMPORT Texts 0x04379426
IMPORT Oberon 0x7fd79012
IMPORT SystemLog 0x7825850f
ENDHDR

PROC OMSPL.align 0 2 0x00100001
!   PROCEDURE align(VAR a: INTEGER);
LINE 118
!   BEGIN a := (a + (G.WordSize - 1) ) DIV G.WordSize*G.WordSize
LINE 119
LDLW 12
LOADW
INC
CONST 2
DIV
CONST 2
TIMES
LDLW 12
STOREW
RETURN
END

PROC OMSPL.GetWordAt 0 4 0
!   PROCEDURE GetWordAt(adr: INTEGER): INTEGER;
LINE 123
!     RETURN 0 + Flash.m[adr] + 100H*Flash.m[adr + 1]
LINE 124
LDGW OMSPL.Flash
NCHECK 124
CONST 8
OFFSET
LDLW 12
CONST 65536
BOUND 124
OFFSET
LOADC
LDGW OMSPL.Flash
NCHECK 124
CONST 8
OFFSET
LDLW 12
INC
CONST 65536
BOUND 124
OFFSET
LOADC
CONST 256
TIMES
PLUS
RETURN
END

PROC OMSPL.PutWordAt 0 4 0
!   PROCEDURE PutWordAt(adr, val: INTEGER);
LINE 128
!   BEGIN Flash.m[adr] := val MOD 100H; val := val DIV 100H;
LINE 129
LDLW 16
CONST 256
MOD
CONVNC
LDGW OMSPL.Flash
NCHECK 129
CONST 8
OFFSET
LDLW 12
CONST 65536
BOUND 129
OFFSET
STOREC
LDLW 16
CONST 256
DIV
STLW 16
!     Flash.m[adr + 1] := val MOD 100H;
LINE 130
LDLW 16
CONST 256
MOD
CONVNC
LDGW OMSPL.Flash
NCHECK 130
CONST 8
OFFSET
LDLW 12
INC
CONST 65536
BOUND 130
OFFSET
STOREC
RETURN
END

PROC OMSPL.EmitByte 0 4 0
!   PROCEDURE EmitByte(val: BYTE);
LINE 133
!     IF Flash.allocPtr <= limit THEN Flash.m[Flash.allocPtr] := val; INC(Flash.allocPtr)
LINE 135
LDGW OMSPL.Flash
NCHECK 135
LDNW 4
LDGW OMSPL.limit
JGT L26
LDLC 12
LDGW OMSPL.Flash
NCHECK 135
CONST 8
OFFSET
LDGW OMSPL.Flash
NCHECK 135
LDNW 4
CONST 65536
BOUND 135
OFFSET
STOREC
LDGW OMSPL.Flash
NCHECK 135
DUP 0
LDNW 4
INC
SWAP
STNW 4
RETURN
LABEL L26
!     ELSE res := nospace
LINE 136
CONST 5
STGW OMSPL.res
RETURN
END

PROC OMSPL.EmitWord 0 3 0
!   PROCEDURE EmitWord(val: INTEGER);
LINE 140
!     IF Flash.allocPtr <= limit THEN PutWordAt(Flash.allocPtr, val); INC(Flash.allocPtr, G.WordSize);
LINE 142
LDGW OMSPL.Flash
NCHECK 142
LDNW 4
LDGW OMSPL.limit
JGT L29
LDLW 12
LDGW OMSPL.Flash
NCHECK 142
LDNW 4
GLOBAL OMSPL.PutWordAt
CALL 2
LDGW OMSPL.Flash
NCHECK 142
DUP 0
LDNW 4
CONST 2
PLUS
SWAP
STNW 4
RETURN
LABEL L29
!     ELSE res := nospace
LINE 143
CONST 5
STGW OMSPL.res
RETURN
END

PROC OMSPL.padFlash 0 2 0
!   PROCEDURE padFlash; (*align flash allocatopn address a on word size boundary*)
LINE 147
LABEL L30
!   BEGIN WHILE (res = noerr) & (Flash.allocPtr MOD G.WordSize # 0) DO EmitByte(0) END
LINE 148
LDGW OMSPL.res
JNEQZ L32
LDGW OMSPL.Flash
NCHECK 148
LDNW 4
CONST 2
MOD
JEQZ L32
CONST 0
GLOBAL OMSPL.EmitByte
CALL 1
JUMP L30
LABEL L32
RETURN
END

PROC OMSPL.MakeFileName 8 4 0x01500001
!   PROCEDURE MakeFileName(VAR FName: ARRAY OF CHAR; name, ext: ARRAY OF CHAR);
LINE 151
!   BEGIN i := 0; j := 0;  (*assume name suffix less than 4 characters*)
LINE 153
CONST 0
STLW -4
CONST 0
STLW -8
LABEL L34
!     WHILE (i < 32-5) & (name[i] > 0X) DO FName[i] := name[i]; INC(i) END ;
LINE 154
LDLW -4
CONST 27
JGEQ L36
LDLW 20
LDLW -4
LDLW 24
BOUND 154
LDIC
JLEQZ L36
LDLW 20
LDLW -4
LDLW 24
BOUND 154
LDIC
LDLW 12
LDLW -4
LDLW 16
BOUND 154
STIC
INCL -4
JUMP L34
LABEL L36
!     REPEAT FName[i]:= ext[j]; INC(i); INC(j) UNTIL ext[j] = 0X;
LINE 155
LDLW 28
LDLW -8
LDLW 32
BOUND 155
LDIC
LDLW 12
LDLW -4
LDLW 16
BOUND 155
STIC
INCL -4
INCL -8
LDLW 28
LDLW -8
LDLW 32
BOUND 155
LDIC
JNEQZ L36
!     FName[i] := 0X
LINE 156
CONST 0
LDLW 12
LDLW -4
LDLW 16
BOUND 156
STIC
RETURN
END

PROC OMSPL.ThisFile 36 7 0x00110001
!   PROCEDURE ThisFile(name: ARRAY OF CHAR): Files.File;
LINE 159
!   BEGIN MakeFileName(filename, name, ".mpc"); F := Files.Old(filename);
LINE 162
CONST 5
GLOBAL OMSPL.%1
LDLW 16
LDLW 12
CONST 32
LOCAL -36
GLOBAL OMSPL.MakeFileName
CALL 6
CONST 32
LOCAL -36
GLOBAL POFiles.Old
CALLW 2
STLW -4
!     RETURN F
LINE 163
LDLW -4
RETURN
END

PROC OMSPL.error 0 7 0x00200001
!   PROCEDURE error(n: INTEGER; name: ARRAY OF CHAR);
LINE 166
!   BEGIN res := n; importing := name
LINE 167
LDLW 12
STGW OMSPL.res
CONST 32
GLOBAL OMSPL.importing
LDLW 20
LDLW 16
CONST 1
CONST 1
GLOBAL FLEXASSIGN
CALL 6
RETURN
END

PROC OMSPL.Check 8 3 0x00100001
!   PROCEDURE Check(s: ARRAY OF CHAR);
LINE 170
!   BEGIN ch := s[0]; res := 1; i := 1;
LINE 172
LDLW 12
CONST 0
LDLW 16
BOUND 172
LDIC
STLC -5
CONST 1
STGW OMSPL.res
CONST 1
STLW -4
!     IF (ch >= "A") & (ch <= "Z") OR (ch >= "a") & (ch <= "z") THEN
LINE 173
LDLC -5
CONST 65
JLT L56
LDLC -5
CONST 90
JLEQ L41
LABEL L56
LDLC -5
CONST 97
JLT L42
LDLC -5
CONST 122
JGT L42
LABEL L41
!       REPEAT ch := s[i]; INC(i)
LINE 174
LDLW 12
LDLW -4
LDLW 16
BOUND 174
LDIC
STLC -5
INCL -4
!       UNTIL ~((ch >= "0") & (ch <= "9") OR (ch >= "A") & (ch <= "Z")
LINE 175
LDLC -5
CONST 48
JLT L49
LDLC -5
CONST 57
JLEQ L45
LABEL L49
LDLC -5
CONST 65
JLT L47
LDLC -5
CONST 90
JLEQ L45
LABEL L47
LDLC -5
CONST 97
JLT L46
LDLC -5
CONST 122
JLEQ L45
LABEL L46
LDLC -5
CONST 46
JNEQ L44
LABEL L45
LDLW -4
CONST 32
JNEQ L41
LABEL L44
!       IF (i < 32) & (ch = 0X) THEN res := 0 END
LINE 177
LDLW -4
CONST 32
JGEQ L42
LDLC -5
JNEQZ L42
CONST 0
STGW OMSPL.res
LABEL L42
RETURN
END

PROC OMSPL.FindModMap 0 7 0x00500001
!   PROCEDURE FindModMap(name: ARRAY OF CHAR; VAR mm: ModMaps);
LINE 181
!   BEGIN mm := maps;
LINE 182
LDGW OMSPL.maps
LDLW 20
STOREW
LABEL L59
!     WHILE (mm # NIL) & (name # mm.name) DO mm := mm.next END;
LINE 183
LDLW 20
LOADW
JEQZ L61
LDLW 20
LOADW
CONST 32
SWAP
NCHECK 183
LDLW 16
LDLW 12
GLOBAL COMPARE
CALLW 4
JEQZ L61
LDLW 20
LOADW
NCHECK 183
LDNW 32
LDLW 20
STOREW
JUMP L59
LABEL L61
!     IF mm = NIL THEN NEW(mm); mm.name := name; mm.next := maps; maps := mm END
LINE 184
LDLW 20
LOADW
JNEQZ L65
CONST 492
GLOBAL OMSPL.ModMapsDesc
GLOBAL NEW
CALLW 2
LDLW 20
STOREW
LDLW 20
LOADW
CONST 32
SWAP
NCHECK 184
LDLW 16
LDLW 12
CONST 1
CONST 1
GLOBAL FLEXASSIGN
CALL 6
LDGW OMSPL.maps
LDLW 20
LOADW
NCHECK 184
STNW 32
LDLW 20
LOADW
STGW OMSPL.maps
LABEL L65
RETURN
END

PROC OMSPL.LinkOne 336 8 OMSPL.LinkOne.%map
!   PROCEDURE LinkOne(name: ARRAY OF CHAR; VAR newmod: Module;
LINE 187
!   BEGIN mod := first; error(noerr, name);
LINE 205
LDGW OMSPL.first
STLW -4
LDLW 16
LDLW 12
CONST 0
GLOBAL OMSPL.error
CALL 3
LABEL L66
!     WHILE (mod # NIL) & (name # mod.name) DO mod := mod.next END ;
LINE 206
LDLW -4
JEQZ L68
CONST 32
LDLW -4
NCHECK 206
LDLW 16
LDLW 12
GLOBAL COMPARE
CALLW 4
JEQZ L68
LDLW -4
NCHECK 206
LDNW 32
STLW -4
JUMP L66
LABEL L68
!     IF mod = NIL THEN (*link*)
LINE 207
LDLW -4
JNEQZ L72
!       Check(name); k := 0; mno := 0;
LINE 208
LDLW 16
LDLW 12
GLOBAL OMSPL.Check
CALL 2
CONST 0
STLW -16
CONST 0
STLC -165
!       IF res = noerr THEN F := ThisFile(name) ELSE F := NIL END ;
LINE 209
LDGW OMSPL.res
JNEQZ L75
LDLW 16
LDLW 12
GLOBAL OMSPL.ThisFile
CALLW 2
STLW -88
JUMP L73
LABEL L75
CONST 0
STLW -88
LABEL L73
!       IF F # NIL THEN
LINE 210
LDLW -88
JEQZ L78
!         Files.Set(R, F, 0); Files.ReadString(R, name1); Files.ReadInt(R, k); Files.ReadByte(R, mno);
LINE 211
CONST 0
LDLW -88
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.Set
CALL 4
CONST 32
LOCAL -84
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadString
CALL 4
LOCAL -16
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadInt
CALL 3
LOCAL -165
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadByte
CALL 3
!         IF mno IN {version*2, version*2+1} THEN mno := mno MOD 2;
LINE 212
CONST 1
LDLC -165
CONST 32
BOUND 212
LSL
CONST 12
BITAND
JEQZ L81
LDLC -165
CONST 2
MOD
STLC -165
!           IF name = name1 THEN nofimps := 0;
LINE 213
CONST 32
LOCAL -84
LDLW 16
LDLW 12
GLOBAL COMPARE
CALLW 4
JNEQZ L84
CONST 0
STLW -24
!             Files.ReadString(R, name1);   (*imports*)
LINE 214
CONST 32
LOCAL -84
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadString
CALL 4
LABEL L85
!             WHILE (name1[0] # 0X) & (res = noerr) DO
LINE 215
LDLC -84
JEQZ L76
LDGW OMSPL.res
JNEQZ L76
!               Files.ReadInt(R, l);
LINE 216
LOCAL -20
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadInt
CALL 3
!               LinkOne(name1, impmod, sec, MW); import[nofimps] := impmod; INC(nofimps);
LINE 217
LDLW 36
LDLW 32
LDLW 28
LDLW 24
LOCAL -8
CONST 32
LOCAL -84
GLOBAL OMSPL.LinkOne
CALL 7
LDLW -8
LOCAL -164
LDLW -24
CONST 16
BOUND 217
STIW
INCL -24
!               IF res = noerr THEN
LINE 218
LDGW OMSPL.res
JNEQZ L85
!                 IF impmod.key # l THEN error(badkey, name); imported := name1 END;
LINE 219
LDLW -8
NCHECK 219
LDNW 36
LDLW -20
JEQ L93
LDLW 16
LDLW 12
CONST 3
GLOBAL OMSPL.error
CALL 3
GLOBAL OMSPL.imported
LOCAL -84
CONST 32
FIXCOPY
LABEL L93
!                 Files.ReadString(R, name1)
LINE 220
CONST 32
LOCAL -84
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadString
CALL 4
JUMP L85
LABEL L84
!           ELSE error(badfile, name)
LINE 223
LDLW 16
LDLW 12
CONST 4
GLOBAL OMSPL.error
CALL 3
JUMP L76
LABEL L81
!         ELSE error(notsupported, name)
LINE 225
LDLW 16
LDLW 12
CONST 8
GLOBAL OMSPL.error
CALL 3
JUMP L76
LABEL L78
!       ELSE error(nofile, name)
LINE 227
LDLW 16
LDLW 12
CONST 1
GLOBAL OMSPL.error
CALL 3
LABEL L76
!       IF res = noerr THEN MW.col := Display.yellow;
LINE 229
LDGW OMSPL.res
JNEQZ L97
CONST 252
LDLW 32
STNW 4
!         Texts.WriteString(MW, "Module "); Texts.WriteString(MW, name); Texts.WriteLn(MW);
LINE 230
CONST 8
GLOBAL OMSPL.%2
LDLW 36
LDLW 32
GLOBAL Texts.WriteString
CALL 4
LDLW 16
LDLW 12
LDLW 36
LDLW 32
GLOBAL Texts.WriteString
CALL 4
LDLW 36
LDLW 32
GLOBAL Texts.WriteLn
CALL 2
!         MW.col := Display.white; FindModMap(name, mm);
LINE 231
CONST 255
LDLW 32
STNW 4
LOCAL -308
LDLW 16
LDLW 12
GLOBAL OMSPL.FindModMap
CALL 3
!         NEW(mod);
LINE 232
CONST 320
GLOBAL OMSPL.ModDesc
GLOBAL NEW
CALLW 2
STLW -4
!         IF first = NIL THEN mod.num := 1; first := mod ELSE mod.num := last.num + 1; last.next := mod END;
LINE 233
LDGW OMSPL.first
JNEQZ L100
CONST 1
LDLW -4
NCHECK 233
STNW 40
LDLW -4
STGW OMSPL.first
JUMP L98
LABEL L100
LDGW OMSPL.last
NCHECK 233
LDNW 40
INC
LDLW -4
NCHECK 233
STNW 40
LDLW -4
LDGW OMSPL.last
NCHECK 233
STNW 32
LABEL L98
!         last := mod; mod.next := NIL;
LINE 234
LDLW -4
STGW OMSPL.last
CONST 0
LDLW -4
NCHECK 234
STNW 32
!         mod.name := name;
LINE 235
CONST 32
LDLW -4
NCHECK 235
LDLW 16
LDLW 12
CONST 1
CONST 1
GLOBAL FLEXASSIGN
CALL 6
!         i := 0; REPEAT INC(i) UNTIL mod.name[i] = 0X; REPEAT mod.name[i] := 0X; INC(i) UNTIL i=32;
LINE 236
CONST 0
STLW -12
LABEL L101
INCL -12
LDLW -4
NCHECK 236
LDLW -12
CONST 32
BOUND 236
LDIC
JNEQZ L101
LABEL L103
CONST 0
LDLW -4
NCHECK 236
LDLW -12
CONST 32
BOUND 236
STIC
INCL -12
LDLW -12
CONST 32
JNEQ L103
!         mod.key := k; mod.codeseg := mno;
LINE 237
LDLW -16
LDLW -4
NCHECK 237
STNW 36
LDLC -165
LDLW -4
NCHECK 237
CONST 316
STIC
!         mod.varsto := RAMAllocPtr; (*storage address in RAM*)
LINE 238
LDGW OMSPL.RAMAllocPtr
LDLW -4
NCHECK 238
STNW 44
!         mod.flashsto := Flash.allocPtr; (*storage address in flash memory*)
LINE 239
LDGW OMSPL.Flash
NCHECK 239
LDNW 4
LDLW -4
NCHECK 239
STNW 48
!         secfpos := Files.Pos(R); nofsecs := 0;
LINE 246
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.Pos
CALLW 2
STLW -300
CONST 0
STLW -304
!         Files.Read(R, ch);
LINE 247
LOCAL -25
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.Read
CALL 3
LABEL L105
!         WHILE ch # 0X DO
LINE 248
LDLC -25
JEQZ L107
!           sec[nofsecs].segment := ch; sec[nofsecs].eadr := -1;
LINE 249
LDLC -25
LDLW 24
LDLW -304
LDLW 28
BOUND 249
CONST 44
TIMES
STIC
CONST -1
LDLW 24
LDLW -304
LDLW 28
BOUND 249
CONST 44
TIMES
OFFSET
STNW 36
!           keep := nofsecs MOD 32 IN mm.refm[nofsecs DIV 32]; (*keep the section if referenced*)
LINE 250
LDLW -308
NCHECK 250
CONST 364
OFFSET
LDLW -304
CONST 32
DIV
CONST 16
BOUND 250
LDIW
CONST 1
LDLW -304
CONST 32
MOD
CONST 32
BOUND 250
LSL
BITAND
CONST 0
NEQ
STLC -309
!           Files.ReadString(R, sec[nofsecs].name); Files.ReadHalfWord(R, sec[nofsecs].size);
LINE 251
LDLW 24
LDLW -304
LDLW 28
BOUND 251
CONST 44
TIMES
OFFSET
CONST 1
OFFSET
CONST 32
SWAP
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadString
CALL 4
LDLW 24
LDLW -304
LDLW 28
BOUND 251
CONST 44
TIMES
OFFSET
CONST 40
OFFSET
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
!           IF (ch = "c") OR (ch = "d") OR (ch = "s") THEN (*in flash memory*)
LINE 252
LDLC -25
CONST 99
JEQ L109
LDLC -25
CONST 100
JEQ L109
LDLC -25
CONST 115
JNEQ L110
LABEL L109
!             IF keep THEN
LINE 253
LDLC -309
JEQZ L115
!               IF sec[nofsecs].size >= G.WordSize THEN padFlash END; sec[nofsecs].eadr := Flash.allocPtr;
LINE 254
LDLW 24
LDLW -304
LDLW 28
BOUND 254
CONST 44
TIMES
OFFSET
LDNW 40
CONST 2
JLT L118
GLOBAL OMSPL.padFlash
CALL 0
LABEL L118
LDGW OMSPL.Flash
NCHECK 254
LDNW 4
LDLW 24
LDLW -304
LDLW 28
BOUND 254
CONST 44
TIMES
OFFSET
STNW 36
!               FOR i := 0 TO sec[nofsecs].size - 1 DO Files.ReadByte(R, mno); EmitByte(mno) END
LINE 255
LDLW 24
LDLW -304
LDLW 28
BOUND 255
CONST 44
TIMES
OFFSET
LDNW 40
DEC
STLW -316
CONST 0
STLW -12
LABEL L119
LDLW -12
LDLW -316
JGT L108
LOCAL -165
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadByte
CALL 3
LDLC -165
GLOBAL OMSPL.EmitByte
CALL 1
INCL -12
JUMP L119
LABEL L115
!             ELSE FOR i := 0 TO sec[nofsecs].size - 1 DO Files.ReadByte(R, mno) END (*skip data*)
LINE 256
LDLW 24
LDLW -304
LDLW 28
BOUND 256
CONST 44
TIMES
OFFSET
LDNW 40
DEC
STLW -320
CONST 0
STLW -12
LABEL L112
LDLW -12
LDLW -320
JGT L108
LOCAL -165
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadByte
CALL 3
INCL -12
JUMP L112
LABEL L110
!           ELSIF ch = "v" THEN (*vector table*)
LINE 258
LDLC -25
CONST 118
JNEQ L124
!             FOR i := 0 TO sec[nofsecs].size DIV 2 - 1 DO Files.ReadHalfWord(R, adr); vec[i] := adr END; (*module vector table*)
LINE 259
LDLW 24
LDLW -304
LDLW 28
BOUND 259
CONST 44
TIMES
OFFSET
LDNW 40
CONST 2
DIV
DEC
STLW -324
CONST 0
STLW -12
LABEL L125
LDLW -12
LDLW -324
JGT L108
LOCAL -32
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
LDLW -32
LOCAL -296
LDLW -12
CONST 32
BOUND 259
STIW
INCL -12
JUMP L125
LABEL L124
!           ELSIF ch = "r" THEN
LINE 260
LDLC -25
CONST 114
JNEQ L128
!             IF keep THEN
LINE 261
LDLC -309
JEQZ L108
!               IF sec[nofsecs].size >= G.WordSize THEN align(RAMAllocPtr) END; sec[nofsecs].eadr := RAMAllocPtr;
LINE 262
LDLW 24
LDLW -304
LDLW 28
BOUND 262
CONST 44
TIMES
OFFSET
LDNW 40
CONST 2
JLT L134
GLOBAL OMSPL.RAMAllocPtr
GLOBAL OMSPL.align
CALL 1
LABEL L134
LDGW OMSPL.RAMAllocPtr
LDLW 24
LDLW -304
LDLW 28
BOUND 262
CONST 44
TIMES
OFFSET
STNW 36
!               INC(RAMAllocPtr, sec[nofsecs].size)
LINE 263
GLOBAL OMSPL.RAMAllocPtr
DUP 0
LOADW
LDLW 24
LDLW -304
LDLW 28
BOUND 263
CONST 44
TIMES
OFFSET
LDNW 40
PLUS
SWAP
STOREW
JUMP L108
LABEL L128
!           ELSE error(badfile, name)
LINE 265
LDLW 16
LDLW 12
CONST 4
GLOBAL OMSPL.error
CALL 3
LABEL L108
!           Files.ReadHalfWord(R, adr); (*skip fixup data*)
LINE 267
LOCAL -32
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
LABEL L135
!           WHILE adr # 0 DO
LINE 268
LDLW -32
JEQZ L137
!             Files.ReadByte(R, mno); Files.ReadHalfWord(R, sno); Files.ReadHalfWord(R, ofs);
LINE 269
LOCAL -165
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadByte
CALL 3
LOCAL -40
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
LOCAL -36
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
!             Files.ReadByte(R, mnor); Files.ReadHalfWord(R, snor);
LINE 270
LOCAL -166
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadByte
CALL 3
LOCAL -48
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
!             Files.ReadHalfWord(R, adr)
LINE 271
LOCAL -32
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
JUMP L135
LABEL L137
!           INC(nofsecs);
LINE 273
INCL -304
!           Files.Read(R, ch)
LINE 274
LOCAL -25
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.Read
CALL 3
JUMP L105
LABEL L107
!         padFlash; mod.flashsize := Flash.allocPtr - mod.flashsto;
LINE 276
GLOBAL OMSPL.padFlash
CALL 0
LDGW OMSPL.Flash
NCHECK 276
LDNW 4
LDLW -4
NCHECK 276
LDNW 48
MINUS
LDLW -4
NCHECK 276
STNW 56
!         IF mod.codeseg = 1 THEN (*execute in RAM*) mod.codeexe := RAMAllocPtr; INC(RAMAllocPtr, mod.flashsize)
LINE 277
LDLW -4
NCHECK 277
CONST 316
LDIC
CONST 1
JNEQ L140
LDGW OMSPL.RAMAllocPtr
LDLW -4
NCHECK 277
STNW 52
GLOBAL OMSPL.RAMAllocPtr
DUP 0
LOADW
LDLW -4
NCHECK 277
LDNW 56
PLUS
SWAP
STOREW
JUMP L138
LABEL L140
!         ELSE mod.codeexe := Flash.origin + mod.flashsto
LINE 278
LDGW OMSPL.Flash
NCHECK 278
LOADW
LDLW -4
NCHECK 278
LDNW 48
PLUS
LDLW -4
NCHECK 278
STNW 52
LABEL L138
!         IF res = noerr THEN
LINE 280
LDGW OMSPL.res
JNEQZ L97
!           FOR i := 0 TO nofsecs - 1 DO
LINE 282
LDLW -304
DEC
STLW -328
CONST 0
STLW -12
LABEL L144
LDLW -12
LDLW -328
JGT L145
!             IF i MOD 32 IN mm.refm[i DIV 32] THEN (*adjust address of the section if referenced*)
LINE 283
LDLW -308
NCHECK 283
CONST 364
OFFSET
LDLW -12
CONST 32
DIV
CONST 16
BOUND 283
LDIW
CONST 1
LDLW -12
CONST 32
MOD
CONST 32
BOUND 283
LSL
BITAND
JEQZ L148
!               Texts.WriteString(MW, sec[i].name); Texts.Write(MW, 09X);
LINE 284
LDLW 24
LDLW -12
LDLW 28
BOUND 284
CONST 44
TIMES
OFFSET
CONST 1
OFFSET
CONST 32
SWAP
LDLW 36
LDLW 32
GLOBAL Texts.WriteString
CALL 4
CONST 9
ALIGNC
LDLW 36
LDLW 32
GLOBAL Texts.Write
CALL 3
!               ch := sec[i].segment; Texts.Write(MW, ch);
LINE 285
LDLW 24
LDLW -12
LDLW 28
BOUND 285
CONST 44
TIMES
LDIC
STLC -25
LDLC -25
ALIGNC
LDLW 36
LDLW 32
GLOBAL Texts.Write
CALL 3
!               IF (ch = "c") OR (ch = "d") OR (ch = "s") THEN (*in flash memory*)
LINE 286
LDLC -25
CONST 99
JEQ L150
LDLC -25
CONST 100
JEQ L150
LDLC -25
CONST 115
JNEQ L151
LABEL L150
!                 DEC(sec[i].eadr, mod.flashsto - mod.codeexe)
LINE 287
LDLW 24
LDLW -12
LDLW 28
BOUND 287
CONST 44
TIMES
OFFSET
CONST 36
OFFSET
DUP 0
LOADW
LDLW -4
NCHECK 287
LDNW 48
LDLW -4
NCHECK 287
LDNW 52
MINUS
MINUS
SWAP
STOREW
LABEL L151
!               IF ch # "v" THEN Texts.WriteHexVLen(MW, sec[i].eadr, 4, FALSE) END; Texts.Write(MW, 09X);
LINE 289
LDLC -25
CONST 118
JEQ L156
CONST 0
ALIGNC
CONST 4
LDLW 24
LDLW -12
LDLW 28
BOUND 289
CONST 44
TIMES
OFFSET
LDNW 36
LDLW 36
LDLW 32
GLOBAL Texts.WriteHexVLen
CALL 5
LABEL L156
CONST 9
ALIGNC
LDLW 36
LDLW 32
GLOBAL Texts.Write
CALL 3
!               Texts.WriteInt(MW, sec[i].size, 1); Texts.WriteLn(MW)
LINE 290
CONST 1
LDLW 24
LDLW -12
LDLW 28
BOUND 290
CONST 44
TIMES
OFFSET
LDNW 40
LDLW 36
LDLW 32
GLOBAL Texts.WriteInt
CALL 4
LDLW 36
LDLW 32
GLOBAL Texts.WriteLn
CALL 2
LABEL L148
!           FOR i := 0 TO nofsecs - 1 DO
LINE 282
INCL -12
JUMP L144
LABEL L145
!           Texts.WriteString(MW, "codeexe"); Texts.Write(MW, 09X); 
LINE 293
CONST 8
GLOBAL OMSPL.%3
LDLW 36
LDLW 32
GLOBAL Texts.WriteString
CALL 4
CONST 9
ALIGNC
LDLW 36
LDLW 32
GLOBAL Texts.Write
CALL 3
!           Texts.WriteHexVLen(MW, mod.codeexe, 4, FALSE); Texts.WriteLn(MW);
LINE 294
CONST 0
ALIGNC
CONST 4
LDLW -4
NCHECK 294
LDNW 52
LDLW 36
LDLW 32
GLOBAL Texts.WriteHexVLen
CALL 5
LDLW 36
LDLW 32
GLOBAL Texts.WriteLn
CALL 2
!           Files.Set(R, Files.Base(R), secfpos); (*rewind rider to beginning of sections list*)
LINE 296
LDLW -300
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.Base
CALLW 2
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.Set
CALL 4
!           no := 0; Files.Read(R, ch);
LINE 297
CONST 0
STLW -44
LOCAL -25
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.Read
CALL 3
LABEL L157
!           WHILE ch # 0X DO (*go to fixup data*)
LINE 298
LDLC -25
JEQZ L159
!             keep := no MOD 32 IN mm.refm[no DIV 32]; (*fixup the section dependencies if referenced*)
LINE 299
LDLW -308
NCHECK 299
CONST 364
OFFSET
LDLW -44
CONST 32
DIV
CONST 16
BOUND 299
LDIW
CONST 1
LDLW -44
CONST 32
MOD
CONST 32
BOUND 299
LSL
BITAND
CONST 0
NEQ
STLC -309
!             Files.ReadString(R, name1); Files.ReadHalfWord(R, k);
LINE 300
CONST 32
LOCAL -84
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadString
CALL 4
LOCAL -16
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
!             IF (ch = "c") OR (ch = "d") OR (ch = "s") OR (ch = "v") THEN
LINE 301
LDLC -25
CONST 99
JEQ L161
LDLC -25
CONST 100
JEQ L161
LDLC -25
CONST 115
JEQ L161
LDLC -25
CONST 118
JNEQ L162
LABEL L161
!               FOR i := 0 TO k - 1 DO Files.ReadByte(R, mno) END (*skip content*)
LINE 302
LDLW -16
DEC
STLW -332
CONST 0
STLW -12
LABEL L163
LDLW -12
LDLW -332
JGT L162
LOCAL -165
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadByte
CALL 3
INCL -12
JUMP L163
LABEL L162
!             Files.ReadHalfWord(R, adr); (*entering fixup data*)
LINE 304
LOCAL -32
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
LABEL L168
!             WHILE adr # 0 DO
LINE 305
LDLW -32
JEQZ L170
!               Files.ReadByte(R, mno); Files.ReadHalfWord(R, sno); Files.ReadHalfWord(R, ofs);
LINE 306
LOCAL -165
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadByte
CALL 3
LOCAL -40
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
LOCAL -36
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
!               Files.ReadByte(R, mnor); Files.ReadHalfWord(R, snor);
LINE 307
LOCAL -166
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadByte
CALL 3
LOCAL -48
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
!               IF keep THEN
LINE 308
LDLC -309
JEQZ L173
!                 IF mno = 0 THEN dest := sec[sno].eadr ELSE dest := import[mno - 1].ent[sno] END;
LINE 309
LDLC -165
JNEQZ L176
LDLW 24
LDLW -40
LDLW 28
BOUND 309
CONST 44
TIMES
OFFSET
LDNW 36
STLW -52
JUMP L174
LABEL L176
LOCAL -164
LDLC -165
DEC
CONST 16
BOUND 309
LDIW
NCHECK 309
CONST 60
OFFSET
LDLW -40
CONST 64
BOUND 309
LDIW
STLW -52
LABEL L174
!                 INC(dest, ofs); (*dest contains now the effective address*)
LINE 310
LOCAL -52
DUP 0
LOADW
LDLW -36
PLUS
SWAP
STOREW
!                 IF mnor # 0FFH THEN
LINE 311
LDLC -166
CONST 255
JEQ L179
!                   IF mnor = 0 THEN DEC(dest, sec[snor].eadr) ELSE DEC(dest, import[mnor - 1].ent[snor]) END
LINE 312
LDLC -166
JNEQZ L182
LOCAL -52
DUP 0
LOADW
LDLW 24
LDLW -48
LDLW 28
BOUND 312
CONST 44
TIMES
OFFSET
LDNW 36
MINUS
SWAP
STOREW
JUMP L179
LABEL L182
LOCAL -52
DUP 0
LOADW
LOCAL -164
LDLC -166
DEC
CONST 16
BOUND 312
LDIW
NCHECK 312
CONST 60
OFFSET
LDLW -48
CONST 64
BOUND 312
LDIW
MINUS
SWAP
STOREW
LABEL L179
!                 IF ch = "v" THEN (*vector table*)
LINE 314
LDLC -25
CONST 118
JNEQ L190
LABEL L191
!                   REPEAT i := (adr - 1) DIV 2;
LINE 315
LDLW -32
DEC
CONST 2
DIV
STLW -12
!                     IF vector[i] # 0FFFFH THEN
LINE 316
GLOBAL OMSPL.vector
LDLW -12
CONST 32
BOUND 316
LDIW
CONST 65535
JEQ L195
!                       Texts.WriteString(W, "interrupt vector number"); Texts.WriteInt(W, i, 3); error(duphandler, name1)
LINE 317
CONST 24
GLOBAL OMSPL.%4
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
CONST 3
LDLW -12
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteInt
CALL 4
CONST 32
LOCAL -84
CONST 2
GLOBAL OMSPL.error
CALL 3
LABEL L195
!                     vector[i] := dest; adr := vec[i]
LINE 319
LDLW -52
GLOBAL OMSPL.vector
LDLW -12
CONST 32
BOUND 319
STIW
LOCAL -296
LDLW -12
CONST 32
BOUND 319
LDIW
STLW -32
!                   UNTIL adr = 0;
LINE 320
LDLW -32
JNEQZ L191
JUMP L173
LABEL L190
!                 ELSE l := sec[no].eadr; IF ch # "r" THEN DEC(l, mod.codeexe - mod.flashsto) END;
LINE 321
LDLW 24
LDLW -44
LDLW 28
BOUND 321
CONST 44
TIMES
OFFSET
LDNW 36
STLW -20
LDLC -25
CONST 114
JEQ L186
LOCAL -20
DUP 0
LOADW
LDLW -4
NCHECK 321
LDNW 52
LDLW -4
NCHECK 321
LDNW 48
MINUS
MINUS
SWAP
STOREW
LABEL L186
!                   REPEAT k := GetWordAt(l + adr - 1); PutWordAt(l + adr - 1, dest); adr := k UNTIL adr = 0
LINE 322
LDLW -20
LDLW -32
PLUS
DEC
GLOBAL OMSPL.GetWordAt
CALLW 1
STLW -16
LDLW -52
LDLW -20
LDLW -32
PLUS
DEC
GLOBAL OMSPL.PutWordAt
CALL 2
LDLW -16
STLW -32
LDLW -32
JNEQZ L186
LABEL L173
!               Files.ReadHalfWord(R, adr)
LINE 325
LOCAL -32
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
JUMP L168
LABEL L170
!             INC(no); Files.Read(R, ch)
LINE 327
INCL -44
LOCAL -25
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.Read
CALL 3
JUMP L157
LABEL L159
!           Files.ReadHalfWord(R, k); (*number of entries*)
LINE 329
LOCAL -16
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
!           FOR i := 0 TO k - 1 DO Files.ReadHalfWord(R, sno);
LINE 330
LDLW -16
DEC
STLW -336
CONST 0
STLW -12
LABEL L196
LDLW -12
LDLW -336
JGT L197
LOCAL -40
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
!             mod.ent[i] := sec[sno].eadr
LINE 331
LDLW 24
LDLW -40
LDLW 28
BOUND 331
CONST 44
TIMES
OFFSET
LDNW 36
LDLW -4
NCHECK 331
CONST 60
OFFSET
LDLW -12
CONST 64
BOUND 331
STIW
!           FOR i := 0 TO k - 1 DO Files.ReadHalfWord(R, sno);
LINE 330
INCL -12
JUMP L196
LABEL L197
!           IF GetWordAt(mod.ent[0] - mod.codeexe + mod.flashsto) = 4130H THEN (*module init is empty*)
LINE 333
LDLW -4
NCHECK 333
LDNW 60
LDLW -4
NCHECK 333
LDNW 52
MINUS
LDLW -4
NCHECK 333
LDNW 48
PLUS
GLOBAL OMSPL.GetWordAt
CALLW 1
CONST 16688
JNEQ L200
!             DEC(mod.flashsize, 2); mod.ent[0] := -1; (*mark init address as invalid*)
LINE 334
LDLW -4
NCHECK 334
DUP 0
LDNW 56
CONST 2
MINUS
SWAP
STNW 56
CONST -1
LDLW -4
NCHECK 334
STNW 60
!             IF mod.codeseg = 1 THEN DEC(RAMAllocPtr, 2) END;
LINE 335
LDLW -4
NCHECK 335
CONST 316
LDIC
CONST 1
JNEQ L203
LDGW OMSPL.RAMAllocPtr
CONST 2
MINUS
STGW OMSPL.RAMAllocPtr
LABEL L203
!             DEC(Flash.allocPtr, 2)
LINE 336
LDGW OMSPL.Flash
NCHECK 336
DUP 0
LDNW 4
CONST 2
MINUS
SWAP
STNW 4
LABEL L200
!           Files.Read(R, ch);
LINE 338
LOCAL -25
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.Read
CALL 3
!           IF ch # "O" THEN mod := NIL; error(badfile, name) END
LINE 339
LDLC -25
CONST 79
JEQ L97
CONST 0
STLW -4
LDLW 16
LDLW 12
CONST 4
GLOBAL OMSPL.error
CALL 3
LABEL L97
!       IF res >= badkey THEN importing := name END;
LINE 342
LDGW OMSPL.res
CONST 3
JLT L209
CONST 32
GLOBAL OMSPL.importing
LDLW 16
LDLW 12
CONST 1
CONST 1
GLOBAL FLEXASSIGN
CALL 6
LABEL L209
!       Texts.WriteLn(MW)
LINE 343
LDLW 36
LDLW 32
GLOBAL Texts.WriteLn
CALL 2
LABEL L72
!     newmod := mod
LINE 345
LDLW -4
LDLW 20
STOREW
RETURN
END

PROC OMSPL.Mark 88 6 OMSPL.Mark.%map
!   PROCEDURE Mark(name: ARRAY OF CHAR; VAR mm: ModMaps);
LINE 356
!   BEGIN error(noerr, name);
LINE 363
LDLW 16
LDLW 12
CONST 0
GLOBAL OMSPL.error
CALL 3
!     FindModMap(name, mm);
LINE 364
LDLW 20
LDLW 16
LDLW 12
GLOBAL OMSPL.FindModMap
CALL 3
!     IF mm.sections = NIL THEN (*load module data from object file*)
LINE 365
LDLW 20
LOADW
NCHECK 365
LDNW 36
JNEQZ L212
!       Check(name);
LINE 366
LDLW 16
LDLW 12
GLOBAL OMSPL.Check
CALL 2
!       IF res = noerr THEN F := ThisFile(name) ELSE F := NIL END ;
LINE 367
LDGW OMSPL.res
JNEQZ L215
LDLW 16
LDLW 12
GLOBAL OMSPL.ThisFile
CALLW 2
STLW -8
JUMP L213
LABEL L215
CONST 0
STLW -8
LABEL L213
!       IF F # NIL THEN
LINE 368
LDLW -8
JEQZ L218
!         Files.Set(R, F, 0); Files.ReadString(R, name1); Files.ReadInt(R, w); Files.ReadByte(R, b);
LINE 369
CONST 0
LDLW -8
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.Set
CALL 4
CONST 32
LOCAL -52
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadString
CALL 4
LOCAL -64
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadInt
CALL 3
LOCAL -54
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadByte
CALL 3
!         IF b IN {version*2, version*2+1} THEN
LINE 370
CONST 1
LDLC -54
CONST 32
BOUND 370
LSL
CONST 12
BITAND
JEQZ L221
!           IF name = name1 THEN mm.import[0] := mm;
LINE 371
CONST 32
LOCAL -52
LDLW 16
LDLW 12
GLOBAL COMPARE
CALLW 4
JNEQZ L212
LDLW 20
LOADW
LDLW 20
LOADW
NCHECK 371
STNW 40
!             Files.ReadString(R, name1);   (*imports*)
LINE 372
CONST 32
LOCAL -52
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadString
CALL 4
LABEL L225
!             WHILE (name1[0] # 0X) & (res = noerr) DO
LINE 373
LDLC -52
JEQZ L227
LDGW OMSPL.res
JNEQZ L227
!               Files.ReadInt(R, w); Mark(name1, im); INC(mm.nofimps); mm.import[mm.nofimps] := im;
LINE 374
LOCAL -64
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadInt
CALL 3
LOCAL -4
CONST 32
LOCAL -52
GLOBAL OMSPL.Mark
CALL 3
LDLW 20
LOADW
NCHECK 374
DUP 0
LDNW 104
INC
SWAP
STNW 104
LDLW -4
LDLW 20
LOADW
NCHECK 374
CONST 40
OFFSET
LDLW 20
LOADW
NCHECK 374
LDNW 104
CONST 16
BOUND 374
STIW
!               Files.ReadString(R, name1)
LINE 375
CONST 32
LOCAL -52
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadString
CALL 4
JUMP L225
LABEL L227
!             IF res = noerr THEN
LINE 377
LDGW OMSPL.res
JNEQZ L231
!               no := 0; Files.Read(R, ch);  (*sections*)
LINE 378
CONST 0
STLW -68
LOCAL -53
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.Read
CALL 3
LABEL L232
!               WHILE ch # 0X DO NEW(s); s.next := mm.sections; mm.sections := s; s.no := no;
LINE 379
LDLC -53
JEQZ L234
CONST 12
GLOBAL OMSPL.SecDepDesc
GLOBAL NEW
CALLW 2
STLW -72
LDLW 20
LOADW
NCHECK 379
LDNW 36
LDLW -72
NCHECK 379
STNW 8
LDLW -72
LDLW 20
LOADW
NCHECK 379
STNW 36
LDLW -68
LDLW -72
NCHECK 379
STOREW
!                 IF ch = "v" THEN INCL(mm.tdm[no DIV 32], no MOD 32) END; (*add the interrupt handler to do list*)
LINE 380
LDLC -53
CONST 118
JNEQ L237
LDLW 20
LOADW
NCHECK 380
CONST 428
OFFSET
LDLW -68
CONST 32
DIV
CONST 16
BOUND 380
INDEXW
DUP 0
LOADW
CONST 1
LDLW -68
CONST 32
MOD
CONST 32
BOUND 380
LSL
BITOR
SWAP
STOREW
LABEL L237
!                 Files.ReadString(R, name1); Files.ReadHalfWord(R, w);
LINE 382
CONST 32
LOCAL -52
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadString
CALL 4
LOCAL -64
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadHalfWord
CALL 3
!                 IF (ch = "c") OR (ch = "d") OR (ch = "s") OR (ch = "v") THEN
LINE 383
LDLC -53
CONST 99
JEQ L239
LDLC -53
CONST 100
JEQ L239
LDLC -53
CONST 115
JEQ L239
LDLC -53
CONST 118
JNEQ L240
LABEL L239
!                   FOR i := 0 TO w - 1 DO Files.ReadByte(R, b) END (*skip content*)
LINE 384
LDLW -64
DEC
STLW -84
CONST 0
STLW -60
LABEL L241
LDLW -60
LDLW -84
JGT L240
LOCAL -54
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadByte
CALL 3
INCL -60
JUMP L241
LABEL L240
!                 Files.ReadHalfWord(R, w); (*entering fixup data*)
LINE 386
LOCAL -64
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadHalfWord
CALL 3
LABEL L246
!                 WHILE w # 0 DO NEW(d); d.next := s.dep; s.dep := d;
LINE 387
LDLW -64
JEQZ L248
CONST 12
GLOBAL OMSPL.DependDesc
GLOBAL NEW
CALLW 2
STLW -76
LDLW -72
NCHECK 387
LDNW 4
LDLW -76
NCHECK 387
STNW 8
LDLW -76
LDLW -72
NCHECK 387
STNW 4
!                   Files.ReadByte(R, d.mno); Files.ReadHalfWord(R, d.sno); Files.ReadHalfWord(R, i); (*skip offset*)
LINE 388
LDLW -76
NCHECK 388
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadByte
CALL 3
LDLW -76
NCHECK 388
CONST 4
OFFSET
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadHalfWord
CALL 3
LOCAL -60
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadHalfWord
CALL 3
!                   Files.ReadByte(R, b); Files.ReadHalfWord(R, w);
LINE 389
LOCAL -54
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadByte
CALL 3
LOCAL -64
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadHalfWord
CALL 3
!                   IF b # 0FFH THEN NEW(d); d.next := s.dep; s.dep := d; d.mno := b; d.sno := w END;
LINE 390
LDLC -54
CONST 255
JEQ L251
CONST 12
GLOBAL OMSPL.DependDesc
GLOBAL NEW
CALLW 2
STLW -76
LDLW -72
NCHECK 390
LDNW 4
LDLW -76
NCHECK 390
STNW 8
LDLW -76
LDLW -72
NCHECK 390
STNW 4
LDLC -54
LDLW -76
NCHECK 390
STOREC
LDLW -64
LDLW -76
NCHECK 390
STNW 4
LABEL L251
!                   Files.ReadHalfWord(R, w)
LINE 391
LOCAL -64
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadHalfWord
CALL 3
JUMP L246
LABEL L248
!                 INC(no); Files.Read(R, ch)
LINE 393
INCL -68
LOCAL -53
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.Read
CALL 3
JUMP L232
LABEL L234
!               Files.ReadHalfWord(R, w); (*number of entries*)
LINE 395
LOCAL -64
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadHalfWord
CALL 3
!               FOR i := 0 TO w - 1 DO Files.ReadHalfWord(R, mm.ent[i]) END;
LINE 396
LDLW -64
DEC
STLW -88
CONST 0
STLW -60
LABEL L252
LDLW -60
LDLW -88
JGT L253
LDLW 20
LOADW
NCHECK 396
CONST 108
OFFSET
LDLW -60
CONST 64
BOUND 396
INDEXW
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadHalfWord
CALL 3
INCL -60
JUMP L252
LABEL L253
!               INCL(mm.tdm[mm.ent[0] DIV 32], mm.ent[0] MOD 32); (*add the module init section to the to do list*)
LINE 397
LDLW 20
LOADW
NCHECK 397
CONST 428
OFFSET
LDLW 20
LOADW
NCHECK 397
LDNW 108
CONST 32
DIV
CONST 16
BOUND 397
INDEXW
DUP 0
LOADW
CONST 1
LDLW 20
LOADW
NCHECK 397
LDNW 108
CONST 32
MOD
CONST 32
BOUND 397
LSL
BITOR
SWAP
STOREW
!               Files.Read(R, ch);
LINE 398
LOCAL -53
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.Read
CALL 3
!               IF ch # "O" THEN mm := NIL; error(badfile, name) END
LINE 399
LDLC -53
CONST 79
JEQ L212
CONST 0
LDLW 20
STOREW
LDLW 16
LDLW 12
CONST 4
GLOBAL OMSPL.error
CALL 3
JUMP L212
LABEL L231
!             ELSE error(badfile, name)
LINE 400
LDLW 16
LDLW 12
CONST 4
GLOBAL OMSPL.error
CALL 3
JUMP L212
LABEL L221
!         ELSE error(notsupported, name)
LINE 403
LDLW 16
LDLW 12
CONST 8
GLOBAL OMSPL.error
CALL 3
JUMP L212
LABEL L218
!       ELSE error(nofile, name);
LINE 405
LDLW 16
LDLW 12
CONST 1
GLOBAL OMSPL.error
CALL 3
LABEL L212
!     IF res = noerr THEN (*process the to do list*)
LINE 408
LDGW OMSPL.res
JNEQZ L259
LABEL L260
!       REPEAT done := TRUE;
LINE 409
CONST 1
STLC -77
!         s := mm.sections;
LINE 410
LDLW 20
LOADW
NCHECK 410
LDNW 36
STLW -72
LABEL L262
!         WHILE s # NIL DO
LINE 411
LDLW -72
JEQZ L264
!           IF s.no MOD 32 IN mm.tdm[s.no DIV 32] THEN
LINE 412
LDLW 20
LOADW
NCHECK 412
CONST 428
OFFSET
LDLW -72
NCHECK 412
LOADW
CONST 32
DIV
CONST 16
BOUND 412
LDIW
CONST 1
LDLW -72
NCHECK 412
LOADW
CONST 32
MOD
CONST 32
BOUND 412
LSL
BITAND
JEQZ L267
!             IF ~(s.no MOD 32 IN mm.refm[s.no DIV 32]) THEN
LINE 413
LDLW 20
LOADW
NCHECK 413
CONST 364
OFFSET
LDLW -72
NCHECK 413
LOADW
CONST 32
DIV
CONST 16
BOUND 413
LDIW
CONST 1
LDLW -72
NCHECK 413
LOADW
CONST 32
MOD
CONST 32
BOUND 413
LSL
BITAND
JNEQZ L270
!               INCL(mm.refm[s.no DIV 32], s.no MOD 32); (*insert in referenced map*)
LINE 414
LDLW 20
LOADW
NCHECK 414
CONST 364
OFFSET
LDLW -72
NCHECK 414
LOADW
CONST 32
DIV
CONST 16
BOUND 414
INDEXW
DUP 0
LOADW
CONST 1
LDLW -72
NCHECK 414
LOADW
CONST 32
MOD
CONST 32
BOUND 414
LSL
BITOR
SWAP
STOREW
!               d := s.dep;
LINE 415
LDLW -72
NCHECK 415
LDNW 4
STLW -76
LABEL L271
!               WHILE d # NIL DO
LINE 416
LDLW -76
JEQZ L270
!                 IF d.mno = 0 THEN (*current module*) INCL(mm.tdm[d.sno DIV 32], d.sno MOD 32)
LINE 418
LDLW -76
NCHECK 418
LOADC
JNEQZ L276
LDLW 20
LOADW
NCHECK 418
CONST 428
OFFSET
LDLW -76
NCHECK 418
LDNW 4
CONST 32
DIV
CONST 16
BOUND 418
INDEXW
DUP 0
LOADW
CONST 1
LDLW -76
NCHECK 418
LDNW 4
CONST 32
MOD
CONST 32
BOUND 418
LSL
BITOR
SWAP
STOREW
JUMP L274
LABEL L276
!                 ELSE (*imported*) im := mm.import[d.mno]; i := im.ent[d.sno];
LINE 419
LDLW 20
LOADW
NCHECK 419
CONST 40
OFFSET
LDLW -76
NCHECK 419
LOADC
CONST 16
BOUND 419
LDIW
STLW -4
LDLW -4
NCHECK 419
CONST 108
OFFSET
LDLW -76
NCHECK 419
LDNW 4
CONST 64
BOUND 419
LDIW
STLW -60
!                   INCL(im.tdm[i DIV 32], i MOD 32);
LINE 420
LDLW -4
NCHECK 420
CONST 428
OFFSET
LDLW -60
CONST 32
DIV
CONST 16
BOUND 420
INDEXW
DUP 0
LOADW
CONST 1
LDLW -60
CONST 32
MOD
CONST 32
BOUND 420
LSL
BITOR
SWAP
STOREW
LABEL L274
!                 done := FALSE;
LINE 422
CONST 0
STLC -77
!                 d := d.next
LINE 423
LDLW -76
NCHECK 423
LDNW 8
STLW -76
JUMP L271
LABEL L270
!             EXCL(mm.tdm[s.no DIV 32], s.no MOD 32); (*remove from to do list*)
LINE 426
LDLW 20
LOADW
NCHECK 426
CONST 428
OFFSET
LDLW -72
NCHECK 426
LOADW
CONST 32
DIV
CONST 16
BOUND 426
INDEXW
DUP 0
LOADW
CONST 1
LDLW -72
NCHECK 426
LOADW
CONST 32
MOD
CONST 32
BOUND 426
LSL
BITNOT
BITAND
SWAP
STOREW
LABEL L267
!           s := s.next
LINE 428
LDLW -72
NCHECK 428
LDNW 8
STLW -72
JUMP L262
LABEL L264
!       UNTIL done
LINE 430
LDLC -77
JEQZ L260
LABEL L259
!     i := 1; WHILE (res = noerr) & (i <= mm.nofimps) DO Mark(mm.import[i].name, im); INC(i) END
LINE 432
CONST 1
STLW -60
LABEL L277
LDGW OMSPL.res
JNEQZ L279
LDLW -60
LDLW 20
LOADW
NCHECK 432
LDNW 104
JGT L279
LOCAL -4
LDLW 20
LOADW
NCHECK 432
CONST 40
OFFSET
LDLW -60
CONST 16
BOUND 432
LDIW
CONST 32
SWAP
NCHECK 432
GLOBAL OMSPL.Mark
CALL 3
INCL -60
JUMP L277
LABEL L279
RETURN
END

PROC OMSPL.Link 24788 9 OMSPL.Link.%map
!   PROCEDURE Link*;  (*link multiple object files together and create a single MSP430 TI-TXT file M.txt from them*)
LINE 435
!   BEGIN Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S); res := noerr; count := 0;
LINE 444
GLOBAL Oberon.Par
LDNW 4
LDGW Oberon.Par
GLOBAL Texts.Scanner
LOCAL -160
GLOBAL Texts.OpenScanner
CALL 4
GLOBAL Texts.Scanner
LOCAL -160
GLOBAL Texts.Scan
CALL 2
CONST 0
STGW OMSPL.res
CONST 0
STLW -20
!     Flash := SYSTEM.VAL(Segment, Modules.AllocPtr); FOR i := 0 TO 31 DO vector[i] := 0FFFFH END;
LINE 445
LDGW Modules.AllocPtr
STGW OMSPL.Flash
CONST 0
STLW -4
LABEL L281
LDLW -4
CONST 31
JGT L282
CONST 65535
GLOBAL OMSPL.vector
LDLW -4
CONST 32
BOUND 445
STIW
INCL -4
JUMP L281
LABEL L282
!     IF S.class = Texts.Int THEN  vecsize := S.i; Texts.Scan(S) ELSE vecsize := 0; res := nopar END;
LINE 446
LDLW -120
CONST 3
JNEQ L285
LDLQ -116
CONVQN
STLW -12
GLOBAL Texts.Scanner
LOCAL -160
GLOBAL Texts.Scan
CALL 2
JUMP L283
LABEL L285
CONST 0
STLW -12
CONST 6
STGW OMSPL.res
LABEL L283
!     IF S.class = Texts.Int THEN  limit := S.i - vecsize; Flash.origin := FlashEnd - S.i; Flash.allocPtr := 0; Texts.Scan(S) ELSE res := nopar END;
LINE 447
LDLW -120
CONST 3
JNEQ L288
LDLQ -116
LDLW -12
CONVNQ
QMINUS
CONVQN
STGW OMSPL.limit
QCONST 65536
LDLQ -116
QMINUS
CONVQN
LDGW OMSPL.Flash
NCHECK 447
STOREW
CONST 0
LDGW OMSPL.Flash
NCHECK 447
STNW 4
GLOBAL Texts.Scanner
LOCAL -160
GLOBAL Texts.Scan
CALL 2
JUMP L286
LABEL L288
CONST 6
STGW OMSPL.res
LABEL L286
!     IF (res = noerr) & (S.class = Texts.Int) THEN RAMLimit := RAMOrigin + S.i; RAMAllocPtr := RAMOrigin; Texts.Scan(S) ELSE res := nopar END;
LINE 448
LDGW OMSPL.res
JNEQZ L291
LDLW -120
CONST 3
JNEQ L291
LDLQ -116
CONST 512
CONVNQ
QPLUS
CONVQN
STGW OMSPL.RAMLimit
CONST 512
STGW OMSPL.RAMAllocPtr
GLOBAL Texts.Scanner
LOCAL -160
GLOBAL Texts.Scan
CALL 2
JUMP L289
LABEL L291
CONST 6
STGW OMSPL.res
LABEL L289
!     IF (res = noerr) & (S.class = Texts.Name) THEN nbmod := 0;
LINE 449
LDGW OMSPL.res
JNEQZ L295
LDLW -120
CONST 1
JNEQ L295
CONST 0
STLW -2256
LABEL L296
!       REPEAT FOR i := 0 TO LEN(S.s)-1 DO modlist[nbmod][i] := S.s[i] END;
LINE 450
CONST 0
STLW -4
LABEL L298
LDLW -4
CONST 31
JGT L299
LOCAL -96
LDLW -4
CONST 32
BOUND 450
LDIC
LOCAL -2252
LDLW -2256
CONST 64
BOUND 450
CONST 32
TIMES
LDLW -4
CONST 32
BOUND 450
PLUS
STIC
INCL -4
JUMP L298
LABEL L299
!         INC(nbmod); Texts.Scan(S)
LINE 451
INCL -2256
GLOBAL Texts.Scanner
LOCAL -160
GLOBAL Texts.Scan
CALL 2
!       UNTIL S.class # Texts.Name;
LINE 452
LDLW -120
CONST 1
JEQ L296
!       maps := NIL; mi := 0; REPEAT Mark(modlist[mi], MM); INC(mi) UNTIL (mi >= nbmod) OR (res # noerr);
LINE 453
CONST 0
STGW OMSPL.maps
CONST 0
STLW -2260
LABEL L300
LOCAL -172
CONST 32
LOCAL -2252
LDLW -2260
CONST 64
BOUND 453
CONST 32
TIMES
OFFSET
GLOBAL OMSPL.Mark
CALL 3
INCL -2260
LDLW -2260
LDLW -2256
JGEQ L301
LDGW OMSPL.res
JEQZ L300
LABEL L301
!       NEW(MT); Texts.Open(MT, ""); Texts.OpenWriter(MW);
LINE 454
CONST 24
GLOBAL Texts.TextDesc
GLOBAL NEW
CALLW 2
STLW -44
CONST 1
GLOBAL OMSPL.%5
LDLW -44
GLOBAL Texts.Open
CALL 3
GLOBAL Texts.Writer
LOCAL -64
GLOBAL Texts.OpenWriter
CALL 2
!       first := NIL; last := NIL; mi := 0; REPEAT LinkOne(modlist[mi], M, sec, MW); INC(mi) UNTIL (mi >= nbmod) OR (res # noerr);
LINE 455
CONST 0
STGW OMSPL.first
CONST 0
STGW OMSPL.last
CONST 0
STLW -2260
LABEL L303
GLOBAL Texts.Writer
LOCAL -64
CONST 512
LOCAL -24788
LOCAL -164
CONST 32
LOCAL -2252
LDLW -2260
CONST 64
BOUND 455
CONST 32
TIMES
OFFSET
GLOBAL OMSPL.LinkOne
CALL 7
INCL -2260
LDLW -2260
LDLW -2256
JGEQ L304
LDGW OMSPL.res
JEQZ L303
LABEL L304
!       Texts.Append(MT, MW.buf);
LINE 456
LDLW -64
LDLW -44
GLOBAL Texts.Append
CALL 2
!       IF res = noerr THEN Texts.WriteString(W, "  linking");
LINE 457
LDGW OMSPL.res
JNEQZ L308
CONST 10
GLOBAL OMSPL.%6
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
!         (*prolog*) padFlash; vector[31] := Flash.origin + Flash.allocPtr; p := first;
LINE 458
GLOBAL OMSPL.padFlash
CALL 0
LDGW OMSPL.Flash
NCHECK 458
LOADW
LDGW OMSPL.Flash
NCHECK 458
LDNW 4
PLUS
GLOBAL OMSPL.vector
STNW 124
LDGW OMSPL.first
STLW -168
!         (*MOV RAMLimit, SP*) EmitWord(4031H); EmitWord(RAMLimit);
LINE 459
CONST 16433
GLOBAL OMSPL.EmitWord
CALL 1
LDGW OMSPL.RAMLimit
GLOBAL OMSPL.EmitWord
CALL 1
LABEL L309
!         WHILE p # NIL DO (*fixup*) Texts.Write(W, " "); Texts.WriteString(W, p.name);
LINE 460
LDLW -168
JEQZ L308
CONST 32
ALIGNC
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.Write
CALL 3
CONST 32
LDLW -168
NCHECK 460
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
!           IF p.codeseg = 1 THEN (*module executed from RAM*) Texts.Write(W, "*");
LINE 461
LDLW -168
NCHECK 461
CONST 316
LDIC
CONST 1
JNEQ L314
CONST 42
ALIGNC
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.Write
CALL 3
!             (*MOV p.flashsize DIV 2,R15*) EmitWord(403FH); EmitWord(p.flashsize DIV 2);
LINE 463
CONST 16447
GLOBAL OMSPL.EmitWord
CALL 1
LDLW -168
NCHECK 463
LDNW 56
CONST 2
DIV
GLOBAL OMSPL.EmitWord
CALL 1
!             (*MOV Flash.origin + p.flashsto,R14*) EmitWord(403EH);  EmitWord(Flash.origin + p.flashsto);
LINE 464
CONST 16446
GLOBAL OMSPL.EmitWord
CALL 1
LDGW OMSPL.Flash
NCHECK 464
LOADW
LDLW -168
NCHECK 464
LDNW 48
PLUS
GLOBAL OMSPL.EmitWord
CALL 1
!             (*MOV @R14+,p.codeexe - (Flash.origin + p.flashsto)(R14) - 2*) EmitWord(4EBEH); EmitWord(p.codeexe - Flash.origin - p.flashsto - 2);
LINE 465
CONST 20158
GLOBAL OMSPL.EmitWord
CALL 1
LDLW -168
NCHECK 465
LDNW 52
LDGW OMSPL.Flash
NCHECK 465
LOADW
MINUS
LDLW -168
NCHECK 465
LDNW 48
MINUS
CONST 2
MINUS
GLOBAL OMSPL.EmitWord
CALL 1
!             (*SUB #1,R15*) EmitWord(831FH);
LINE 466
CONST 33567
GLOBAL OMSPL.EmitWord
CALL 1
!             (*JNE $-8*) EmitWord(23FCH)
LINE 467
CONST 9212
GLOBAL OMSPL.EmitWord
CALL 1
LABEL L314
!           INC(count); IF count MOD 8 = 0 THEN count := 0; Texts.WriteLn(W) END;
LINE 469
INCL -20
LDLW -20
CONST 8
MOD
JNEQZ L317
CONST 0
STLW -20
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteLn
CALL 2
LABEL L317
!           IF p.ent[0] >= 0 THEN (*init code present: CALL p.ent[0]*); EmitWord(12B0H); EmitWord(p.ent[0]) END;
LINE 470
LDLW -168
NCHECK 470
LDNW 60
JLTZ L320
CONST 4784
GLOBAL OMSPL.EmitWord
CALL 1
LDLW -168
NCHECK 470
LDNW 60
GLOBAL OMSPL.EmitWord
CALL 1
LABEL L320
!           p := p.next
LINE 471
LDLW -168
NCHECK 471
LDNW 32
STLW -168
JUMP L309
LABEL L308
!       IF (res = noerr) & (M.ent[0] < 0) THEN error(noinit, M.name) END;
LINE 474
LDGW OMSPL.res
JNEQZ L323
LDLW -164
NCHECK 474
LDNW 60
JGEQZ L323
CONST 32
LDLW -164
NCHECK 474
CONST 7
GLOBAL OMSPL.error
CALL 3
LABEL L323
!       IF res = noerr THEN
LINE 475
LDGW OMSPL.res
JNEQZ L342
!         MakeFileName(name, S.s, ".txt"); F := Files.New(name); Files.Set(R, F, 0);
LINE 476
CONST 5
GLOBAL OMSPL.%7
CONST 32
LOCAL -96
CONST 32
LOCAL -204
GLOBAL OMSPL.MakeFileName
CALL 6
CONST 32
LOCAL -204
GLOBAL POFiles.New
CALLW 2
STLW -28
CONST 0
LDLW -28
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL POFiles.Set
CALL 4
!         i := 32 - vecsize DIV 2; isrtrap := -1; (*install default ISR trap if required*)
LINE 477
CONST 32
LDLW -12
CONST 2
DIV
MINUS
STLW -4
CONST -1
STLW -16
LABEL L343
!           IF vector[i] = 0FFFFH THEN (*isrtrap is needed*) isrtrap := Flash.origin + Flash.allocPtr;
LINE 479
GLOBAL OMSPL.vector
LDLW -4
CONST 32
BOUND 479
LDIW
CONST 65535
JNEQ L348
LDGW OMSPL.Flash
NCHECK 479
LOADW
LDGW OMSPL.Flash
NCHECK 479
LDNW 4
PLUS
STLW -16
!             EmitWord(0D032H); EmitWord( 0010H); EmitWord(3FFDH) END;
LINE 480
CONST 53298
GLOBAL OMSPL.EmitWord
CALL 1
CONST 16
GLOBAL OMSPL.EmitWord
CALL 1
CONST 16381
GLOBAL OMSPL.EmitWord
CALL 1
LABEL L348
!           INC(i)
LINE 481
INCL -4
!         UNTIL (i >= 31) OR (isrtrap > 0);
LINE 482
LDLW -4
CONST 31
JGEQ L344
LDLW -16
JLEQZ L343
LABEL L344
!         i := 0; Files.Write(R, "@"); FilesEx.WriteHexHalfWord(R, Flash.origin); FilesEx.WriteLn(R); (*code*)
LINE 484
CONST 0
STLW -4
CONST 64
ALIGNC
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL POFiles.Write
CALL 3
LDGW OMSPL.Flash
NCHECK 484
LOADW
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL FilesEx.WriteHexHalfWord
CALL 3
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL FilesEx.WriteLn
CALL 2
LABEL L349
!         WHILE i < Flash.allocPtr DO
LINE 485
LDLW -4
LDGW OMSPL.Flash
NCHECK 485
LDNW 4
JGEQ L351
!           FilesEx.WriteHex(R, Flash.m[i]); Files.Write(R, " "); INC(i);
LINE 486
LDGW OMSPL.Flash
NCHECK 486
CONST 8
OFFSET
LDLW -4
CONST 65536
BOUND 486
OFFSET
LOADC
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL FilesEx.WriteHex
CALL 3
CONST 32
ALIGNC
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL POFiles.Write
CALL 3
INCL -4
!           IF i MOD 16 = 0 THEN FilesEx.WriteLn(R) END
LINE 487
LDLW -4
CONST 16
MOD
JNEQZ L349
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL FilesEx.WriteLn
CALL 2
JUMP L349
LABEL L351
!         IF i MOD 16 # 0 THEN FilesEx.WriteLn(R) END;
LINE 489
LDLW -4
CONST 16
MOD
JEQZ L357
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL FilesEx.WriteLn
CALL 2
LABEL L357
!         i := 0; x := 32 - vecsize DIV 2; Files.Write(R, "@"); FilesEx.WriteHexHalfWord(R, FlashEnd - vecsize); FilesEx.WriteLn(R); (*vector table*)
LINE 490
CONST 0
STLW -4
CONST 32
LDLW -12
CONST 2
DIV
MINUS
STLW -8
CONST 64
ALIGNC
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL POFiles.Write
CALL 3
CONST 65536
LDLW -12
MINUS
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL FilesEx.WriteHexHalfWord
CALL 3
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL FilesEx.WriteLn
CALL 2
LABEL L358
!         WHILE x < 32 DO IF vector[x] = 0FFFFH THEN vector[x] := isrtrap END;
LINE 491
LDLW -8
CONST 32
JGEQ L360
GLOBAL OMSPL.vector
LDLW -8
CONST 32
BOUND 491
LDIW
CONST 65535
JNEQ L363
LDLW -16
GLOBAL OMSPL.vector
LDLW -8
CONST 32
BOUND 491
STIW
LABEL L363
!           FilesEx.WriteHex(R, vector[x] MOD 100H); Files.Write(R, " ");
LINE 492
GLOBAL OMSPL.vector
LDLW -8
CONST 32
BOUND 492
LDIW
CONST 256
MOD
CONVNC
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL FilesEx.WriteHex
CALL 3
CONST 32
ALIGNC
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL POFiles.Write
CALL 3
!           FilesEx.WriteHex(R, vector[x] DIV 100H MOD 100H); Files.Write(R, " ");
LINE 493
GLOBAL OMSPL.vector
LDLW -8
CONST 32
BOUND 493
LDIW
CONST 256
DIV
CONST 256
MOD
CONVNC
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL FilesEx.WriteHex
CALL 3
CONST 32
ALIGNC
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL POFiles.Write
CALL 3
!           INC(i,2); IF i MOD 16 = 0 THEN FilesEx.WriteLn(R) END;
LINE 494
LDLW -4
CONST 2
PLUS
STLW -4
LDLW -4
CONST 16
MOD
JNEQZ L366
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL FilesEx.WriteLn
CALL 2
LABEL L366
!           INC(x)
LINE 495
INCL -8
JUMP L358
LABEL L360
!         IF i MOD 16 # 0 THEN FilesEx.WriteLn(R) END;
LINE 497
LDLW -4
CONST 16
MOD
JEQZ L369
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL FilesEx.WriteLn
CALL 2
LABEL L369
!         Files.Write(R, "q"); FilesEx.WriteLn(R);
LINE 498
CONST 113
ALIGNC
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL POFiles.Write
CALL 3
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL FilesEx.WriteLn
CALL 2
!         Files.Register(F);
LINE 499
LDLW -28
GLOBAL POFiles.Register
CALL 1
!         IF count MOD 8 # 0 THEN count := 0; Texts.WriteLn(W) END;
LINE 500
LDLW -20
CONST 8
MOD
JEQZ L372
CONST 0
STLW -20
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteLn
CALL 2
LABEL L372
!         Texts.WriteString(W, "    flash"); Texts.WriteInt(W, Flash.allocPtr, 5);
LINE 501
CONST 10
GLOBAL OMSPL.%8
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
CONST 5
LDGW OMSPL.Flash
NCHECK 501
LDNW 4
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteInt
CALL 4
!         Texts.WriteString(W, ", data"); Texts.WriteInt(W, RAMAllocPtr - RAMOrigin, 5);
LINE 502
CONST 7
GLOBAL OMSPL.%9
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
CONST 5
LDGW OMSPL.RAMAllocPtr
CONST 512
MINUS
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteInt
CALL 4
!         Texts.WriteString(W, ", stack"); Texts.WriteInt(W, RAMLimit - RAMAllocPtr, 5);
LINE 503
CONST 8
GLOBAL OMSPL.%10
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
CONST 5
LDGW OMSPL.RAMLimit
LDGW OMSPL.RAMAllocPtr
MINUS
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteInt
CALL 4
!         Texts.WriteString(W, " bytes")
LINE 504
CONST 7
GLOBAL OMSPL.%11
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
JUMP L325
LABEL L342
!       ELSE  Texts.WriteLn(W); oldcol := W.col; W.col := Display.red;
LINE 505
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteLn
CALL 2
GLOBAL OMSPL.W
LDNW 4
STLW -24
CONST 224
GLOBAL OMSPL.W
STNW 4
!         Texts.WriteString(W, "Link error:  "); Texts.WriteString(W, importing);
LINE 506
CONST 14
GLOBAL OMSPL.%12
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
CONST 32
GLOBAL OMSPL.importing
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
!         IF res = nofile THEN Texts.WriteString(W, " module not found")
LINE 507
LDGW OMSPL.res
CONST 1
JNEQ L328
CONST 18
GLOBAL OMSPL.%13
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
JUMP L340
LABEL L328
!         ELSIF res = duphandler THEN Texts.WriteString(W, " duplicate interrupt handler")
LINE 508
LDGW OMSPL.res
CONST 2
JNEQ L330
CONST 29
GLOBAL OMSPL.%14
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
JUMP L340
LABEL L330
!         ELSIF res = badkey THEN Texts.WriteString(W, " imports ");
LINE 509
LDGW OMSPL.res
CONST 3
JNEQ L332
CONST 10
GLOBAL OMSPL.%15
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
!           Texts.WriteString(W, imported); Texts.WriteString(W, " with bad key")
LINE 510
CONST 32
GLOBAL OMSPL.imported
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
CONST 14
GLOBAL OMSPL.%16
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
JUMP L340
LABEL L332
!         ELSIF res = badfile THEN Texts.WriteString(W, " corrupted obj file")
LINE 511
LDGW OMSPL.res
CONST 4
JNEQ L334
CONST 20
GLOBAL OMSPL.%17
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
JUMP L340
LABEL L334
!         ELSIF res = nospace THEN Texts.WriteString(W, " insufficient space")
LINE 512
LDGW OMSPL.res
CONST 5
JNEQ L336
CONST 20
GLOBAL OMSPL.%18
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
JUMP L340
LABEL L336
!         ELSIF res = noinit THEN Texts.WriteString(W, " top module init code missing")
LINE 513
LDGW OMSPL.res
CONST 7
JNEQ L338
CONST 30
GLOBAL OMSPL.%19
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
JUMP L340
LABEL L338
!         ELSIF res = notsupported THEN Texts.WriteString(W, " version not supported")
LINE 514
LDGW OMSPL.res
CONST 8
JNEQ L340
CONST 23
GLOBAL OMSPL.%20
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
LABEL L340
!         END; W.col := oldcol
LINE 515
LDLW -24
GLOBAL OMSPL.W
STNW 4
LABEL L325
!       MakeFileName(name, S.s, ".map"); Texts.Close(MT, name)
LINE 517
CONST 5
GLOBAL OMSPL.%21
CONST 32
LOCAL -96
CONST 32
LOCAL -204
GLOBAL OMSPL.MakeFileName
CALL 6
CONST 32
LOCAL -204
LDLW -44
GLOBAL Texts.Close
CALL 3
JUMP L293
LABEL L295
!     ELSE Texts.WriteString(W, "Usage: OMSPL.Link VectorTableSize FlashSize RAMSize [module...] topmodule")
LINE 518
CONST 74
GLOBAL OMSPL.%22
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
LABEL L293
!     Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf);
LINE 520
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteLn
CALL 2
LDGW OMSPL.W
LDGW Oberon.Log
GLOBAL Texts.Append
CALL 2
!     first := NIL; last := NIL; maps := NIL
LINE 521
CONST 0
STGW OMSPL.first
CONST 0
STGW OMSPL.last
CONST 0
STGW OMSPL.maps
RETURN
END

PROC OMSPL.%main 0 5 0
! BEGIN Texts.OpenWriter(W); Texts.WriteString(W, "OMSP linker  AP 6.8.20 / CS 26.10.25");
LINE 524
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.OpenWriter
CALL 2
CONST 37
GLOBAL OMSPL.%23
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
!   Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf);
LINE 525
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteLn
CALL 2
LDGW OMSPL.W
LDGW Oberon.Log
GLOBAL Texts.Append
CALL 2
RETURN
END

! Global variables
GLOVAR OMSPL.first 4
GLOVAR OMSPL.last 4
GLOVAR OMSPL.maps 4
GLOVAR OMSPL.RAMAllocPtr 4
GLOVAR OMSPL.RAMLimit 4
GLOVAR OMSPL.limit 4
GLOVAR OMSPL.res 4
GLOVAR OMSPL.Flash 4
GLOVAR OMSPL.vector 128
GLOVAR OMSPL.importing 32
GLOVAR OMSPL.imported 32
GLOVAR OMSPL.W 20

! Global pointer map
DEFINE OMSPL.%gcmap
WORD GC_POINTER
WORD OMSPL.first
WORD GC_POINTER
WORD OMSPL.last
WORD GC_POINTER
WORD OMSPL.maps
WORD GC_POINTER
WORD OMSPL.Flash
WORD GC_BASE
WORD OMSPL.W
WORD 0x00000023
WORD GC_END

! String ".mpc"
DEFINE OMSPL.%1
STRING 2E6D706300

! String "Module "
DEFINE OMSPL.%2
STRING 4D6F64756C652000

! String "codeexe"
DEFINE OMSPL.%3
STRING 636F646565786500

! String "interrupt vector number"
DEFINE OMSPL.%4
STRING 696E7465727275707420766563746F72206E756D62657200

! String ""
DEFINE OMSPL.%5
STRING 00

! String "  linking"
DEFINE OMSPL.%6
STRING 20206C696E6B696E6700

! String ".txt"
DEFINE OMSPL.%7
STRING 2E74787400

! String "    flash"
DEFINE OMSPL.%8
STRING 20202020666C61736800

! String ", data"
DEFINE OMSPL.%9
STRING 2C206461746100

! String ", stack"
DEFINE OMSPL.%10
STRING 2C20737461636B00

! String " bytes"
DEFINE OMSPL.%11
STRING 20627974657300

! String "Link error:  "
DEFINE OMSPL.%12
STRING 4C696E6B206572726F723A202000

! String " module not found"
DEFINE OMSPL.%13
STRING 206D6F64756C65206E6F7420666F756E6400

! String " duplicate interrupt handler"
DEFINE OMSPL.%14
STRING 206475706C696361746520696E746572727570742068616E646C657200

! String " imports "
DEFINE OMSPL.%15
STRING 20696D706F7274732000

! String " with bad key"
DEFINE OMSPL.%16
STRING 207769746820626164206B657900

! String " corrupted obj file"
DEFINE OMSPL.%17
STRING 20636F72727570746564206F626A2066696C6500

! String " insufficient space"
DEFINE OMSPL.%18
STRING 20696E73756666696369656E7420737061636500

! String " top module init code missing"
DEFINE OMSPL.%19
STRING 20746F70206D6F64756C6520696E697420636F6465206D697373696E6700

! String " version not supported"
DEFINE OMSPL.%20
STRING 2076657273696F6E206E6F7420737570706F7274656400

! String ".map"
DEFINE OMSPL.%21
STRING 2E6D617000

! String "Usage: OMSPL.Link VectorTableSize FlashSize RAMSize [module...] topmodule"
DEFINE OMSPL.%22
STRING 55736167653A204F4D53504C2E4C696E6B20566563746F725461626C6553697A
STRING 6520466C61736853697A652052414D53697A65205B6D6F64756C652E2E2E5D20
STRING 746F706D6F64756C6500

! String "OMSP linker  AP 6.8.20 / CS 26.10.25"
DEFINE OMSPL.%23
STRING 4F4D5350206C696E6B65722020415020362E382E3230202F2043532032362E31
STRING 302E323500

! Descriptor for ModDesc
DEFINE OMSPL.ModDesc
WORD 0x00000201
WORD 0
WORD OMSPL.ModDesc.%anc

DEFINE OMSPL.ModDesc.%anc
WORD OMSPL.ModDesc

! Descriptor for SegmentDesc
DEFINE OMSPL.SegmentDesc
WORD 0
WORD 0
WORD OMSPL.SegmentDesc.%anc

DEFINE OMSPL.SegmentDesc.%anc
WORD OMSPL.SegmentDesc

! Descriptor for Section
DEFINE OMSPL.Section
WORD 0
WORD 0
WORD OMSPL.Section.%anc

DEFINE OMSPL.Section.%anc
WORD OMSPL.Section

! Descriptor for DependDesc
DEFINE OMSPL.DependDesc
WORD 0x00000009
WORD 0
WORD OMSPL.DependDesc.%anc

DEFINE OMSPL.DependDesc.%anc
WORD OMSPL.DependDesc

! Descriptor for SecDepDesc
DEFINE OMSPL.SecDepDesc
WORD 0x0000000d
WORD 0
WORD OMSPL.SecDepDesc.%anc

DEFINE OMSPL.SecDepDesc.%anc
WORD OMSPL.SecDepDesc

! Descriptor for ModMapsDesc
DEFINE OMSPL.ModMapsDesc
WORD 0x07fffe01
WORD 0
WORD OMSPL.ModMapsDesc.%anc

DEFINE OMSPL.ModMapsDesc.%anc
WORD OMSPL.ModMapsDesc

! Pointer maps
DEFINE OMSPL.LinkOne.%map
WORD 12
WORD 20
WORD 24
WORD 32
WORD -4
WORD -8
WORD -88
WORD -92
WORD GC_BLOCK
WORD -164
WORD 16
WORD -308
WORD GC_END

DEFINE OMSPL.Mark.%map
WORD 12
WORD 20
WORD -4
WORD -8
WORD -12
WORD -72
WORD -76
WORD GC_END

DEFINE OMSPL.Link.%map
WORD -28
WORD -32
WORD -44
WORD -64
WORD -48
WORD -152
WORD -132
WORD -164
WORD -168
WORD -172
WORD GC_END

! End of file
