!! (SYMFILE #OMSPP 0x00030300 #OMSPP.%main 1 #OMSPP.Mod)
!! (TYPE #PtrBase !1 (POINTER))
!! (TARGET =1 !2 (RECORD #OMSPP.PtrBaseDesc 40 VOID
!!     (FIELD #name 0 ?3 #OMSPS 1 #Ident (ARRAY 32 CHAR))
!!     (FIELD #type 32 ?4 #OMSPB 3 #Type (POINTER))
!!     (FIELD #next 36 =1)))
!! (TARGET =4 ?5 #OMSPB 5 #TypeDesc (RECORD #OMSPB.TypeDesc 44 VOID
!!     (FIELD #form* 0 INTEGER)
!!     (FIELD #ref* 4 INTEGER)
!!     (FIELD #mno* 8 INTEGER)
!!     (FIELD #nofpar* 12 INTEGER)
!!     (FIELD #len* 16 INTEGER)
!!     (FIELD #dsc* 20 ?6 #OMSPB 1 #Object (POINTER))
!!     (FIELD #typobj* 24 =6)
!!     (FIELD #base* 28 =4)
!!     (FIELD #size* 32 INTEGER)
!!     (FIELD #leaf* 36 BOOLEAN)
!!     (FIELD #ur* 40 SET)))
!! (TARGET =6 ?7 #OMSPB 2 #ObjDesc (RECORD #OMSPB.ObjDesc 60 VOID
!!     (FIELD #class* 0 BYTE)
!!     (FIELD #exno* 1 BYTE)
!!     (FIELD #register* 2 BYTE)
!!     (FIELD #expo* 3 BOOLEAN)
!!     (FIELD #unsafe* 4 BOOLEAN)
!!     (FIELD #rdo* 5 BOOLEAN)
!!     (FIELD #lev* 8 INTEGER)
!!     (FIELD #next* 12 =6)
!!     (FIELD #dsc* 16 =6)
!!     (FIELD #type* 20 =4)
!!     (FIELD #name* 24 =3)
!!     (FIELD #val* 56 INTEGER)))
!! (TYPE #PtrBaseDesc =2)
!! (GLOBAL #sym #OMSPP.sym INTEGER)
!! (GLOBAL #level #OMSPP.level INTEGER)
!! (GLOBAL #exno #OMSPP.exno INTEGER)
!! (GLOBAL #newSF #OMSPP.newSF BOOLEAN)
!! (GLOBAL #initmode #OMSPP.initmode BOOLEAN)
!! (DEF ?8 #OMSPG 2 #Item (RECORD #OMSPG.Item 44 ?9 #OMSPA 3 #Item (RECORD #OMSPA.Item 8 VOID
!!       (FIELD #reg* 0 BYTE)
!!       (FIELD #am* 1 BYTE)
!!       (FIELD #ofs* 4 INTEGER))
!!     (FIELD #reg* 0 BYTE)
!!     (FIELD #am* 1 BYTE)
!!     (FIELD #ofs* 4 INTEGER)
!!     (FIELD #mode* 8 INTEGER)
!!     (FIELD #type* 12 =4)
!!     (FIELD #obj* 16 =6)
!!     (FIELD #a* 20 INTEGER)
!!     (FIELD #b* 24 INTEGER)
!!     (FIELD #c* 28 INTEGER)
!!     (FIELD #mnor 32 BYTE)
!!     (FIELD #snor 36 INTEGER)
!!     (FIELD #rdo* 40 BOOLEAN)
!!     (FIELD #tmp 41 BOOLEAN)
!!     (FIELD #ladr 42 BOOLEAN)
!!     (FIELD #ptr 43 BOOLEAN)))
!! (GLOBAL #expression #OMSPP.expression !10 (PROC 2 VOID
!!     (VPARAM #x 12 =8)))
!! (GLOBAL #Type #OMSPP.Type !11 (PROC 1 VOID
!!     (VPARAM #type 12 =4)))
!! (GLOBAL #FormalType #OMSPP.FormalType !12 (PROC 2 VOID
!!     (VPARAM #typ 12 =4)
!!     (PARAM #dim 16 INTEGER)))
!! (GLOBAL #modid #OMSPP.modid =3)
!! (GLOBAL #pbsList #OMSPP.pbsList =1)
!! (GLOBAL #dummy #OMSPP.dummy =6)
!! (GLOBAL #isLeaf #OMSPP.isLeaf BOOLEAN)
!! (GLOBAL #isInt #OMSPP.isInt BOOLEAN)
!! (GLOBAL #codeseg #OMSPP.codeseg BYTE)
!! (GLOBAL #W #OMSPP.W ?13 #Texts 17 #Writer (RECORD #Texts.Writer 20 VOID
!!     (FIELD #buf* 0 ?14 #Texts 15 #Buffer (POINTER))
!!     (FIELD #col* 4 INTEGER)
!!     (FIELD #rider 8 ?15 #POFiles 6 #Rider (RECORD #POFiles.Rider 12 VOID
!!         (FIELD #eof* 0 BOOLEAN)
!!         (FIELD #res* 4 INTEGER)
!!         (FIELD #base 8 ?16 #POFiles 1 #File (POINTER))))))
!! (TARGET =16 ?17 #POFiles 2 #FileDesc (RECORD #POFiles.FileDesc 68 VOID
!!     (FIELD #file 0 ?18 #Files 1 #File (POINTER))
!!     (FIELD #tmpName 4 ?19 #POFiles 4 ANON (ARRAY 32 CHAR))
!!     (FIELD #name 36 =19)))
!! (TARGET =18 ?20 #Files 2 #FileDesc (RECORD #Files.FileDesc 8 VOID
!!     (FIELD #file- 0 SYSTEM.LONGPTR)))
!! (TARGET =14 ?21 #Texts 16 #BufDesc (RECORD #Texts.BufDesc 12 VOID
!!     (FIELD #len* 0 INTEGER)
!!     (FIELD #header 4 ?22 #Texts 1 #Piece (POINTER))
!!     (FIELD #last 8 =22)))
!! (TARGET =22 ?23 #Texts 2 #PieceDesc (RECORD #Texts.PieceDesc 24 VOID
!!     (FIELD #f 0 =16)
!!     (FIELD #off 4 INTEGER)
!!     (FIELD #len 8 INTEGER)
!!     (FIELD #col 12 INTEGER)
!!     (FIELD #prev 16 =22)
!!     (FIELD #next 20 =22)))
!! (DEF !24 (FLEX CHAR))
!! (PROCEDURE #Check 28 #OMSPP.Check !25 (PROC 3 VOID
!!     (PARAM #s 12 INTEGER)
!!     (CPARAM #msg 16 =24)))
!! (PROCEDURE #qualident 33 #OMSPP.qualident !26 (PROC 1 VOID
!!     (VPARAM #obj 12 =6)))
!! (PROCEDURE #CheckBool 44 #OMSPP.CheckBool !27 (PROC 2 VOID
!!     (VPARAM #x 12 =8)))
!! (PROCEDURE #CheckInt 49 #OMSPP.CheckInt !28 (PROC 2 VOID
!!     (VPARAM #x 12 =8)))
!! (PROCEDURE #CheckSet 54 #OMSPP.CheckSet !29 (PROC 2 VOID
!!     (VPARAM #x 12 =8)))
!! (PROCEDURE #CheckSetVal 59 #OMSPP.CheckSetVal !30 (PROC 2 VOID
!!     (VPARAM #x 12 =8)))
!! (PROCEDURE #CheckConst 67 #OMSPP.CheckConst !31 (PROC 2 VOID
!!     (VPARAM #x 12 =8)))
!! (PROCEDURE #CheckReadOnly 72 #OMSPP.CheckReadOnly !32 (PROC 2 VOID
!!     (VPARAM #x 12 =8)))
!! (PROCEDURE #CheckExport 76 #OMSPP.CheckExport !33 (PROC 1 VOID
!!     (VPARAM #expo 12 BOOLEAN)))
!! (PROCEDURE #CheckUnsafeMarking 85 #OMSPP.CheckUnsafeMarking !34 (PROC 1 VOID
!!     (VPARAM #unsafe 12 BOOLEAN)))
!! (PROCEDURE #IsExtension 94 #OMSPP.IsExtension !35 (PROC 2 BOOLEAN
!!     (PARAM #t0 12 =4)
!!     (PARAM #t1 16 =4)))
!! (PROCEDURE #TypeTest 100 #OMSPP.TypeTest !36 (PROC 4 VOID
!!     (VPARAM #x 12 =8)
!!     (PARAM #T 20 =4)
!!     (PARAM #guard 24 BOOLEAN))
!!   (LOCAL #xt -4 =4))
!! (PROCEDURE #StandFunc 123 #OMSPP.StandFunc !37 (PROC 4 VOID
!!     (VPARAM #x 12 =8)
!!     (PARAM #fct 20 INTEGER)
!!     (PARAM #restyp 24 =4))
!!   (LOCAL #y -44 =8)
!!   (LOCAL #z -88 =8)
!!   (LOCAL #n -92 INTEGER)
!!   (LOCAL #npar -96 INTEGER))
!! (PROCEDURE #isRecOrPtr 170 #OMSPP.isRecOrPtr !38 (PROC 1 BOOLEAN
!!     (CPARAM #x 12 =8)))
!! (PROCEDURE #selector 174 #OMSPP.selector !39 (PROC 2 VOID
!!     (VPARAM #x 12 =8))
!!   (LOCAL #y -44 =8)
!!   (LOCAL #obj -48 =6))
!! (PROCEDURE #DeRefProc 219 #OMSPP.DeRefProc !40 (PROC 1 VOID
!!     (VPARAM #t 12 =4)))
!! (PROCEDURE #EqualSignatures 224 #OMSPP.EqualSignatures !41 (PROC 2 BOOLEAN
!!     (PARAM #t0 12 =4)
!!     (PARAM #t1 16 =4))
!!   (LOCAL #p0 -4 =6)
!!   (LOCAL #p1 -8 =6)
!!   (LOCAL #com -9 BOOLEAN)
!!   (LOCAL #i -16 INTEGER)
!!   (LOCAL #dr -20 SET)
!!   (LOCAL #first -21 BOOLEAN))
!! (PROCEDURE #CompTypes 253 #OMSPP.CompTypes !42 (PROC 3 BOOLEAN
!!     (PARAM #t0 12 =4)
!!     (PARAM #t1 16 =4)
!!     (PARAM #varpar 20 BOOLEAN)))
!! (PROCEDURE #Parameter 265 #OMSPP.Parameter !43 (PROC 1 VOID
!!     (PARAM #par 12 =6))
!!   (LOCAL #x -44 =8)
!!   (LOCAL #varpar -45 BOOLEAN))
!! (PROCEDURE #ParamList 295 #OMSPP.ParamList !44 (PROC 1 VOID
!!     (PARAM #t 12 =4))
!!   (LOCAL #n -4 INTEGER)
!!   (LOCAL #par -8 =6))
!! (PROCEDURE #element 313 #OMSPP.element !45 (PROC 2 VOID
!!     (VPARAM #x 12 =8))
!!   (LOCAL #y -44 =8))
!! (PROCEDURE #set 322 #OMSPP.set !46 (PROC 2 VOID
!!     (VPARAM #x 12 =8))
!!   (LOCAL #y -44 =8))
!! (PROCEDURE #factor 338 #OMSPP.factor !47 (PROC 2 VOID
!!     (VPARAM #x 12 =8))
!!   (LOCAL #obj -4 =6)
!!   (LOCAL #rx -8 SET)
!!   (LOCAL #orx -12 SET)
!!   (LOCAL #pau -13 BOOLEAN))
!! (PROCEDURE #term 371 #OMSPP.term !48 (PROC 2 VOID
!!     (VPARAM #x 12 =8))
!!   (LOCAL #y -44 =8)
!!   (LOCAL #op -48 INTEGER)
!!   (LOCAL #f -52 INTEGER))
!! (PROCEDURE #SimpleExpression 392 #OMSPP.SimpleExpression !49 (PROC 2 VOID
!!     (VPARAM #x 12 =8))
!!   (LOCAL #y -44 =8)
!!   (LOCAL #op -48 INTEGER))
!! (PROCEDURE #expression0 411 #OMSPP.expression0 !50 (PROC 2 VOID
!!     (VPARAM #x 12 =8))
!!   (LOCAL #y -44 =8)
!!   (LOCAL #obj -48 =6)
!!   (LOCAL #rel -52 INTEGER)
!!   (LOCAL #xf -56 INTEGER)
!!   (LOCAL #yf -60 INTEGER))
!! (PROCEDURE #StandProc 454 #OMSPP.StandProc !51 (PROC 1 VOID
!!     (PARAM #pno 12 INTEGER))
!!   (LOCAL #nap -4 INTEGER)
!!   (LOCAL #npar -8 INTEGER)
!!   (LOCAL #x -52 =8)
!!   (LOCAL #y -96 =8)
!!   (LOCAL #z -140 =8))
!! (PROCEDURE #StatSequence 500 #OMSPP.StatSequence !52 (PROC 0 VOID)
!!   (LOCAL #obj -4 =6)
!!   (LOCAL #orgtype -8 =4)
!!   (LOCAL #x -52 =8)
!!   (LOCAL #y -96 =8)
!!   (LOCAL #z -140 =8)
!!   (LOCAL #w -184 =8)
!!   (LOCAL #L0 -188 INTEGER)
!!   (LOCAL #L1 -192 INTEGER)
!!   (LOCAL #rx -196 SET)
!!   (LOCAL #orx -200 SET)
!!   (LOCAL #pau -201 BOOLEAN)
!!   (PROCEDURE #TypeCase 506 #OMSPP.%119.TypeCase !53 (PROC 3 VOID
!!       (PARAM #obj 12 =6)
!!       (VPARAM #x 16 =8))
!!     (LOCAL #typobj -8 =6))
!!   (PROCEDURE #SkipCase 518 #OMSPP.%120.SkipCase !54 (PROC 0 VOID)))
!! (PROCEDURE #IdentList 645 #OMSPP.IdentList !55 (PROC 2 VOID
!!     (PARAM #class 12 INTEGER)
!!     (VPARAM #first 16 =6))
!!   (LOCAL #obj -4 =6))
!! (PROCEDURE #ArrayType 661 #OMSPP.ArrayType !56 (PROC 1 VOID
!!     (VPARAM #type 12 =4))
!!   (LOCAL #x -44 =8)
!!   (LOCAL #typ -48 =4)
!!   (LOCAL #len -52 INTEGER))
!! (PROCEDURE #RecordType 677 #OMSPP.RecordType !57 (PROC 1 VOID
!!     (VPARAM #type 12 =4))
!!   (LOCAL #obj -4 =6)
!!   (LOCAL #obj0 -8 =6)
!!   (LOCAL #new -12 =6)
!!   (LOCAL #bot -16 =6)
!!   (LOCAL #base -20 =6)
!!   (LOCAL #typ -24 =4)
!!   (LOCAL #tp -28 =4)
!!   (LOCAL #offset -32 INTEGER)
!!   (LOCAL #off -36 INTEGER)
!!   (LOCAL #n -40 INTEGER))
!! (PROCEDURE #FPSection 724 #OMSPP.FPSection !58 (PROC 3 VOID
!!     (VPARAM #adr 12 INTEGER)
!!     (VPARAM #nofpar 16 INTEGER)
!!     (VPARAM #inreg 20 BOOLEAN))
!!   (LOCAL #obj -4 =6)
!!   (LOCAL #first -8 =6)
!!   (LOCAL #tp -12 =4)
!!   (LOCAL #parsize -16 INTEGER)
!!   (LOCAL #dummy -20 INTEGER)
!!   (LOCAL #nbregs -24 INTEGER)
!!   (LOCAL #cl -28 INTEGER)
!!   (LOCAL #rdo -29 BOOLEAN))
!! (PROCEDURE #InsertResultRegister 748 #OMSPP.InsertResultRegister !59 (PROC 1 VOID
!!     (VPARAM #type 12 =4))
!!   (LOCAL #L -4 INTEGER)
!!   (LOCAL #dummy -8 INTEGER)
!!   (LOCAL #loc -12 =6)
!!   (LOCAL #x -56 =8)
!!   (LOCAL #tp -60 =4))
!! (PROCEDURE #ProcedureType 767 #OMSPP.ProcedureType !60 (PROC 2 VOID
!!     (PARAM #ptype 12 =4)
!!     (VPARAM #parblksize 16 INTEGER))
!!   (LOCAL #obj -4 =6)
!!   (LOCAL #size -8 INTEGER)
!!   (LOCAL #nofpar -12 INTEGER)
!!   (LOCAL #leaf -13 BOOLEAN)
!!   (LOCAL #inreg -14 BOOLEAN)
!!   (LOCAL #x -60 =8))
!! (PROCEDURE #FormalType0 792 #OMSPP.FormalType0 !61 (PROC 2 VOID
!!     (VPARAM #typ 12 =4)
!!     (PARAM #dim 16 INTEGER))
!!   (LOCAL #obj -4 =6)
!!   (LOCAL #dmy -8 INTEGER)
!!   (LOCAL #t -12 =4))
!! (PROCEDURE #CheckRecLevel 812 #OMSPP.CheckRecLevel !62 (PROC 1 VOID
!!     (PARAM #lev 12 INTEGER)))
!! (PROCEDURE #Type0 817 #OMSPP.Type0 !63 (PROC 1 VOID
!!     (VPARAM #type 12 =4))
!!   (LOCAL #dmy -4 INTEGER)
!!   (LOCAL #obj -8 =6)
!!   (LOCAL #ptbase -12 =1)
!!   (LOCAL #sr -56 =8)
!!   (LOCAL #t -60 =4))
!! (PROCEDURE #containsPointer 862 #OMSPP.containsPointer !64 (PROC 1 BOOLEAN
!!     (PARAM #type 12 =4))
!!   (LOCAL #obj -4 =6)
!!   (LOCAL #res -5 BOOLEAN))
!! (PROCEDURE #Declarations 878 #OMSPP.Declarations !65 (PROC 2 VOID
!!     (VPARAM #varsize 12 INTEGER)
!!     (VPARAM #haveinregs 16 BOOLEAN))
!!   (LOCAL #obj -4 =6)
!!   (LOCAL #first -8 =6)
!!   (LOCAL #x -52 =8)
!!   (LOCAL #tp -56 =4)
!!   (LOCAL #ptbase -60 =1)
!!   (LOCAL #expo -61 BOOLEAN)
!!   (LOCAL #unsafe -62 BOOLEAN)
!!   (LOCAL #umm -63 BOOLEAN)
!!   (LOCAL #umf -64 BOOLEAN)
!!   (LOCAL #inreg -65 BOOLEAN)
!!   (LOCAL #onetimeinit -66 BOOLEAN)
!!   (LOCAL #id -98 =3)
!!   (LOCAL #nbregs -104 INTEGER)
!!   (LOCAL #dummy -108 INTEGER))
!! (PROCEDURE #ProcedureDecl 970 #OMSPP.ProcedureDecl !66 (PROC 0 VOID)
!!   (LOCAL #proc -4 =6)
!!   (LOCAL #loc -8 =6)
!!   (LOCAL #type -12 =4)
!!   (LOCAL #procid -44 =3)
!!   (LOCAL #x -88 =8)
!!   (LOCAL #sr -132 =8)
!!   (LOCAL #locblksize -136 INTEGER)
!!   (LOCAL #parblksize -140 INTEGER)
!!   (LOCAL #L -144 INTEGER)
!!   (LOCAL #nv -148 INTEGER)
!!   (LOCAL #int -149 BOOLEAN)
!!   (LOCAL #haveinregs -150 BOOLEAN)
!!   (LOCAL #riu -156 SET)
!!   (LOCAL #savedregs -160 SET)
!!   (LOCAL #v -168 !67 (ARRAY 8 BYTE)))
!! (PROCEDURE #Import 1055 #OMSPP.Import !68 (PROC 0 VOID)
!!   (LOCAL #impid -32 =3)
!!   (LOCAL #impid1 -64 =3))
!! (PROCEDURE #Module 1072 #OMSPP.Module !69 (PROC 0 VOID)
!!   (LOCAL #key -4 INTEGER)
!!   (LOCAL #oldCol -8 INTEGER)
!!   (LOCAL #dmyv -12 INTEGER)
!!   (LOCAL #dmy -13 BOOLEAN))
!! (DEF ?70 #Texts 13 #Scanner (RECORD #Texts.Scanner 96 ?71 #Texts 11 #Reader (RECORD #Texts.Reader 32 VOID
!!       (FIELD #eot* 0 BOOLEAN)
!!       (FIELD #col* 4 INTEGER)
!!       (FIELD #ref 8 =22)
!!       (FIELD #org 12 INTEGER)
!!       (FIELD #off 16 INTEGER)
!!       (FIELD #rider 20 =15))
!!     (FIELD #eot* 0 BOOLEAN)
!!     (FIELD #col* 4 INTEGER)
!!     (FIELD #ref 8 =22)
!!     (FIELD #org 12 INTEGER)
!!     (FIELD #off 16 INTEGER)
!!     (FIELD #rider 20 =15)
!!     (FIELD #nextCh* 32 CHAR)
!!     (FIELD #line* 36 INTEGER)
!!     (FIELD #class* 40 INTEGER)
!!     (FIELD #i* 44 LONGINT)
!!     (FIELD #x* 52 REAL)
!!     (FIELD #c* 56 CHAR)
!!     (FIELD #len* 60 INTEGER)
!!     (FIELD #s* 64 ?72 #Texts 14 ANON (ARRAY 32 CHAR))))
!! (PROCEDURE #Option 1118 #OMSPP.Option !73 (PROC 2 VOID
!!     (VPARAM #S1 12 =70)))
!! (PROCEDURE #Compile* 1126 #OMSPP.Compile !74 (PROC 0 VOID)
!!   (LOCAL #beg -4 INTEGER)
!!   (LOCAL #end -8 INTEGER)
!!   (LOCAL #time -12 INTEGER)
!!   (LOCAL #T -16 ?75 #Texts 8 #Text (POINTER))
!!   (LOCAL #S1 -112 =70))
!! (TARGET =75 ?76 #Texts 9 #TextDesc (RECORD #Texts.TextDesc 24 VOID
!!     (FIELD #len* 0 INTEGER)
!!     (FIELD #changed* 4 BOOLEAN)
!!     (FIELD #notify* 8 ?77 #Texts 10 #Notifier (PROC 4 VOID
!!         (PARAM #T 12 =75)
!!         (PARAM #op 16 INTEGER)
!!         (PARAM #beg 20 INTEGER)
!!         (PARAM #end 24 INTEGER)))
!!     (FIELD #trailer 12 =22)
!!     (FIELD #pce 16 =22)
!!     (FIELD #org 20 INTEGER)))
!! (CHKSUM 0x0ba6dc24)
!! 
MODULE OMSPP 0x0ba6dc24 1165
IMPORT Display 0x6ac5a6ac
IMPORT Texts 0x04379426
IMPORT Oberon 0x7fd79012
IMPORT OMSPS 0x669fb75e
IMPORT OMSPB 0x44d6da02
IMPORT OMSPG 0x1f97ef6a
ENDHDR

PROC OMSPP.Check 0 3 0x00200001
!   PROCEDURE Check(s: INTEGER; msg: ARRAY OF CHAR);
LINE 28
!     IF sym = s THEN S.Get(sym) ELSE S.Mark(msg) END
LINE 30
LDGW OMSPP.sym
LDLW 12
JNEQ L123
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
RETURN
LABEL L123
LDLW 20
LDLW 16
GLOBAL OMSPS.Mark
CALL 2
RETURN
END

PROC OMSPP.qualident 0 3 0x00100001
!   PROCEDURE qualident(VAR obj: B.Object);
LINE 33
!   BEGIN obj := B.thisObj(); S.Get(sym);
LINE 34
GLOBAL OMSPB.thisObj
CALLW 0
LDLW 12
STOREW
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!     IF obj = NIL THEN S.Mark("undef"); obj := dummy END ;
LINE 35
LDLW 12
LOADW
JNEQZ L126
CONST 6
GLOBAL OMSPP.%1
GLOBAL OMSPS.Mark
CALL 2
LDGW OMSPP.dummy
LDLW 12
STOREW
LABEL L126
!     IF (sym = S.period) & (obj.class = B.Mod) THEN S.Get(sym);
LINE 36
LDGW OMSPP.sym
CONST 18
JNEQ L129
LDLW 12
LOADW
NCHECK 36
LOADC
CONST 8
JNEQ L129
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!       IF sym = S.ident THEN obj := B.thisimport(obj); S.Get(sym);
LINE 37
LDGW OMSPP.sym
CONST 31
JNEQ L132
LDLW 12
LOADW
GLOBAL OMSPB.thisimport
CALLW 1
LDLW 12
STOREW
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!         IF obj = NIL THEN S.Mark("undef"); obj := dummy END
LINE 38
LDLW 12
LOADW
JNEQZ L129
CONST 6
GLOBAL OMSPP.%1
GLOBAL OMSPS.Mark
CALL 2
LDGW OMSPP.dummy
LDLW 12
STOREW
RETURN
LABEL L132
!       ELSE S.Mark("identifier expected"); obj := dummy
LINE 39
CONST 20
GLOBAL OMSPP.%2
GLOBAL OMSPS.Mark
CALL 2
LDGW OMSPP.dummy
LDLW 12
STOREW
LABEL L129
RETURN
END

PROC OMSPP.CheckBool 0 3 0x00100001
!   PROCEDURE CheckBool(VAR x: G.Item);
LINE 44
!     IF x.type.form # B.Bool THEN S.Mark("not Boolean"); x.type := B.boolType END
LINE 46
LDLW 12
LDNW 12
NCHECK 46
LOADW
CONST 2
JEQ L139
CONST 12
GLOBAL OMSPP.%3
GLOBAL OMSPS.Mark
CALL 2
LDGW OMSPB.boolType
LDLW 12
STNW 12
LABEL L139
RETURN
END

PROC OMSPP.CheckInt 0 3 0x00100001
!   PROCEDURE CheckInt(VAR x: G.Item);
LINE 49
!     IF x.type.form # B.Int THEN S.Mark("not Integer"); x.type := B.intType END
LINE 51
LDLW 12
LDNW 12
NCHECK 51
LOADW
CONST 4
JEQ L142
CONST 12
GLOBAL OMSPP.%4
GLOBAL OMSPS.Mark
CALL 2
LDGW OMSPB.intType
LDLW 12
STNW 12
LABEL L142
RETURN
END

PROC OMSPP.CheckSet 0 3 0x00100001
!   PROCEDURE CheckSet(VAR x: G.Item);
LINE 54
!     IF x.type.form # B.Set THEN S.Mark("not Set"); x.type := B.setType END 
LINE 56
LDLW 12
LDNW 12
NCHECK 56
LOADW
CONST 6
JEQ L145
CONST 8
GLOBAL OMSPP.%5
GLOBAL OMSPS.Mark
CALL 2
LDGW OMSPB.setType
LDLW 12
STNW 12
LABEL L145
RETURN
END

PROC OMSPP.CheckSetVal 0 3 0x00100001
!   PROCEDURE CheckSetVal(VAR x: G.Item);
LINE 59
!     IF x.type.form # B.Int THEN S.Mark("not Int"); x.type := B.setType
LINE 61
LDLW 12
LDNW 12
NCHECK 61
LOADW
CONST 4
JEQ L148
CONST 8
GLOBAL OMSPP.%6
GLOBAL OMSPS.Mark
CALL 2
LDGW OMSPB.setType
LDLW 12
STNW 12
RETURN
LABEL L148
!     ELSIF x.mode = B.Const THEN
LINE 62
LDLW 12
LDNW 8
CONST 1
JNEQ L150
!       IF (x.a < 0) OR (x.a >= 16) THEN S.Mark("invalid set") END
LINE 63
LDLW 12
LDNW 20
JLTZ L152
LDLW 12
LDNW 20
CONST 16
JLT L150
LABEL L152
CONST 12
GLOBAL OMSPP.%7
GLOBAL OMSPS.Mark
CALL 2
LABEL L150
RETURN
END

PROC OMSPP.CheckConst 0 3 0x00100001
!   PROCEDURE CheckConst(VAR x: G.Item);
LINE 67
!     IF x.mode # B.Const THEN S.Mark("not a constant"); x.mode := B.Const END
LINE 69
LDLW 12
LDNW 8
CONST 1
JEQ L157
CONST 15
GLOBAL OMSPP.%8
GLOBAL OMSPS.Mark
CALL 2
CONST 1
LDLW 12
STNW 8
LABEL L157
RETURN
END

PROC OMSPP.CheckReadOnly 0 3 0x00100001
!   PROCEDURE CheckReadOnly(VAR x: G.Item);
LINE 72
!   BEGIN IF x.rdo THEN S.Mark("read-only") END
LINE 73
LDLW 12
CONST 40
LDIC
JEQZ L160
CONST 10
GLOBAL OMSPP.%9
GLOBAL OMSPS.Mark
CALL 2
LABEL L160
RETURN
END

PROC OMSPP.CheckExport 0 3 0x00100001
!   PROCEDURE CheckExport(VAR expo: BOOLEAN);
LINE 76
!     IF sym = S.times THEN
LINE 78
LDGW OMSPP.sym
CONST 1
JNEQ L163
!       expo := TRUE; S.Get(sym);
LINE 79
CONST 1
LDLW 12
STOREC
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!       IF level # 0 THEN S.Mark("remove asterisk") END
LINE 80
LDGW OMSPP.level
JEQZ L161
CONST 16
GLOBAL OMSPP.%10
GLOBAL OMSPS.Mark
CALL 2
RETURN
LABEL L163
!     ELSE expo := FALSE
LINE 81
CONST 0
LDLW 12
STOREC
LABEL L161
RETURN
END

PROC OMSPP.CheckUnsafeMarking 0 3 0x00100001
!   PROCEDURE CheckUnsafeMarking(VAR unsafe: BOOLEAN);
LINE 85
!     IF sym = S.emark THEN
LINE 87
LDGW OMSPP.sym
CONST 19
JNEQ L169
!       unsafe := TRUE; S.Get(sym);
LINE 88
CONST 1
LDLW 12
STOREC
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!       IF level = 0 THEN S.Mark("remove exclamation mark") END
LINE 89
LDGW OMSPP.level
JNEQZ L167
CONST 24
GLOBAL OMSPP.%11
GLOBAL OMSPS.Mark
CALL 2
RETURN
LABEL L169
!     ELSE unsafe := FALSE
LINE 90
CONST 0
LDLW 12
STOREC
LABEL L167
RETURN
END

PROC OMSPP.IsExtension 0 3 0x00300001
!   PROCEDURE IsExtension(t0, t1: B.Type): BOOLEAN;
LINE 94
!     RETURN (t0 = t1) OR (t1 # NIL) & IsExtension(t0, t1.base)
LINE 96
LDLW 12
LDLW 16
JEQ L173
LDLW 16
JEQZ L174
LDLW 16
NCHECK 96
LDNW 28
LDLW 12
GLOBAL OMSPP.IsExtension
CALLW 2
JEQZ L174
LABEL L173
CONST 1
RETURN
LABEL L174
CONST 0
RETURN
END

PROC OMSPP.TypeTest 4 6 0x00510001
!   PROCEDURE TypeTest(VAR x: G.Item; T: B.Type; guard: BOOLEAN);
LINE 100
!   BEGIN xt := x.type;
LINE 102
LDLW 12
LDNW 12
STLW -4
!     IF (T.form = xt.form ) & ((T.form = B.Pointer) OR (T.form = B.Record) & (x.mode = B.Par)) THEN
LINE 103
LDLW 20
NCHECK 103
LOADW
LDLW -4
NCHECK 103
LOADW
JNEQ L180
LDLW 20
NCHECK 103
LOADW
CONST 7
JEQ L179
LDLW 20
NCHECK 103
LOADW
CONST 13
JNEQ L180
LDLW 12
LDNW 8
CONST 3
JNEQ L180
LABEL L179
!       WHILE (xt # T) & (xt # NIL) DO xt := xt.base END ;
LINE 104
LDLW -4
LDLW 20
JEQ L183
LDLW -4
JEQZ L183
LDLW -4
NCHECK 104
LDNW 28
STLW -4
JUMP L179
LABEL L183
!       IF xt # T THEN xt := x.type;
LINE 105
LDLW -4
LDLW 20
JEQ L187
LDLW 12
LDNW 12
STLW -4
!         IF xt.form = B.Pointer THEN
LINE 106
LDLW -4
NCHECK 106
LOADW
CONST 7
JNEQ L190
!           IF IsExtension(xt.base, T.base) THEN G.TypeTest(x, T.base, FALSE, guard); x.type := T
LINE 107
LDLW 20
NCHECK 107
LDNW 28
LDLW -4
NCHECK 107
LDNW 28
GLOBAL OMSPP.IsExtension
CALLW 2
JEQZ L193
LDLC 24
ALIGNC
CONST 0
ALIGNC
LDLW 20
NCHECK 107
LDNW 28
LDLW 16
LDLW 12
GLOBAL OMSPG.TypeTest
CALL 5
LDLW 20
LDLW 12
STNW 12
JUMP L178
LABEL L193
!           ELSE S.Mark("not an extension")
LINE 108
CONST 17
GLOBAL OMSPP.%12
GLOBAL OMSPS.Mark
CALL 2
JUMP L178
LABEL L190
!         ELSIF (xt.form = B.Record) & (x.mode = B.Par) THEN
LINE 110
LDLW -4
NCHECK 110
LOADW
CONST 13
JNEQ L195
LDLW 12
LDNW 8
CONST 3
JNEQ L195
!           IF IsExtension(xt, T) THEN  G.TypeTest(x, T, TRUE, guard); x.type := T
LINE 111
LDLW 20
LDLW -4
GLOBAL OMSPP.IsExtension
CALLW 2
JEQZ L198
LDLC 24
ALIGNC
CONST 1
ALIGNC
LDLW 20
LDLW 16
LDLW 12
GLOBAL OMSPG.TypeTest
CALL 5
LDLW 20
LDLW 12
STNW 12
JUMP L178
LABEL L198
!           ELSE S.Mark("not an extension")
LINE 112
CONST 17
GLOBAL OMSPP.%12
GLOBAL OMSPS.Mark
CALL 2
JUMP L178
LABEL L195
!         ELSE S.Mark("incompatible types")
LINE 114
CONST 19
GLOBAL OMSPP.%13
GLOBAL OMSPS.Mark
CALL 2
JUMP L178
LABEL L187
!       ELSIF ~guard THEN G.TypeTest(x, NIL, FALSE, FALSE)
LINE 116
LDLC 24
JNEQZ L178
CONST 0
ALIGNC
CONST 0
ALIGNC
CONST 0
LDLW 16
LDLW 12
GLOBAL OMSPG.TypeTest
CALL 5
JUMP L178
LABEL L180
!     ELSE S.Mark("type mismatch")
LINE 118
CONST 14
GLOBAL OMSPP.%14
GLOBAL OMSPS.Mark
CALL 2
LABEL L178
!     IF ~guard THEN x.type := B.boolType END
LINE 120
LDLC 24
JNEQZ L207
LDGW OMSPB.boolType
LDLW 12
STNW 12
LABEL L207
RETURN
END

PROC OMSPP.StandFunc 96 7 OMSPP.StandFunc.%map
!   PROCEDURE StandFunc(VAR x: G.Item; fct: INTEGER; restyp: B.Type);
LINE 123
!   BEGIN Check(S.lparen, "no (");
LINE 125
CONST 5
GLOBAL OMSPP.%15
CONST 28
GLOBAL OMSPP.Check
CALL 3
!     npar := fct MOD 10; fct := fct DIV 10; expression(x); n := 1;
LINE 126
LDLW 20
CONST 10
MOD
STLW -96
LDLW 20
CONST 10
DIV
STLW 20
LDLW 16
LDLW 12
LDGW OMSPP.expression
NCHECK 126
CALL 2
CONST 1
STLW -92
!     IF (fct IN {4, 5, 7, 15, 16}) & (x.obj # NIL) THEN x.rdo := x.obj.rdo END;
LINE 127
CONST 1
LDLW 20
CONST 32
BOUND 127
LSL
CONST 98480
BITAND
JEQZ L210
LDLW 12
LDNW 16
JEQZ L210
LDLW 12
LDNW 16
NCHECK 127
CONST 5
LDIC
LDLW 12
CONST 40
STIC
LABEL L210
!     IF sym = S.comma THEN S.Get(sym); expression(y); n := 2;
LINE 128
LDGW OMSPP.sym
CONST 40
JNEQ L214
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -44
LDGW OMSPP.expression
NCHECK 128
CALL 2
CONST 2
STLW -92
LABEL L215
!       WHILE sym = S.comma DO S.Get(sym); expression(z); INC(n) END ;
LINE 129
LDGW OMSPP.sym
CONST 40
JNEQ L214
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -88
LDGW OMSPP.expression
NCHECK 129
CALL 2
INCL -92
JUMP L215
LABEL L214
!     Check(S.rparen, "no )");
LINE 131
CONST 5
GLOBAL OMSPP.%16
CONST 44
GLOBAL OMSPP.Check
CALL 3
!     IF n = npar THEN
LINE 132
LDLW -92
LDLW -96
JNEQ L220
!       IF fct = 0 THEN (*ABS*) CheckInt(x); G.Abs(x)
LINE 133
LDLW 20
JNEQZ L225
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckInt
CALL 2
LDLW 16
LDLW 12
GLOBAL OMSPG.Abs
CALL 2
JUMP L223
LABEL L225
!       ELSIF fct = 1 THEN (*ODD*) CheckInt(x); G.Odd(x)
LINE 134
LDLW 20
CONST 1
JNEQ L227
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckInt
CALL 2
LDLW 16
LDLW 12
GLOBAL OMSPG.Odd
CALL 2
JUMP L223
LABEL L227
!       ELSIF fct = 4 THEN (*ORD*)
LINE 135
LDLW 20
CONST 4
JNEQ L229
!         IF x.type.form <= B.Proc THEN G.Ord(x); IF x.type.size = 1 THEN restyp := B.byteType END
LINE 136
LDLW 12
LDNW 12
NCHECK 136
LOADW
CONST 10
JGT L232
LDLW 16
LDLW 12
GLOBAL OMSPG.Ord
CALL 2
LDLW 12
LDNW 12
NCHECK 136
LDNW 32
CONST 1
JNEQ L223
LDGW OMSPB.byteType
STLW 24
JUMP L223
LABEL L232
!         ELSIF (x.type.form = B.String) & (G.Length(x) = 2) THEN G.StrToChar(x); restyp := B.byteType
LINE 137
LDLW 12
LDNW 12
NCHECK 137
LOADW
CONST 11
JNEQ L237
LDLW 12
GLOBAL OMSPG.Length
CALLW 1
CONST 2
JNEQ L237
LDLW 16
LDLW 12
GLOBAL OMSPG.StrToChar
CALL 2
LDGW OMSPB.byteType
STLW 24
JUMP L223
LABEL L237
!         ELSE S.Mark("bad type")
LINE 138
CONST 9
GLOBAL OMSPP.%17
GLOBAL OMSPS.Mark
CALL 2
JUMP L223
LABEL L229
!       ELSIF fct = 5 THEN (*CHR*) CheckInt(x); G.Ord(x)
LINE 140
LDLW 20
CONST 5
JNEQ L240
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckInt
CALL 2
LDLW 16
LDLW 12
GLOBAL OMSPG.Ord
CALL 2
JUMP L223
LABEL L240
!       ELSIF fct = 6 THEN (*LEN*)
LINE 141
LDLW 20
CONST 6
JNEQ L242
!           IF x.type.form IN {B.Array, B.String} THEN G.Len(x) ELSE S.Mark("not an array") END
LINE 142
CONST 1
LDLW 12
LDNW 12
NCHECK 142
LOADW
CONST 32
BOUND 142
LSL
CONST 6144
BITAND
JEQZ L245
LDLW 16
LDLW 12
GLOBAL OMSPG.Len
CALL 2
JUMP L223
LABEL L245
CONST 13
GLOBAL OMSPP.%18
GLOBAL OMSPS.Mark
CALL 2
JUMP L223
LABEL L242
!       ELSIF fct = 7 THEN (*TOSET*) CheckInt(x); IF x.type.size = 1 THEN restyp := B.byteSetType END
LINE 143
LDLW 20
CONST 7
JNEQ L247
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckInt
CALL 2
LDLW 12
LDNW 12
NCHECK 143
LDNW 32
CONST 1
JNEQ L223
LDGW OMSPB.byteSetType
STLW 24
JUMP L223
LABEL L247
!       ELSIF fct = 14 THEN (*BIT*)
LINE 144
LDLW 20
CONST 14
JNEQ L252
!         IF (x.type.form IN {B.Int, B.Set}) & (y.type.form IN {B.Int, B.Set}) THEN G.Bit(x, y) ELSE S.Mark("bad type") END
LINE 145
CONST 1
LDLW 12
LDNW 12
NCHECK 145
LOADW
CONST 32
BOUND 145
LSL
CONST 80
BITAND
JEQZ L255
CONST 1
LDLW -32
NCHECK 145
LOADW
CONST 32
BOUND 145
LSL
CONST 80
BITAND
JEQZ L255
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
GLOBAL OMSPG.Bit
CALL 4
JUMP L223
LABEL L255
CONST 9
GLOBAL OMSPP.%17
GLOBAL OMSPS.Mark
CALL 2
JUMP L223
LABEL L252
!       ELSIF fct = 15 THEN (*PTR: make a type checked pointer of type x pointing on y*)
LINE 146
LDLW 20
CONST 15
JNEQ L258
!         IF x.mode # B.Typ THEN S.Mark("first op is not a type")
LINE 147
LDLW 12
LDNW 8
CONST 5
JEQ L262
CONST 23
GLOBAL OMSPP.%19
GLOBAL OMSPS.Mark
CALL 2
JUMP L223
LABEL L262
!         ELSIF x.type.base # y.type THEN S.Mark("incompatible types")
LINE 148
LDLW 12
LDNW 12
NCHECK 148
LDNW 28
LDLW -32
JEQ L264
CONST 19
GLOBAL OMSPP.%13
GLOBAL OMSPS.Mark
CALL 2
JUMP L223
LABEL L264
!         ELSE restyp := x.type; G.Adr(y); x :=  y
LINE 149
LDLW 12
LDNW 12
STLW 24
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.Adr
CALL 2
LDLW 16
GLOBAL OMSPG.Item
JEQ L260
ERROR E_ASSIGN 149
LABEL L260
LDLW 12
LOCAL -44
CONST 44
FIXCOPY
JUMP L223
LABEL L258
!       ELSIF fct = 16 THEN (*VAL*)
LINE 151
LDLW 20
CONST 16
JNEQ L266
!         IF (x.mode= B.Typ) & (x.type.size <= y.type.size) THEN restyp := x.type; G.Val(y, restyp); x := y
LINE 152
LDLW 12
LDNW 8
CONST 5
JNEQ L269
LDLW 12
LDNW 12
NCHECK 152
LDNW 32
LDLW -32
NCHECK 152
LDNW 32
JGT L269
LDLW 12
LDNW 12
STLW 24
LDLW 24
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.Val
CALL 3
LDLW 16
GLOBAL OMSPG.Item
JEQ L270
ERROR E_ASSIGN 152
LABEL L270
LDLW 12
LOCAL -44
CONST 44
FIXCOPY
JUMP L223
LABEL L269
!         ELSE S.Mark("casting not allowed")
LINE 153
CONST 20
GLOBAL OMSPP.%20
GLOBAL OMSPS.Mark
CALL 2
JUMP L223
LABEL L266
!       ELSIF fct = 17 THEN (*ADR*) G.Adr(x)
LINE 155
LDLW 20
CONST 17
JNEQ L273
LDLW 16
LDLW 12
GLOBAL OMSPG.Adr
CALL 2
JUMP L223
LABEL L273
!       ELSIF fct = 18 THEN (*SIZE*)
LINE 156
LDLW 20
CONST 18
JNEQ L275
!         IF x.mode = B.Typ THEN G.MakeConstItem(x, B.intType, x.type.size)
LINE 157
LDLW 12
LDNW 8
CONST 5
JNEQ L278
LDLW 12
LDNW 12
NCHECK 157
LDNW 32
LDGW OMSPB.intType
LDLW 16
LDLW 12
GLOBAL OMSPG.MakeConstItem
CALL 4
JUMP L223
LABEL L278
!         ELSE S.Mark("must be a type")
LINE 158
CONST 15
GLOBAL OMSPP.%21
GLOBAL OMSPS.Mark
CALL 2
JUMP L223
LABEL L275
!       ELSIF fct = 19 THEN (*COND*) CheckConst(x); CheckInt(x); G.Condition(x)
LINE 160
LDLW 20
CONST 19
JNEQ L280
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckConst
CALL 2
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckInt
CALL 2
LDLW 16
LDLW 12
GLOBAL OMSPG.Condition
CALL 2
JUMP L223
LABEL L280
!       ELSIF fct = 22 THEN (*Int Compare*)
LINE 161
LDLW 20
CONST 22
JNEQ L282
!         CheckInt(x); CheckInt(y); CheckConst(z); CheckInt(z); G.IntCompare(x, y, z)
LINE 162
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -88
GLOBAL OMSPP.CheckConst
CALL 2
GLOBAL OMSPG.Item
LOCAL -88
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -88
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
GLOBAL OMSPG.IntCompare
CALL 6
JUMP L223
LABEL L282
CONST 0
CONST 163
GLOBAL EASSERT
CALL 2
LABEL L223
!       x.type := restyp
LINE 165
LDLW 24
LDLW 12
STNW 12
RETURN
LABEL L220
!     ELSE S.Mark("wrong nof params")
LINE 166
CONST 17
GLOBAL OMSPP.%22
GLOBAL OMSPS.Mark
CALL 2
RETURN
END

PROC OMSPP.isRecOrPtr 0 2 0x00100001
!   PROCEDURE isRecOrPtr(x: G.Item): BOOLEAN;
LINE 170
!     RETURN (x.type.form = B.Record) OR (x.type.form = B.Pointer) & (x.type.base.form = B.Record)
LINE 171
LDLW 12
LDNW 12
NCHECK 171
LOADW
CONST 13
JEQ L283
LDLW 12
LDNW 12
NCHECK 171
LOADW
CONST 7
JNEQ L284
LDLW 12
LDNW 12
NCHECK 171
LDNW 28
NCHECK 171
LOADW
CONST 13
JNEQ L284
LABEL L283
CONST 1
RETURN
LABEL L284
CONST 0
RETURN
END

PROC OMSPP.selector 48 5 0x00100621
!   PROCEDURE selector(VAR x: G.Item);
LINE 174
!     IF x.obj.class = B.SFunc THEN StandFunc(x, x.obj.val, x.obj.type) END;
LINE 177
LDLW 12
LDNW 16
NCHECK 177
LOADC
CONST 7
JNEQ L290
LDLW 12
LDNW 16
NCHECK 177
LDNW 20
LDLW 12
LDNW 16
NCHECK 177
LDNW 56
LDLW 16
LDLW 12
GLOBAL OMSPP.StandFunc
CALL 4
LABEL L290
!     WHILE (sym = S.lbrak) OR (sym = S.period) OR (sym = S.arrow)
LINE 178
LDGW OMSPP.sym
CONST 29
JEQ L292
LDGW OMSPP.sym
CONST 18
JEQ L292
LDGW OMSPP.sym
CONST 17
JEQ L292
LDGW OMSPP.sym
CONST 28
JNEQ L293
LDLW 12
GLOBAL OMSPP.isRecOrPtr
CALLW 1
JEQZ L293
LABEL L292
!       IF sym = S.lbrak THEN
LINE 180
LDGW OMSPP.sym
CONST 29
JNEQ L296
LABEL L297
!         REPEAT S.Get(sym); expression(y); CheckInt(y); 
LINE 181
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -44
LDGW OMSPP.expression
NCHECK 181
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckInt
CALL 2
!           IF x.type.form = B.Array THEN G.Index(x, y); x.type := x.type.base
LINE 182
LDLW 12
LDNW 12
NCHECK 182
LOADW
CONST 12
JNEQ L301
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
GLOBAL OMSPG.Index
CALL 4
LDLW 12
LDNW 12
NCHECK 182
LDNW 28
LDLW 12
STNW 12
JUMP L299
LABEL L301
!           ELSIF x.type.form = B.String THEN G.Index(x, y); x.type := B.charType
LINE 183
LDLW 12
LDNW 12
NCHECK 183
LOADW
CONST 11
JNEQ L303
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
GLOBAL OMSPG.Index
CALL 4
LDGW OMSPB.charType
LDLW 12
STNW 12
JUMP L299
LABEL L303
!           ELSE S.Mark("not an array")
LINE 184
CONST 13
GLOBAL OMSPP.%18
GLOBAL OMSPS.Mark
CALL 2
LABEL L299
!         UNTIL sym # S.comma;
LINE 186
LDGW OMSPP.sym
CONST 40
JEQ L297
!         Check(S.rbrak, "no ]")
LINE 187
CONST 5
GLOBAL OMSPP.%23
CONST 45
GLOBAL OMSPP.Check
CALL 3
JUMP L290
LABEL L296
!       ELSIF sym = S.period THEN S.Get(sym);
LINE 188
LDGW OMSPP.sym
CONST 18
JNEQ L305
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!         IF sym = S.ident THEN
LINE 189
LDGW OMSPP.sym
CONST 31
JNEQ L308
!           IF x.type.form = B.Pointer THEN G.DeRef(x); x.type := x.type.base; x.rdo := FALSE END ;
LINE 190
LDLW 12
LDNW 12
NCHECK 190
LOADW
CONST 7
JNEQ L311
LDLW 16
LDLW 12
GLOBAL OMSPG.DeRef
CALL 2
LDLW 12
LDNW 12
NCHECK 190
LDNW 28
LDLW 12
STNW 12
CONST 0
LDLW 12
CONST 40
STIC
LABEL L311
!           IF x.type.form = B.Record THEN
LINE 191
LDLW 12
LDNW 12
NCHECK 191
LOADW
CONST 13
JNEQ L314
!             obj := B.thisfield(x.type); S.Get(sym);
LINE 192
LDLW 12
LDNW 12
GLOBAL OMSPB.thisfield
CALLW 1
STLW -48
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!             IF obj # NIL THEN G.Field(x, obj); x.type := obj.type; x.rdo := obj.rdo
LINE 193
LDLW -48
JEQZ L317
LDLW -48
LDLW 16
LDLW 12
GLOBAL OMSPG.Field
CALL 3
LDLW -48
NCHECK 193
LDNW 20
LDLW 12
STNW 12
LDLW -48
NCHECK 193
CONST 5
LDIC
LDLW 12
CONST 40
STIC
JUMP L290
LABEL L317
!             ELSE S.Mark("undef")
LINE 194
CONST 6
GLOBAL OMSPP.%1
GLOBAL OMSPS.Mark
CALL 2
JUMP L290
LABEL L314
!           ELSE S.Mark("not a record"); S.Get(sym)
LINE 196
CONST 13
GLOBAL OMSPP.%24
GLOBAL OMSPS.Mark
CALL 2
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
JUMP L290
LABEL L308
!         ELSE S.Mark("ident?")
LINE 198
CONST 7
GLOBAL OMSPP.%25
GLOBAL OMSPS.Mark
CALL 2
JUMP L290
LABEL L305
!       ELSIF sym = S.arrow THEN
LINE 200
LDGW OMSPP.sym
CONST 17
JNEQ L319
!         S.Get(sym);
LINE 201
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!         IF x.type.form = B.Pointer THEN G.DeRef(x); x.type := x.type.base; x.rdo := FALSE
LINE 202
LDLW 12
LDNW 12
NCHECK 202
LOADW
CONST 7
JNEQ L322
LDLW 16
LDLW 12
GLOBAL OMSPG.DeRef
CALL 2
LDLW 12
LDNW 12
NCHECK 202
LDNW 28
LDLW 12
STNW 12
CONST 0
LDLW 12
CONST 40
STIC
JUMP L290
LABEL L322
!         ELSE S.Mark("not a pointer")
LINE 203
CONST 14
GLOBAL OMSPP.%26
GLOBAL OMSPS.Mark
CALL 2
JUMP L290
LABEL L319
!       ELSIF (sym = S.lparen) & isRecOrPtr(x) THEN (*type guard*)
LINE 205
LDGW OMSPP.sym
CONST 28
JNEQ L290
LDLW 12
GLOBAL OMSPP.isRecOrPtr
CALLW 1
JEQZ L290
!         S.Get(sym);
LINE 206
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!         IF sym = S.ident THEN
LINE 207
LDGW OMSPP.sym
CONST 31
JNEQ L327
!           qualident(obj);
LINE 208
LOCAL -48
GLOBAL OMSPP.qualident
CALL 1
!           IF obj.class = B.Typ THEN TypeTest(x, obj.type, TRUE)
LINE 209
LDLW -48
NCHECK 209
LOADC
CONST 5
JNEQ L330
CONST 1
ALIGNC
LDLW -48
NCHECK 209
LDNW 20
LDLW 16
LDLW 12
GLOBAL OMSPP.TypeTest
CALL 4
JUMP L325
LABEL L330
!           ELSE S.Mark("guard type expected")
LINE 210
CONST 20
GLOBAL OMSPP.%27
GLOBAL OMSPS.Mark
CALL 2
JUMP L325
LABEL L327
!         ELSE S.Mark("not an identifier")
LINE 212
CONST 18
GLOBAL OMSPP.%28
GLOBAL OMSPS.Mark
CALL 2
LABEL L325
!         Check(S.rparen, " ) missing")
LINE 214
CONST 11
GLOBAL OMSPP.%29
CONST 44
GLOBAL OMSPP.Check
CALL 3
JUMP L290
LABEL L293
RETURN
END

PROC OMSPP.DeRefProc 0 2 0x00100001
!   PROCEDURE DeRefProc(VAR t: B.Type);
LINE 219
!     IF (t.form = B.Pointer) & (t.base # NIL) & (t.base.form = B.Proc) THEN t := t.base END;
LINE 221
LDLW 12
LOADW
NCHECK 221
LOADW
CONST 7
JNEQ L338
LDLW 12
LOADW
NCHECK 221
LDNW 28
JEQZ L338
LDLW 12
LOADW
NCHECK 221
LDNW 28
NCHECK 221
LOADW
CONST 10
JNEQ L338
LDLW 12
LOADW
NCHECK 221
LDNW 28
LDLW 12
STOREW
LABEL L338
RETURN
END

PROC OMSPP.EqualSignatures 24 5 0x00318001
!   PROCEDURE EqualSignatures(t0, t1: B.Type): BOOLEAN;
LINE 224
!   BEGIN DeRefProc(t0); DeRefProc(t1);
LINE 227
LOCAL 12
GLOBAL OMSPP.DeRefProc
CALL 1
LOCAL 16
GLOBAL OMSPP.DeRefProc
CALL 1
!     com := TRUE; dr := t1.ur - t0.ur;
LINE 228
CONST 1
STLC -9
LDLW 16
NCHECK 228
LDNW 40
LDLW 12
NCHECK 228
LDNW 40
BITNOT
BITAND
STLW -20
!     IF dr # {} THEN S.Mark("regs destroyed: "); first := TRUE;
LINE 229
LDLW -20
JEQZ L343
CONST 17
GLOBAL OMSPP.%30
GLOBAL OMSPS.Mark
CALL 2
CONST 1
STLC -21
!       FOR i := 0 TO 15 DO
LINE 230
CONST 0
STLW -16
LABEL L344
LDLW -16
CONST 15
JGT L345
!         IF i IN dr THEN IF ~first THEN Texts.WriteString(W, ", ") END;
LINE 231
LDLW -20
CONST 1
LDLW -16
CONST 32
BOUND 231
LSL
BITAND
JEQZ L348
LDLC -21
JNEQZ L351
CONST 3
GLOBAL OMSPP.%31
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteString
CALL 4
LABEL L351
!           Texts.Write(W, "R"); Texts.WriteInt(W, i, 1); first := FALSE
LINE 232
CONST 82
ALIGNC
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.Write
CALL 3
CONST 1
LDLW -16
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteInt
CALL 4
CONST 0
STLC -21
LABEL L348
!       FOR i := 0 TO 15 DO
LINE 230
INCL -16
JUMP L344
LABEL L345
!       END; Texts.WriteLn(W);
LINE 234
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteLn
CALL 2
!       com := FALSE END;
LINE 235
CONST 0
STLC -9
LABEL L343
!     IF (t0.base = t1.base) & (t0.nofpar = t1.nofpar) THEN
LINE 236
LDLW 12
NCHECK 236
LDNW 28
LDLW 16
NCHECK 236
LDNW 28
JNEQ L354
LDLW 12
NCHECK 236
LDNW 12
LDLW 16
NCHECK 236
LDNW 12
JNEQ L354
!       p0 := t0.dsc; p1 := t1.dsc;
LINE 237
LDLW 12
NCHECK 237
LDNW 20
STLW -4
LDLW 16
NCHECK 237
LDNW 20
STLW -8
LABEL L355
!       WHILE p0 # NIL DO
LINE 238
LDLW -4
JEQZ L352
!         IF (p0.class = p1.class) &  (p0.rdo = p1.rdo) &
LINE 239
LDLW -4
NCHECK 239
LOADC
LDLW -8
NCHECK 239
LOADC
JNEQ L360
LDLW -4
NCHECK 239
CONST 5
LDIC
LDLW -8
NCHECK 239
CONST 5
LDIC
JNEQ L360
LDLW -4
NCHECK 240
LDNW 20
LDLW -8
NCHECK 240
LDNW 20
JNEQ L365
LDLW -4
NCHECK 240
CONST 2
LDIC
LDLW -8
NCHECK 240
CONST 2
LDIC
JEQ L359
LABEL L365
LDLW -4
NCHECK 241
LDNW 20
NCHECK 241
LOADW
CONST 12
JNEQ L362
LDLW -8
NCHECK 241
LDNW 20
NCHECK 241
LOADW
CONST 12
JNEQ L362
LDLW -4
NCHECK 241
LDNW 20
NCHECK 241
LDNW 16
LDLW -8
NCHECK 241
LDNW 20
NCHECK 241
LDNW 16
JNEQ L362
LDLW -4
NCHECK 241
LDNW 20
NCHECK 241
LDNW 28
LDLW -8
NCHECK 241
LDNW 20
NCHECK 241
LDNW 28
JEQ L359
LABEL L362
LDLW -4
NCHECK 242
LDNW 20
NCHECK 242
LOADW
CONST 10
JNEQ L360
LDLW -8
NCHECK 242
LDNW 20
NCHECK 242
LOADW
CONST 10
JNEQ L360
LDLW -8
NCHECK 242
LDNW 20
LDLW -4
NCHECK 242
LDNW 20
GLOBAL OMSPP.EqualSignatures
CALLW 2
JEQZ L360
LABEL L359
!         THEN p0 := p0.next; p1 := p1.next
LINE 243
LDLW -4
NCHECK 243
LDNW 12
STLW -4
LDLW -8
NCHECK 243
LDNW 12
STLW -8
JUMP L355
LABEL L360
!         ELSE p0 := NIL; com := FALSE
LINE 244
CONST 0
STLW -4
CONST 0
STLC -9
JUMP L355
LABEL L354
!     ELSE com := FALSE
LINE 247
CONST 0
STLC -9
LABEL L352
!     IF (t0.base.form # B.NoTyp) & (t0.leaf # t1.leaf) THEN S.Mark("incompatible leafness"); com := FALSE END
LINE 249
LDLW 12
NCHECK 249
LDNW 28
NCHECK 249
LOADW
CONST 9
JEQ L374
LDLW 12
NCHECK 249
CONST 36
LDIC
LDLW 16
NCHECK 249
CONST 36
LDIC
JEQ L374
CONST 22
GLOBAL OMSPP.%32
GLOBAL OMSPS.Mark
CALL 2
CONST 0
STLC -9
LABEL L374
!     RETURN com
LINE 250
LDLC -9
RETURN
END

PROC OMSPP.CompTypes 0 3 0x00300001
!   PROCEDURE CompTypes(t0, t1: B.Type; varpar: BOOLEAN): BOOLEAN;
LINE 253
!     DeRefProc(t0); DeRefProc(t1);
LINE 255
LOCAL 12
GLOBAL OMSPP.DeRefProc
CALL 1
LOCAL 16
GLOBAL OMSPP.DeRefProc
CALL 1
!     RETURN (t0 = t1)    (*openarray assignment disallowed in OMSPG*)
LINE 256
LDLW 12
LDLW 16
JEQ L376
LDLW 12
NCHECK 257
LOADW
CONST 12
JNEQ L388
LDLW 16
NCHECK 257
LOADW
CONST 12
JNEQ L388
LDLW 12
NCHECK 257
LDNW 28
LDLW 16
NCHECK 257
LDNW 28
JNEQ L388
LDLW 12
NCHECK 257
LDNW 16
LDLW 16
NCHECK 257
LDNW 16
JEQ L376
LABEL L388
LDLW 12
NCHECK 258
LOADW
CONST 13
JNEQ L379
LDLW 16
NCHECK 258
LOADW
CONST 13
JNEQ L379
LDLW 16
LDLW 12
GLOBAL OMSPP.IsExtension
CALLW 2
JNEQZ L376
LABEL L379
LDLC 20
JNEQZ L377
LDLW 12
NCHECK 260
LOADW
CONST 7
JNEQ L383
LDLW 16
NCHECK 260
LOADW
CONST 7
JNEQ L383
LDLW 16
NCHECK 260
LDNW 28
LDLW 12
NCHECK 260
LDNW 28
GLOBAL OMSPP.IsExtension
CALLW 2
JNEQZ L376
LABEL L383
LDLW 12
NCHECK 261
LOADW
CONST 10
JNEQ L381
LDLW 16
NCHECK 261
LOADW
CONST 10
JNEQ L381
LDLW 16
LDLW 12
GLOBAL OMSPP.EqualSignatures
CALLW 2
JNEQZ L376
LABEL L381
CONST 1
LDLW 12
NCHECK 262
LOADW
CONST 32
BOUND 262
LSL
CONST 1152
BITAND
JEQZ L377
LDLW 16
NCHECK 262
LOADW
CONST 8
JNEQ L377
LABEL L376
CONST 1
RETURN
LABEL L377
CONST 0
RETURN
END

PROC OMSPP.Parameter 48 4 0x00100601
!   PROCEDURE Parameter(par: B.Object);
LINE 265
!   BEGIN expression(x);
LINE 267
GLOBAL OMSPG.Item
LOCAL -44
LDGW OMSPP.expression
NCHECK 267
CALL 2
!     IF x.obj # NIL THEN x.rdo := x.obj.rdo END; (*allow updating of VAR parameters*)
LINE 268
LDLW -28
JEQZ L397
LDLW -28
NCHECK 268
CONST 5
LDIC
STLC -4
LABEL L397
!     IF par # NIL THEN
LINE 269
LDLW 12
JEQZ L400
!       varpar := par.class = B.Par;
LINE 270
LDLW 12
NCHECK 270
LOADC
CONST 3
EQ
STLC -45
!       IF CompTypes(par.type, x.type, varpar) THEN
LINE 271
LDLC -45
ALIGNC
LDLW -32
LDLW 12
NCHECK 271
LDNW 20
GLOBAL OMSPP.CompTypes
CALLW 3
JEQZ L403
!         IF ~varpar THEN G.ValueParam(x, par)
LINE 272
LDLC -45
JNEQZ L409
LDLW 12
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.ValueParam
CALL 3
RETURN
LABEL L409
!           IF ~par.rdo THEN CheckReadOnly(x) END ;
LINE 274
LDLW 12
NCHECK 274
CONST 5
LDIC
JNEQZ L407
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckReadOnly
CALL 2
LABEL L407
!           G.VarParam(x, par)
LINE 275
LDLW 12
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.VarParam
CALL 3
RETURN
LABEL L403
!       ELSIF (x.type.form = B.Array) & (par.type.form = B.Array) &
LINE 277
LDLW -32
NCHECK 277
LOADW
CONST 12
JNEQ L411
LDLW 12
NCHECK 277
LDNW 20
NCHECK 277
LOADW
CONST 12
JNEQ L411
LDLW -32
NCHECK 278
LDNW 28
LDLW 12
NCHECK 278
LDNW 20
NCHECK 278
LDNW 28
JNEQ L411
LDLW 12
NCHECK 278
LDNW 20
NCHECK 278
LDNW 16
JGEQZ L411
!         IF ~par.rdo THEN CheckReadOnly(x) END ;
LINE 279
LDLW 12
NCHECK 279
CONST 5
LDIC
JNEQZ L414
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckReadOnly
CALL 2
LABEL L414
!         G.OpenArrayParam(x, par)
LINE 280
LDLW 12
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.OpenArrayParam
CALL 3
RETURN
LABEL L411
!       ELSIF (x.type.form = B.String) & varpar & par.rdo & (par.type.form = B.Array) & 
LINE 281
LDLW -32
NCHECK 281
LOADW
CONST 11
JNEQ L419
LDLC -45
JEQZ L419
LDLW 12
NCHECK 281
CONST 5
LDIC
JEQZ L419
LDLW 12
NCHECK 281
LDNW 20
NCHECK 281
LOADW
CONST 12
JNEQ L419
LDLW 12
NCHECK 282
LDNW 20
NCHECK 282
LDNW 28
NCHECK 282
LOADW
CONST 3
JNEQ L419
LDLW 12
NCHECK 282
LDNW 20
NCHECK 282
LDNW 16
JGEQZ L419
!           (par.type.base.form = B.Char) & (par.type.len < 0) THEN G.StringParam(x, par)
LINE 282
LDLW 12
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.StringParam
CALL 3
RETURN
LABEL L419
!       ELSIF ~varpar & (par.type.form = B.Int) & (x.type.form = B.Int) THEN G.ValueParam(x, par)  (*BYTE*)
LINE 283
LDLC -45
JNEQZ L426
LDLW 12
NCHECK 283
LDNW 20
NCHECK 283
LOADW
CONST 4
JNEQ L426
LDLW -32
NCHECK 283
LOADW
CONST 4
JNEQ L426
LDLW 12
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.ValueParam
CALL 3
RETURN
LABEL L426
!       ELSIF ~varpar & (par.type.form = B.Set) & (x.type.form = B.Set) THEN G.ValueParam(x, par)  (*byte SET*)
LINE 284
LDLC -45
JNEQZ L430
LDLW 12
NCHECK 284
LDNW 20
NCHECK 284
LOADW
CONST 6
JNEQ L430
LDLW -32
NCHECK 284
LOADW
CONST 6
JNEQ L430
LDLW 12
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.ValueParam
CALL 3
RETURN
LABEL L430
!       ELSIF (x.type.form = B.String) & (G.Length(x) = 2) & (par.class = B.Var) & (par.type.form = B.Char) THEN
LINE 285
LDLW -32
NCHECK 285
LOADW
CONST 11
JNEQ L434
LOCAL -44
GLOBAL OMSPG.Length
CALLW 1
CONST 2
JNEQ L434
LDLW 12
NCHECK 285
LOADC
CONST 2
JNEQ L434
LDLW 12
NCHECK 285
LDNW 20
NCHECK 285
LOADW
CONST 3
JNEQ L434
!         G.StrToChar(x); G.ValueParam(x, par)
LINE 286
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.StrToChar
CALL 2
LDLW 12
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.ValueParam
CALL 3
RETURN
LABEL L434
!       ELSIF (par.type.form = B.Array) & (par.type.base = B.byteType) & 
LINE 287
LDLW 12
NCHECK 287
LDNW 20
NCHECK 287
LOADW
CONST 12
JNEQ L439
LDLW 12
NCHECK 287
LDNW 20
NCHECK 287
LDNW 28
LDGW OMSPB.byteType
JNEQ L439
LDLW 12
NCHECK 288
LDNW 20
NCHECK 288
LDNW 16
JLTZ L439
LDLW 12
NCHECK 288
LDNW 20
NCHECK 288
LDNW 32
LDLW -32
NCHECK 288
LDNW 32
JNEQ L439
!         G.VarParam(x, par)
LINE 289
LDLW 12
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.VarParam
CALL 3
RETURN
LABEL L439
!       ELSE S.Mark("incompatible parameters")
LINE 290
CONST 24
GLOBAL OMSPP.%33
GLOBAL OMSPS.Mark
CALL 2
LABEL L400
RETURN
END

PROC OMSPP.ParamList 8 4 0x00108001
!   PROCEDURE ParamList(t: B.Type);
LINE 295
!   BEGIN par := t.dsc; n := 0;
LINE 297
LDLW 12
NCHECK 297
LDNW 20
STLW -8
CONST 0
STLW -4
!     IF sym # S.rparen THEN
LINE 298
LDGW OMSPP.sym
CONST 44
JEQ L445
!       Parameter(par); n := 1;
LINE 299
LDLW -8
GLOBAL OMSPP.Parameter
CALL 1
CONST 1
STLW -4
LABEL L446
!       WHILE sym <= S.comma DO
LINE 300
LDGW OMSPP.sym
CONST 40
JGT L448
!         Check(S.comma, "comma?");
LINE 301
CONST 7
GLOBAL OMSPP.%34
CONST 40
GLOBAL OMSPP.Check
CALL 3
!         IF par # NIL THEN par := par.next END ;
LINE 302
LDLW -8
JEQZ L451
LDLW -8
NCHECK 302
LDNW 12
STLW -8
LABEL L451
!         INC(n); Parameter(par)
LINE 303
INCL -4
LDLW -8
GLOBAL OMSPP.Parameter
CALL 1
JUMP L446
LABEL L448
!       Check(S.rparen, ") missing")
LINE 305
CONST 10
GLOBAL OMSPP.%35
CONST 44
GLOBAL OMSPP.Check
CALL 3
JUMP L443
LABEL L445
!     ELSE S.Get(sym);
LINE 306
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LABEL L443
!     IF n < t.nofpar THEN S.Mark("too few params")
LINE 308
LDLW -4
LDLW 12
NCHECK 308
LDNW 12
JGEQ L454
CONST 15
GLOBAL OMSPP.%36
GLOBAL OMSPS.Mark
CALL 2
RETURN
LABEL L454
!     ELSIF n > t.nofpar THEN S.Mark("too many params")
LINE 309
LDLW -4
LDLW 12
NCHECK 309
LDNW 12
JLEQ L456
CONST 16
GLOBAL OMSPP.%37
GLOBAL OMSPS.Mark
CALL 2
LABEL L456
RETURN
END

PROC OMSPP.element 44 5 0x00100601
!   PROCEDURE element(VAR x: G.Item);
LINE 313
!   BEGIN expression(x); CheckSetVal(x);
LINE 315
LDLW 16
LDLW 12
LDGW OMSPP.expression
NCHECK 315
CALL 2
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckSetVal
CALL 2
!     IF sym = S.upto THEN S.Get(sym); expression(y); CheckSetVal(y); G.Set(x, y)
LINE 316
LDGW OMSPP.sym
CONST 43
JNEQ L459
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -44
LDGW OMSPP.expression
NCHECK 316
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckSetVal
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
GLOBAL OMSPG.Set
CALL 4
JUMP L457
LABEL L459
!     ELSE G.Singleton(x)
LINE 317
LDLW 16
LDLW 12
GLOBAL OMSPG.Singleton
CALL 2
LABEL L457
!     x.type := B.setType
LINE 319
LDGW OMSPB.setType
LDLW 12
STNW 12
RETURN
END

PROC OMSPP.set 44 6 0x00100601
!   PROCEDURE set(VAR x: G.Item);
LINE 322
!     IF sym >= S.if THEN
LINE 325
LDGW OMSPP.sym
CONST 32
JLT L471
!       IF sym # S.rbrace THEN S.Mark(" } missing") END ;
LINE 326
LDGW OMSPP.sym
CONST 46
JEQ L474
CONST 11
GLOBAL OMSPP.%38
GLOBAL OMSPS.Mark
CALL 2
LABEL L474
!       G.MakeConstItem(x, B.setType, 0) (*empty set*)
LINE 327
CONST 0
LDGW OMSPB.setType
LDLW 16
LDLW 12
GLOBAL OMSPG.MakeConstItem
CALL 4
RETURN
LABEL L471
!     ELSE element(x);
LINE 328
LDLW 16
LDLW 12
GLOBAL OMSPP.element
CALL 2
LABEL L461
!       WHILE (sym < S.rparen) OR (sym > S.rbrace) DO
LINE 329
LDGW OMSPP.sym
CONST 44
JLT L462
LDGW OMSPP.sym
CONST 46
JLEQ L463
LABEL L462
!         IF sym = S.comma THEN S.Get(sym)
LINE 330
LDGW OMSPP.sym
CONST 40
JNEQ L466
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
JUMP L468
LABEL L466
!         ELSIF sym # S.rbrace THEN S.Mark("missing comma")
LINE 331
LDGW OMSPP.sym
CONST 46
JEQ L468
CONST 14
GLOBAL OMSPP.%39
GLOBAL OMSPS.Mark
CALL 2
LABEL L468
!         element(y); G.SetOp(S.plus, x, y)
LINE 333
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.element
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
CONST 6
GLOBAL OMSPG.SetOp
CALL 5
JUMP L461
LABEL L463
RETURN
END

PROC OMSPP.factor 16 6 0x00110001
!   PROCEDURE factor(VAR x: G.Item);
LINE 338
!     IF (sym < S.char) OR (sym > S.ident) THEN S.Mark("expression expected");
LINE 341
LDGW OMSPP.sym
CONST 20
JLT L476
LDGW OMSPP.sym
CONST 31
JLEQ L477
LABEL L476
CONST 20
GLOBAL OMSPP.%40
GLOBAL OMSPS.Mark
CALL 2
LABEL L478
!       REPEAT S.Get(sym) UNTIL (sym >= S.char) & (sym <= S.for) OR (sym >= S.then)
LINE 342
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDGW OMSPP.sym
CONST 20
JLT L480
LDGW OMSPP.sym
CONST 37
JLEQ L477
LABEL L480
LDGW OMSPP.sym
CONST 47
JLT L478
LABEL L477
!     IF sym = S.ident THEN
LINE 344
LDGW OMSPP.sym
CONST 31
JNEQ L485
!       qualident(obj); G.MakeItem(x, obj, level); selector(x); x.rdo := TRUE;
LINE 345
LOCAL -4
GLOBAL OMSPP.qualident
CALL 1
LDGW OMSPP.level
LDLW -4
LDLW 16
LDLW 12
GLOBAL OMSPG.MakeItem
CALL 4
LDLW 16
LDLW 12
GLOBAL OMSPP.selector
CALL 2
CONST 1
LDLW 12
CONST 40
STIC
!       IF (x.type.form = B.Pointer) & (x.type.base.form = B.Proc) THEN
LINE 346
LDLW 12
LDNW 12
NCHECK 346
LOADW
CONST 7
JNEQ L488
LDLW 12
LDNW 12
NCHECK 346
LDNW 28
NCHECK 346
LOADW
CONST 10
JNEQ L488
!         G.DeRef(x); x.type := x.type.base
LINE 347
LDLW 16
LDLW 12
GLOBAL OMSPG.DeRef
CALL 2
LDLW 12
LDNW 12
NCHECK 347
LDNW 28
LDLW 12
STNW 12
LABEL L488
!       IF sym = S.lparen THEN
LINE 349
LDGW OMSPP.sym
CONST 28
JNEQ L483
!         S.Get(sym);
LINE 350
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!         IF (x.type.form = B.Proc) & (x.type.base.form # B.NoTyp) THEN
LINE 351
LDLW 12
LDNW 12
NCHECK 351
LOADW
CONST 10
JNEQ L495
LDLW 12
LDNW 12
NCHECK 351
LDNW 28
NCHECK 351
LOADW
CONST 9
JEQ L495
!           IF isLeaf THEN S.Mark("no call in leaf func"); ParamList(x.type)
LINE 352
LDGC OMSPP.isLeaf
JEQZ L498
CONST 21
GLOBAL OMSPP.%41
GLOBAL OMSPS.Mark
CALL 2
LDLW 12
LDNW 12
GLOBAL OMSPP.ParamList
CALL 1
RETURN
LABEL L498
!           ELSE G.PrepCall(x, rx, orx, pau); ParamList(x.type); G.Call(x, rx, orx, pau); x.type := x.type.base; selector(x)
LINE 353
LOCAL -13
LOCAL -12
LOCAL -8
LDLW 16
LDLW 12
GLOBAL OMSPG.PrepCall
CALL 5
LDLW 12
LDNW 12
GLOBAL OMSPP.ParamList
CALL 1
LDLC -13
ALIGNC
LDLW -12
LDLW -8
LDLW 16
LDLW 12
GLOBAL OMSPG.Call
CALL 5
LDLW 12
LDNW 12
NCHECK 353
LDNW 28
LDLW 12
STNW 12
LDLW 16
LDLW 12
GLOBAL OMSPP.selector
CALL 2
RETURN
LABEL L495
!         ELSE S.Mark("not a function"); ParamList(x.type)
LINE 355
CONST 15
GLOBAL OMSPP.%42
GLOBAL OMSPS.Mark
CALL 2
LDLW 12
LDNW 12
GLOBAL OMSPP.ParamList
CALL 1
RETURN
LABEL L485
!     ELSIF sym = S.int THEN G.MakeConstItem(x, B.intType, S.ival); S.Get(sym)
LINE 358
LDGW OMSPP.sym
CONST 21
JNEQ L501
LDGW OMSPS.ival
LDGW OMSPB.intType
LDLW 16
LDLW 12
GLOBAL OMSPG.MakeConstItem
CALL 4
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
RETURN
LABEL L501
!     ELSIF sym = S.char THEN G.MakeConstItem(x, B.charType, S.ival); S.Get(sym)
LINE 359
LDGW OMSPP.sym
CONST 20
JNEQ L503
LDGW OMSPS.ival
LDGW OMSPB.charType
LDLW 16
LDLW 12
GLOBAL OMSPG.MakeConstItem
CALL 4
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
RETURN
LABEL L503
!     ELSIF sym = S.nil THEN S.Get(sym); G.MakeConstItem(x, B.nilType, 0)
LINE 360
LDGW OMSPP.sym
CONST 25
JNEQ L505
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
CONST 0
LDGW OMSPB.nilType
LDLW 16
LDLW 12
GLOBAL OMSPG.MakeConstItem
CALL 4
RETURN
LABEL L505
!     ELSIF sym = S.string THEN G.MakeStringItem(x); S.Get(sym)
LINE 361
LDGW OMSPP.sym
CONST 26
JNEQ L507
LDLW 16
LDLW 12
GLOBAL OMSPG.MakeStringItem
CALL 2
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
RETURN
LABEL L507
!     ELSIF sym = S.lparen THEN S.Get(sym); expression(x); Check(S.rparen, "no )")
LINE 362
LDGW OMSPP.sym
CONST 28
JNEQ L509
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW 16
LDLW 12
LDGW OMSPP.expression
NCHECK 362
CALL 2
CONST 5
GLOBAL OMSPP.%16
CONST 44
GLOBAL OMSPP.Check
CALL 3
RETURN
LABEL L509
!     ELSIF sym = S.lbrace THEN S.Get(sym); set(x); Check(S.rbrace, "no }")
LINE 363
LDGW OMSPP.sym
CONST 30
JNEQ L511
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW 16
LDLW 12
GLOBAL OMSPP.set
CALL 2
CONST 5
GLOBAL OMSPP.%43
CONST 46
GLOBAL OMSPP.Check
CALL 3
RETURN
LABEL L511
!     ELSIF sym = S.not THEN S.Get(sym); factor(x); CheckBool(x); G.Not(x)
LINE 364
LDGW OMSPP.sym
CONST 27
JNEQ L513
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW 16
LDLW 12
GLOBAL OMSPP.factor
CALL 2
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckBool
CALL 2
LDLW 16
LDLW 12
GLOBAL OMSPG.Not
CALL 2
RETURN
LABEL L513
!     ELSIF sym = S.false THEN S.Get(sym); G.MakeConstItem(x, B.boolType, 0)
LINE 365
LDGW OMSPP.sym
CONST 23
JNEQ L515
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
CONST 0
LDGW OMSPB.boolType
LDLW 16
LDLW 12
GLOBAL OMSPG.MakeConstItem
CALL 4
RETURN
LABEL L515
!     ELSIF sym = S.true THEN S.Get(sym); G.MakeConstItem(x, B.boolType, 1)
LINE 366
LDGW OMSPP.sym
CONST 24
JNEQ L517
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
CONST 1
LDGW OMSPB.boolType
LDLW 16
LDLW 12
GLOBAL OMSPG.MakeConstItem
CALL 4
RETURN
LABEL L517
!     ELSE S.Mark("not a factor"); S.Get(sym); G.MakeConstItem(x, B.intType, 0)
LINE 367
CONST 13
GLOBAL OMSPP.%44
GLOBAL OMSPS.Mark
CALL 2
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
CONST 0
LDGW OMSPB.intType
LDLW 16
LDLW 12
GLOBAL OMSPG.MakeConstItem
CALL 4
LABEL L483
RETURN
END

PROC OMSPP.term 52 6 0x00100601
!   PROCEDURE term(VAR x: G.Item);
LINE 371
!   BEGIN factor(x); f := x.type.form;
LINE 373
LDLW 16
LDLW 12
GLOBAL OMSPP.factor
CALL 2
LDLW 12
LDNW 12
NCHECK 373
LOADW
STLW -52
LABEL L518
!     WHILE (sym >= S.times) & (sym <= S.and) DO
LINE 374
LDGW OMSPP.sym
CONST 1
JLT L520
LDGW OMSPP.sym
CONST 5
JGT L520
!       op := sym; S.Get(sym);
LINE 375
LDGW OMSPP.sym
STLW -48
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!       IF op = S.times THEN
LINE 376
LDLW -48
CONST 1
JNEQ L523
!         IF f = B.Int THEN factor(y); CheckInt(y); G.MulOp(x, y)
LINE 377
LDLW -52
CONST 4
JNEQ L526
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.factor
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
GLOBAL OMSPG.MulOp
CALL 4
JUMP L518
LABEL L526
!          ELSIF f = B.Set THEN factor(y); CheckSet(y); G.SetOp(op, x, y)
LINE 378
LDLW -52
CONST 6
JNEQ L528
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.factor
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckSet
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
LDLW -48
GLOBAL OMSPG.SetOp
CALL 5
JUMP L518
LABEL L528
!         ELSE S.Mark("bad type")
LINE 379
CONST 9
GLOBAL OMSPP.%17
GLOBAL OMSPS.Mark
CALL 2
JUMP L518
LABEL L523
!       ELSIF (op = S.div) OR (op = S.mod) THEN
LINE 381
LDLW -48
CONST 3
JEQ L529
LDLW -48
CONST 4
JNEQ L530
LABEL L529
!         CheckInt(x); factor(y); CheckInt(y); G.DivOp(op, x, y)
LINE 382
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.factor
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
LDLW -48
GLOBAL OMSPG.DivOp
CALL 5
JUMP L518
LABEL L530
!       ELSIF op = S.rdiv THEN
LINE 383
LDLW -48
CONST 2
JNEQ L533
!         IF f = B.Set THEN factor(y); CheckSet(y); G.SetOp(op, x, y)
LINE 384
LDLW -52
CONST 6
JNEQ L536
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.factor
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckSet
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
LDLW -48
GLOBAL OMSPG.SetOp
CALL 5
JUMP L518
LABEL L536
!         ELSE S.Mark("bad type")
LINE 385
CONST 9
GLOBAL OMSPP.%17
GLOBAL OMSPS.Mark
CALL 2
JUMP L518
LABEL L533
!       ELSE (*op = and*) CheckBool(x); G.And1(x); factor(y); CheckBool(y); G.And2(x, y)
LINE 387
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckBool
CALL 2
LDLW 16
LDLW 12
GLOBAL OMSPG.And1
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.factor
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckBool
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
GLOBAL OMSPG.And2
CALL 4
JUMP L518
LABEL L520
RETURN
END

PROC OMSPP.SimpleExpression 48 6 0x00100601
!   PROCEDURE SimpleExpression(VAR x: G.Item);
LINE 392
!     IF sym = S.minus THEN S.Get(sym); term(x);
LINE 395
LDGW OMSPP.sym
CONST 7
JNEQ L540
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW 16
LDLW 12
GLOBAL OMSPP.term
CALL 2
!       IF x.type.form IN {B.Int, B.Set} THEN G.Neg(x) ELSE CheckInt(x) END
LINE 396
CONST 1
LDLW 12
LDNW 12
NCHECK 396
LOADW
CONST 32
BOUND 396
LSL
CONST 80
BITAND
JEQZ L543
LDLW 16
LDLW 12
GLOBAL OMSPG.Neg
CALL 2
JUMP L538
LABEL L543
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckInt
CALL 2
JUMP L538
LABEL L540
!     ELSIF sym = S.plus THEN S.Get(sym); term(x);
LINE 397
LDGW OMSPP.sym
CONST 6
JNEQ L545
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW 16
LDLW 12
GLOBAL OMSPP.term
CALL 2
JUMP L538
LABEL L545
!     ELSE term(x)
LINE 398
LDLW 16
LDLW 12
GLOBAL OMSPP.term
CALL 2
LABEL L538
!     WHILE (sym >= S.plus) & (sym <= S.or) DO
LINE 400
LDGW OMSPP.sym
CONST 6
JLT L548
LDGW OMSPP.sym
CONST 8
JGT L548
!       op := sym; S.Get(sym);
LINE 401
LDGW OMSPP.sym
STLW -48
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!       IF op = S.or THEN G.Or1(x); CheckBool(x); term(y); CheckBool(y); G.Or2(x, y)
LINE 402
LDLW -48
CONST 8
JNEQ L551
LDLW 16
LDLW 12
GLOBAL OMSPG.Or1
CALL 2
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckBool
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.term
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckBool
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
GLOBAL OMSPG.Or2
CALL 4
JUMP L538
LABEL L551
!       ELSIF x.type.form = B.Int THEN term(y); CheckInt(y); G.AddOp(op, x, y)
LINE 403
LDLW 12
LDNW 12
NCHECK 403
LOADW
CONST 4
JNEQ L553
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.term
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
LDLW -48
GLOBAL OMSPG.AddOp
CALL 5
JUMP L538
LABEL L553
!       ELSIF x.type.form = B.String THEN term(y);
LINE 404
LDLW 12
LDNW 12
NCHECK 404
LOADW
CONST 11
JNEQ L555
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.term
CALL 2
!         IF y.type.form IN {B.String, B.Char} THEN G.StringOp(op, x, y) ELSE S.Mark("not String nor Char") END
LINE 405
CONST 1
LDLW -32
NCHECK 405
LOADW
CONST 32
BOUND 405
LSL
CONST 2056
BITAND
JEQZ L558
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
LDLW -48
GLOBAL OMSPG.StringOp
CALL 5
JUMP L538
LABEL L558
CONST 20
GLOBAL OMSPP.%45
GLOBAL OMSPS.Mark
CALL 2
JUMP L538
LABEL L555
!       ELSE CheckSet(x); term(y); CheckSet(y); G.SetOp(op, x, y)
LINE 406
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckSet
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.term
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckSet
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
LDLW -48
GLOBAL OMSPG.SetOp
CALL 5
JUMP L538
LABEL L548
RETURN
END

PROC OMSPP.expression0 60 6 0x00100621
!   PROCEDURE expression0(VAR x: G.Item);
LINE 411
!   BEGIN SimpleExpression(x);
LINE 413
LDLW 16
LDLW 12
GLOBAL OMSPP.SimpleExpression
CALL 2
!     IF (sym >= S.eql) & (sym <= S.leq) THEN
LINE 414
LDGW OMSPP.sym
CONST 9
JLT L562
LDGW OMSPP.sym
CONST 14
JGT L562
!       rel := sym; S.Get(sym); SimpleExpression(y); xf := x.type.form; yf := y.type.form;
LINE 415
LDGW OMSPP.sym
STLW -52
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.SimpleExpression
CALL 2
LDLW 12
LDNW 12
NCHECK 415
LOADW
STLW -56
LDLW -32
NCHECK 415
LOADW
STLW -60
!       IF x.type = y.type THEN
LINE 416
LDLW 12
LDNW 12
LDLW -32
JNEQ L565
!         IF (xf IN {B.Char, B.Int}) THEN G.IntRelation(rel, x, y)
LINE 417
CONST 1
LDLW -56
CONST 32
BOUND 417
LSL
CONST 24
BITAND
JEQZ L568
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
LDLW -52
GLOBAL OMSPG.IntRelation
CALL 5
JUMP L563
LABEL L568
!         ELSIF (xf IN {B.Set, B.Pointer, B.Proc, B.NilTyp, B.Bool}) THEN
LINE 418
CONST 1
LDLW -56
CONST 32
BOUND 418
LSL
CONST 1476
BITAND
JEQZ L570
!           IF rel <= S.neq THEN G.IntRelation(rel, x, y) ELSE S.Mark("only = or #") END
LINE 419
LDLW -52
CONST 10
JGT L573
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
LDLW -52
GLOBAL OMSPG.IntRelation
CALL 5
JUMP L563
LABEL L573
CONST 12
GLOBAL OMSPP.%46
GLOBAL OMSPS.Mark
CALL 2
JUMP L563
LABEL L570
!         ELSIF (xf = B.Array) & (x.type.base.form = B.Char) OR (xf = B.String) THEN
LINE 420
LDLW -56
CONST 12
JNEQ L576
LDLW 12
LDNW 12
NCHECK 420
LDNW 28
NCHECK 420
LOADW
CONST 3
JEQ L574
LABEL L576
LDLW -56
CONST 11
JNEQ L575
LABEL L574
!           G.StringRelation(rel, x, y)
LINE 421
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
LDLW -52
GLOBAL OMSPG.StringRelation
CALL 5
JUMP L563
LABEL L575
!         ELSE S.Mark("illegal comparison")
LINE 422
CONST 19
GLOBAL OMSPP.%47
GLOBAL OMSPS.Mark
CALL 2
JUMP L563
LABEL L565
!       ELSIF (xf IN {B.Pointer, B.Proc}) & (yf = B.NilTyp)
LINE 424
CONST 1
LDLW -56
CONST 32
BOUND 424
LSL
CONST 1152
BITAND
JEQZ L583
LDLW -60
CONST 8
JEQ L578
LABEL L583
CONST 1
LDLW -60
CONST 32
BOUND 425
LSL
CONST 1152
BITAND
JEQZ L579
LDLW -56
CONST 8
JNEQ L579
LABEL L578
!         IF rel <= S.neq THEN G.IntRelation(rel, x,  y) ELSE S.Mark("only = or #") END
LINE 426
LDLW -52
CONST 10
JGT L582
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
LDLW -52
GLOBAL OMSPG.IntRelation
CALL 5
JUMP L563
LABEL L582
CONST 12
GLOBAL OMSPP.%46
GLOBAL OMSPS.Mark
CALL 2
JUMP L563
LABEL L579
!       ELSIF (xf = B.Pointer) & (yf = B.Pointer) &
LINE 427
LDLW -56
CONST 7
JNEQ L591
LDLW -60
CONST 7
JNEQ L591
LDLW -32
NCHECK 428
LDNW 28
LDLW 12
LDNW 12
NCHECK 428
LDNW 28
GLOBAL OMSPP.IsExtension
CALLW 2
JNEQZ L586
LDLW 12
LDNW 12
NCHECK 428
LDNW 28
LDLW -32
NCHECK 428
LDNW 28
GLOBAL OMSPP.IsExtension
CALLW 2
JNEQZ L586
LABEL L591
LDLW -56
CONST 10
JNEQ L587
LDLW -60
CONST 10
JNEQ L587
LDLW -32
LDLW 12
LDNW 12
GLOBAL OMSPP.EqualSignatures
CALLW 2
JEQZ L587
LABEL L586
!         IF rel <= S.neq THEN G.IntRelation(rel,  x, y) ELSE S.Mark("only = or #") END
LINE 430
LDLW -52
CONST 10
JGT L590
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
LDLW -52
GLOBAL OMSPG.IntRelation
CALL 5
JUMP L563
LABEL L590
CONST 12
GLOBAL OMSPP.%46
GLOBAL OMSPS.Mark
CALL 2
JUMP L563
LABEL L587
!       ELSIF (xf = B.Array) & (x.type.base.form = B.Char) &
LINE 431
LDLW -56
CONST 12
JNEQ L599
LDLW 12
LDNW 12
NCHECK 431
LDNW 28
NCHECK 431
LOADW
CONST 3
JNEQ L599
LDLW -60
CONST 11
JEQ L597
LDLW -60
CONST 12
JNEQ L599
LDLW -32
NCHECK 432
LDNW 28
NCHECK 432
LOADW
CONST 3
JEQ L597
LABEL L599
LDLW -60
CONST 12
JNEQ L598
LDLW -32
NCHECK 433
LDNW 28
NCHECK 433
LOADW
CONST 3
JNEQ L598
LDLW -56
CONST 11
JNEQ L598
LABEL L597
!         G.StringRelation(rel, x, y)
LINE 434
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
LDLW -52
GLOBAL OMSPG.StringRelation
CALL 5
JUMP L563
LABEL L598
!       ELSIF (xf = B.Char) & (yf = B.String) & (G.Length(y) = 2) THEN
LINE 435
LDLW -56
CONST 3
JNEQ L607
LDLW -60
CONST 11
JNEQ L607
LOCAL -44
GLOBAL OMSPG.Length
CALLW 1
CONST 2
JNEQ L607
!         G.StrToChar(y); G.IntRelation(rel, x, y)
LINE 436
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.StrToChar
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
LDLW -52
GLOBAL OMSPG.IntRelation
CALL 5
JUMP L563
LABEL L607
!       ELSIF (xf = B.Int) & (yf = B.Int) THEN G.IntRelation(rel,  x, y)  (*BYTE*)
LINE 437
LDLW -56
CONST 4
JNEQ L611
LDLW -60
CONST 4
JNEQ L611
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
LDLW -52
GLOBAL OMSPG.IntRelation
CALL 5
JUMP L563
LABEL L611
!       ELSIF (xf = B.Set) & (yf = B.Set) THEN
LINE 438
LDLW -56
CONST 6
JNEQ L614
LDLW -60
CONST 6
JNEQ L614
!         IF rel <= S.neq THEN G.IntRelation(rel, x, y) ELSE S.Mark("only = or #") END (*byte SET*)
LINE 439
LDLW -52
CONST 10
JGT L617
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
LDLW -52
GLOBAL OMSPG.IntRelation
CALL 5
JUMP L563
LABEL L617
CONST 12
GLOBAL OMSPP.%46
GLOBAL OMSPS.Mark
CALL 2
JUMP L563
LABEL L614
!       ELSE S.Mark("illegal comparison")
LINE 440
CONST 19
GLOBAL OMSPP.%47
GLOBAL OMSPS.Mark
CALL 2
LABEL L563
!       x.type := B.boolType
LINE 442
LDGW OMSPB.boolType
LDLW 12
STNW 12
RETURN
LABEL L562
!     ELSIF sym = S.in THEN
LINE 443
LDGW OMSPP.sym
CONST 15
JNEQ L621
!       S.Get(sym); CheckInt(x); SimpleExpression(y); CheckSet(y); G.In(x, y) ;
LINE 444
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.SimpleExpression
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckSet
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
LDLW 16
LDLW 12
GLOBAL OMSPG.In
CALL 4
!       x.type := B.boolType
LINE 445
LDGW OMSPB.boolType
LDLW 12
STNW 12
RETURN
LABEL L621
!     ELSIF sym = S.is THEN
LINE 446
LDGW OMSPP.sym
CONST 16
JNEQ L623
!       S.Get(sym); qualident(obj); TypeTest(x, obj.type, FALSE) ;
LINE 447
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LOCAL -48
GLOBAL OMSPP.qualident
CALL 1
CONST 0
ALIGNC
LDLW -48
NCHECK 447
LDNW 20
LDLW 16
LDLW 12
GLOBAL OMSPP.TypeTest
CALL 4
!       x.type := B.boolType
LINE 448
LDGW OMSPB.boolType
LDLW 12
STNW 12
LABEL L623
RETURN
END

PROC OMSPP.StandProc 140 7 OMSPP.StandProc.%map
!   PROCEDURE StandProc(pno: INTEGER);
LINE 454
!   BEGIN npar := pno MOD 10; pno := pno DIV 10;
LINE 457
LDLW 12
CONST 10
MOD
STLW -8
LDLW 12
CONST 10
DIV
STLW 12
!     IF npar # 0 THEN
LINE 458
LDLW -8
JEQZ L626
!       Check(S.lparen, "no (");
LINE 459
CONST 5
GLOBAL OMSPP.%15
CONST 28
GLOBAL OMSPP.Check
CALL 3
!       IF (pno = 4) (*ASSERT*) & ~G.AssertionChecked() THEN G.EnableCode(FALSE) END;
LINE 460
LDLW 12
CONST 4
JNEQ L629
GLOBAL OMSPG.AssertionChecked
CALLW 0
JNEQZ L629
CONST 0
ALIGNC
GLOBAL OMSPG.EnableCode
CALL 1
LABEL L629
!       expression(x); nap := 1; IF x.obj # NIL THEN x.rdo := x.obj.rdo END; G.CheckWritable(x);
LINE 461
GLOBAL OMSPG.Item
LOCAL -52
LDGW OMSPP.expression
NCHECK 461
CALL 2
CONST 1
STLW -4
LDLW -36
JEQZ L633
LDLW -36
NCHECK 461
CONST 5
LDIC
STLC -12
LABEL L633
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.CheckWritable
CALL 2
!       IF sym = S.comma THEN S.Get(sym);
LINE 462
LDGW OMSPP.sym
CONST 40
JNEQ L636
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!         expression(y); nap := 2; z.type := B.noType;
LINE 463
GLOBAL OMSPG.Item
LOCAL -96
LDGW OMSPP.expression
NCHECK 463
CALL 2
CONST 2
STLW -4
LDGW OMSPB.noType
STLW -128
LABEL L637
!         WHILE sym = S.comma DO S.Get(sym); expression(z); INC(nap) END
LINE 464
LDGW OMSPP.sym
CONST 40
JNEQ L634
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -140
LDGW OMSPP.expression
NCHECK 464
CALL 2
INCL -4
JUMP L637
LABEL L636
!       ELSE y.type := B.noType
LINE 465
LDGW OMSPB.noType
STLW -84
LABEL L634
!       Check(S.rparen, "no )")
LINE 467
CONST 5
GLOBAL OMSPP.%16
CONST 44
GLOBAL OMSPP.Check
CALL 3
JUMP L624
LABEL L626
!     ELSE nap := 0
LINE 468
CONST 0
STLW -4
LABEL L624
!     IF (npar = nap) OR (pno IN {0, 1}) THEN 
LINE 470
LDLW -8
LDLW -4
JEQ L641
CONST 1
LDLW 12
CONST 32
BOUND 470
LSL
CONST 3
BITAND
JEQZ L642
LABEL L641
!       IF pno IN {0, 1} THEN (*INC, DEC*)
LINE 471
CONST 1
LDLW 12
CONST 32
BOUND 471
LSL
CONST 3
BITAND
JEQZ L647
!         CheckInt(x); CheckReadOnly(x);
LINE 472
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPP.CheckReadOnly
CALL 2
!         IF y.type # B.noType THEN CheckInt(y) END ;
LINE 473
LDLW -84
LDGW OMSPB.noType
JEQ L650
GLOBAL OMSPG.Item
LOCAL -96
GLOBAL OMSPP.CheckInt
CALL 2
LABEL L650
!         G.Increment(pno, x, y)
LINE 474
GLOBAL OMSPG.Item
LOCAL -96
GLOBAL OMSPG.Item
LOCAL -52
LDLW 12
GLOBAL OMSPG.Increment
CALL 5
JUMP L640
LABEL L647
!       ELSIF pno IN {2, 3} THEN (*INCL, EXCL*)
LINE 475
CONST 1
LDLW 12
CONST 32
BOUND 475
LSL
CONST 12
BITAND
JEQZ L652
!         CheckSet(x); CheckReadOnly(x); CheckInt(y); G.Include(pno-2, x, y)
LINE 476
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPP.CheckSet
CALL 2
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPP.CheckReadOnly
CALL 2
GLOBAL OMSPG.Item
LOCAL -96
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -96
GLOBAL OMSPG.Item
LOCAL -52
LDLW 12
CONST 2
MINUS
GLOBAL OMSPG.Include
CALL 5
JUMP L640
LABEL L652
!       ELSIF pno = 4 THEN CheckBool(x); G.Assert(x)
LINE 477
LDLW 12
CONST 4
JNEQ L654
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPP.CheckBool
CALL 2
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.Assert
CALL 2
JUMP L640
LABEL L654
!       ELSIF pno IN {5, 6, 7, 8} THEN CheckReadOnly(x); G.Logical(pno-5, x, y)
LINE 478
CONST 1
LDLW 12
CONST 32
BOUND 478
LSL
CONST 480
BITAND
JEQZ L656
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPP.CheckReadOnly
CALL 2
GLOBAL OMSPG.Item
LOCAL -96
GLOBAL OMSPG.Item
LOCAL -52
LDLW 12
CONST 5
MINUS
GLOBAL OMSPG.Logical
CALL 5
JUMP L640
LABEL L656
!       ELSIF pno IN {9, 10} THEN G.LogicalSR(pno-9, x)
LINE 479
CONST 1
LDLW 12
CONST 32
BOUND 479
LSL
CONST 1536
BITAND
JEQZ L658
GLOBAL OMSPG.Item
LOCAL -52
LDLW 12
CONST 9
MINUS
GLOBAL OMSPG.LogicalSR
CALL 3
JUMP L640
LABEL L658
!       ELSIF pno = 12 THEN CheckInt(x); CheckInt(y); CheckInt(z); G.Copy(x, y, z)
LINE 480
LDLW 12
CONST 12
JNEQ L660
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -96
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -140
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -140
GLOBAL OMSPG.Item
LOCAL -96
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.Copy
CALL 6
JUMP L640
LABEL L660
!       ELSIF pno = 13 THEN G.ClrC
LINE 481
LDLW 12
CONST 13
JNEQ L662
GLOBAL OMSPG.ClrC
CALL 0
JUMP L640
LABEL L662
!       ELSIF pno = 14 THEN G.Nop
LINE 482
LDLW 12
CONST 14
JNEQ L664
GLOBAL OMSPG.Nop
CALL 0
JUMP L640
LABEL L664
!       ELSIF pno = 15 THEN CheckReadOnly(x); G.ADC(x, y)
LINE 483
LDLW 12
CONST 15
JNEQ L666
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPP.CheckReadOnly
CALL 2
GLOBAL OMSPG.Item
LOCAL -96
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.ADC
CALL 4
JUMP L640
LABEL L666
!       ELSIF pno = 16 THEN CheckReadOnly(x); G.SBC(x, y)
LINE 484
LDLW 12
CONST 16
JNEQ L668
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPP.CheckReadOnly
CALL 2
GLOBAL OMSPG.Item
LOCAL -96
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.SBC
CALL 4
JUMP L640
LABEL L668
!       ELSIF pno IN {17, 19} THEN (*RLA, RRA*) CheckReadOnly(x); CheckInt(y);
LINE 485
CONST 1
LDLW 12
CONST 32
BOUND 485
LSL
CONST 655360
BITAND
JEQZ L670
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPP.CheckReadOnly
CALL 2
GLOBAL OMSPG.Item
LOCAL -96
GLOBAL OMSPP.CheckInt
CALL 2
!         IF x.type.form IN {B.Int, B.Set} THEN G.Shift(pno-17, x, y) ELSE S.Mark("bad type") END
LINE 486
CONST 1
LDLW -40
NCHECK 486
LOADW
CONST 32
BOUND 486
LSL
CONST 80
BITAND
JEQZ L673
GLOBAL OMSPG.Item
LOCAL -96
GLOBAL OMSPG.Item
LOCAL -52
LDLW 12
CONST 17
MINUS
GLOBAL OMSPG.Shift
CALL 5
JUMP L640
LABEL L673
CONST 9
GLOBAL OMSPP.%17
GLOBAL OMSPS.Mark
CALL 2
JUMP L640
LABEL L670
!       ELSIF pno IN {18, 20} THEN (*RLC, RRC*) CheckReadOnly(x);
LINE 487
CONST 1
LDLW 12
CONST 32
BOUND 487
LSL
CONST 1310720
BITAND
JEQZ L675
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPP.CheckReadOnly
CALL 2
!         IF x.type.form IN {B.Int, B.Set} THEN G.Rotate(pno-18, x) ELSE S.Mark("bad type") END
LINE 488
CONST 1
LDLW -40
NCHECK 488
LOADW
CONST 32
BOUND 488
LSL
CONST 80
BITAND
JEQZ L678
GLOBAL OMSPG.Item
LOCAL -52
LDLW 12
CONST 18
MINUS
GLOBAL OMSPG.Rotate
CALL 3
JUMP L640
LABEL L678
CONST 9
GLOBAL OMSPP.%17
GLOBAL OMSPS.Mark
CALL 2
JUMP L640
LABEL L675
!       ELSIF pno IN {21, 22} THEN 
LINE 489
CONST 1
LDLW 12
CONST 32
BOUND 489
LSL
CONST 6291456
BITAND
JEQZ L680
!         IF isInt THEN G.LogicalSROnExit(pno-21, x) ELSE S.Mark("not allowed here") END
LINE 490
LDGC OMSPP.isInt
JEQZ L683
GLOBAL OMSPG.Item
LOCAL -52
LDLW 12
CONST 21
MINUS
GLOBAL OMSPG.LogicalSROnExit
CALL 3
JUMP L640
LABEL L683
CONST 17
GLOBAL OMSPP.%48
GLOBAL OMSPS.Mark
CALL 2
JUMP L640
LABEL L680
!       ELSIF pno = 23 THEN CheckReadOnly(x); CheckInt(x); G.Swpb(x)
LINE 491
LDLW 12
CONST 23
JNEQ L685
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPP.CheckReadOnly
CALL 2
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.Swpb
CALL 2
JUMP L640
LABEL L685
!       ELSIF pno = 24 THEN CheckReadOnly(x); CheckInt(x); G.Neg(x)
LINE 492
LDLW 12
CONST 24
JNEQ L687
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPP.CheckReadOnly
CALL 2
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.Neg
CALL 2
JUMP L640
LABEL L687
CONST 0
CONST 493
GLOBAL EASSERT
CALL 2
JUMP L640
LABEL L642
!     ELSE S.Mark("wrong nof parameters")
LINE 495
CONST 21
GLOBAL OMSPP.%49
GLOBAL OMSPS.Mark
CALL 2
LABEL L640
!     G.EnableCode(TRUE)
LINE 497
CONST 1
ALIGNC
GLOBAL OMSPG.EnableCode
CALL 1
RETURN
END

PROC OMSPP.%119.TypeCase 8 5 0x00308001
SAVELINK
!     PROCEDURE TypeCase(obj: B.Object; VAR x: G.Item);
LINE 506
!     BEGIN G.MakeItem(x, obj, level);
LINE 508
LDGW OMSPP.level
LDLW 12
LDLW 20
LDLW 16
GLOBAL OMSPG.MakeItem
CALL 4
!       IF sym = S.ident THEN
LINE 509
LDGW OMSPP.sym
CONST 31
JNEQ L691
!         qualident(typobj);
LINE 510
LOCAL -8
GLOBAL OMSPP.qualident
CALL 1
!         IF typobj.class # B.Typ THEN S.Mark("not a type") END ;
LINE 511
LDLW -8
NCHECK 511
LOADC
CONST 5
JEQ L694
CONST 11
GLOBAL OMSPP.%50
GLOBAL OMSPS.Mark
CALL 2
LABEL L694
!         TypeTest(x, typobj.type, FALSE); obj.type := typobj.type;
LINE 512
CONST 0
ALIGNC
LDLW -8
NCHECK 512
LDNW 20
LDLW 20
LDLW 16
GLOBAL OMSPP.TypeTest
CALL 4
LDLW -8
NCHECK 512
LDNW 20
LDLW 12
NCHECK 512
STNW 20
!         G.CFJump(x); Check(S.colon, ": expected"); StatSequence
LINE 513
LDLW 20
LDLW 16
GLOBAL OMSPG.CFJump
CALL 2
CONST 11
GLOBAL OMSPP.%51
CONST 41
GLOBAL OMSPP.Check
CALL 3
GLOBAL OMSPP.StatSequence
CALL 0
RETURN
LABEL L691
!       ELSE G.CFJump(x); S.Mark("type id expected")
LINE 514
LDLW 20
LDLW 16
GLOBAL OMSPG.CFJump
CALL 2
CONST 17
GLOBAL OMSPP.%52
GLOBAL OMSPS.Mark
CALL 2
RETURN
END

PROC OMSPP.%120.SkipCase 4 2 0
SAVELINK
!     PROCEDURE SkipCase;
LINE 518
LABEL L695
!       WHILE sym # S.colon DO S.Get(sym) END ;
LINE 520
LDGW OMSPP.sym
CONST 41
JEQ L697
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
JUMP L695
LABEL L697
!       S.Get(sym); StatSequence
LINE 521
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPP.StatSequence
CALL 0
RETURN
END

PROC OMSPP.StatSequence 204 10 OMSPP.StatSequence.%map
!   PROCEDURE StatSequence;
LINE 500
LABEL L698
!     REPEAT (*sync*) obj := NIL;
LINE 525
CONST 0
STLW -4
!       IF ~((sym >= S.ident)  & (sym <= S.for) OR (sym >= S.semicolon)) THEN
LINE 526
LDGW OMSPP.sym
CONST 31
JLT L705
LDGW OMSPP.sym
CONST 37
JLEQ L702
LABEL L705
LDGW OMSPP.sym
CONST 52
JGEQ L702
!         S.Mark("statement expected");
LINE 527
CONST 19
GLOBAL OMSPP.%53
GLOBAL OMSPS.Mark
CALL 2
LABEL L703
!         REPEAT S.Get(sym) UNTIL (sym >= S.ident)
LINE 528
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDGW OMSPP.sym
CONST 31
JLT L703
LABEL L702
!       IF sym = S.ident THEN
LINE 530
LDGW OMSPP.sym
CONST 31
JNEQ L709
!         qualident(obj);  IF initmode & (obj.lev = 0) THEN obj.rdo := FALSE END;
LINE 531
LOCAL -4
GLOBAL OMSPP.qualident
CALL 1
LDGC OMSPP.initmode
JEQZ L712
LDLW -4
NCHECK 531
LDNW 8
JNEQZ L712
CONST 0
LDLW -4
NCHECK 531
CONST 5
STIC
LABEL L712
!         G.MakeItem(x, obj, level);
LINE 532
LDGW OMSPP.level
LDLW -4
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.MakeItem
CALL 4
!         IF x.mode = B.SProc THEN StandProc(obj.val)
LINE 533
LDLW -44
CONST 6
JNEQ L773
LDLW -4
NCHECK 533
LDNW 56
GLOBAL OMSPP.StandProc
CALL 1
JUMP L804
LABEL L773
!         ELSE selector(x);
LINE 534
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPP.selector
CALL 2
!           IF (x.type.form = B.Pointer) & (x.type.base.form = B.Proc) THEN
LINE 535
LDLW -40
NCHECK 535
LOADW
CONST 7
JNEQ L717
LDLW -40
NCHECK 535
LDNW 28
NCHECK 535
LOADW
CONST 10
JNEQ L717
!             G.DeRef(x); x.type := x.type.base
LINE 536
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.DeRef
CALL 2
LDLW -40
NCHECK 536
LDNW 28
STLW -40
LABEL L717
!           IF sym = S.becomes THEN (*assignment*)
LINE 538
LDGW OMSPP.sym
CONST 42
JNEQ L721
!             S.Get(sym); CheckReadOnly(x); expression(y);
LINE 539
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPP.CheckReadOnly
CALL 2
GLOBAL OMSPG.Item
LOCAL -96
LDGW OMSPP.expression
NCHECK 539
CALL 2
!             IF CompTypes(x.type, y.type, FALSE) THEN
LINE 540
CONST 0
ALIGNC
LDLW -84
LDLW -40
GLOBAL OMSPP.CompTypes
CALLW 3
JEQZ L724
!               IF (x.type.form <= B.Pointer) OR (x.type.form = B.Proc) THEN G.Store(x, y)
LINE 541
LDLW -40
NCHECK 541
LOADW
CONST 7
JLEQ L726
LDLW -40
NCHECK 541
LOADW
CONST 10
JNEQ L727
LABEL L726
GLOBAL OMSPG.Item
LOCAL -96
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.Store
CALL 4
JUMP L804
LABEL L727
!               ELSE G.StoreStruct(x, y)
LINE 542
GLOBAL OMSPG.Item
LOCAL -96
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.StoreStruct
CALL 4
JUMP L804
LABEL L724
!             ELSIF (x.type.form = B.Array) & (y.type.form = B.Array) & (x.type.base = y.type.base) & (y.type.len < 0) THEN
LINE 544
LDLW -40
NCHECK 544
LOADW
CONST 12
JNEQ L730
LDLW -84
NCHECK 544
LOADW
CONST 12
JNEQ L730
LDLW -40
NCHECK 544
LDNW 28
LDLW -84
NCHECK 544
LDNW 28
JNEQ L730
LDLW -84
NCHECK 544
LDNW 16
JGEQZ L730
!               G.StoreStruct(x, y)
LINE 545
GLOBAL OMSPG.Item
LOCAL -96
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.StoreStruct
CALL 4
JUMP L804
LABEL L730
!             ELSIF (x.type.form = B.Array) & (x.type.base.form = B.Char) & (y.type.form = B.String) THEN
LINE 546
LDLW -40
NCHECK 546
LOADW
CONST 12
JNEQ L735
LDLW -40
NCHECK 546
LDNW 28
NCHECK 546
LOADW
CONST 3
JNEQ L735
LDLW -84
NCHECK 546
LOADW
CONST 11
JNEQ L735
!               G.CopyString(x, y)
LINE 547
GLOBAL OMSPG.Item
LOCAL -96
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.CopyString
CALL 4
JUMP L804
LABEL L735
!             ELSIF (x.type.form = B.Int) & (y.type.form = B.Int) THEN G.Store(x, y)  (*BYTE*)
LINE 548
LDLW -40
NCHECK 548
LOADW
CONST 4
JNEQ L739
LDLW -84
NCHECK 548
LOADW
CONST 4
JNEQ L739
GLOBAL OMSPG.Item
LOCAL -96
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.Store
CALL 4
JUMP L804
LABEL L739
!             ELSIF (x.type.form = B.Set) & (y.type.form = B.Set) THEN G.Store(x, y)  (*byte SET*)
LINE 549
LDLW -40
NCHECK 549
LOADW
CONST 6
JNEQ L742
LDLW -84
NCHECK 549
LOADW
CONST 6
JNEQ L742
GLOBAL OMSPG.Item
LOCAL -96
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.Store
CALL 4
JUMP L804
LABEL L742
!             ELSIF (x.type.form = B.Char) & (y.type.form = B.String) & (G.Length(y) = 2) THEN
LINE 550
LDLW -40
NCHECK 550
LOADW
CONST 3
JNEQ L745
LDLW -84
NCHECK 550
LOADW
CONST 11
JNEQ L745
LOCAL -96
GLOBAL OMSPG.Length
CALLW 1
CONST 2
JNEQ L745
!               G.StrToChar(y); G.Store(x, y)
LINE 551
GLOBAL OMSPG.Item
LOCAL -96
GLOBAL OMSPG.StrToChar
CALL 2
GLOBAL OMSPG.Item
LOCAL -96
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.Store
CALL 4
JUMP L804
LABEL L745
!             ELSE S.Mark("illegal assignment")
LINE 552
CONST 19
GLOBAL OMSPP.%54
GLOBAL OMSPS.Mark
CALL 2
JUMP L804
LABEL L721
!           ELSIF sym = S.eql THEN S.Mark("should be :="); S.Get(sym); expression(y)
LINE 554
LDGW OMSPP.sym
CONST 9
JNEQ L749
CONST 13
GLOBAL OMSPP.%55
GLOBAL OMSPS.Mark
CALL 2
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -96
LDGW OMSPP.expression
NCHECK 554
CALL 2
JUMP L804
LABEL L749
!           ELSIF sym = S.lparen THEN (*procedure call*)
LINE 555
LDGW OMSPP.sym
CONST 28
JNEQ L751
!             S.Get(sym);
LINE 556
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!             IF (x.type.form = B.Proc) & (x.type.base.form = B.NoTyp) THEN
LINE 557
LDLW -40
NCHECK 557
LOADW
CONST 10
JNEQ L754
LDLW -40
NCHECK 557
LDNW 28
NCHECK 557
LOADW
CONST 9
JNEQ L754
!               IF isLeaf THEN S.Mark("no call in leaf proc"); ParamList(x.type)
LINE 558
LDGC OMSPP.isLeaf
JEQZ L757
CONST 21
GLOBAL OMSPP.%56
GLOBAL OMSPS.Mark
CALL 2
LDLW -40
GLOBAL OMSPP.ParamList
CALL 1
JUMP L804
LABEL L757
!               ELSE G.PrepCall(x, rx, orx, pau); ParamList(x.type); G.Call(x, rx, orx, pau)
LINE 559
LOCAL -201
LOCAL -200
LOCAL -196
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.PrepCall
CALL 5
LDLW -40
GLOBAL OMSPP.ParamList
CALL 1
LDLC -201
ALIGNC
LDLW -200
LDLW -196
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.Call
CALL 5
JUMP L804
LABEL L754
!             ELSE S.Mark("not a procedure"); ParamList(x.type)
LINE 561
CONST 16
GLOBAL OMSPP.%57
GLOBAL OMSPS.Mark
CALL 2
LDLW -40
GLOBAL OMSPP.ParamList
CALL 1
JUMP L804
LABEL L751
!           ELSIF x.type.form = B.Proc THEN (*procedure call without parameters*)
LINE 563
LDLW -40
NCHECK 563
LOADW
CONST 10
JNEQ L760
!             IF x.type.nofpar > 0 THEN S.Mark("missing parameters") END ;
LINE 564
LDLW -40
NCHECK 564
LDNW 12
JLEQZ L763
CONST 19
GLOBAL OMSPP.%58
GLOBAL OMSPS.Mark
CALL 2
LABEL L763
!             IF x.type.base.form = B.NoTyp THEN
LINE 565
LDLW -40
NCHECK 565
LDNW 28
NCHECK 565
LOADW
CONST 9
JNEQ L766
!               IF isLeaf THEN S.Mark("no call in leaf proc")
LINE 566
LDGC OMSPP.isLeaf
JEQZ L769
CONST 21
GLOBAL OMSPP.%56
GLOBAL OMSPS.Mark
CALL 2
JUMP L804
LABEL L769
!               ELSE G.PrepCall(x, rx, orx, pau); G.Call(x, rx, orx, pau)
LINE 567
LOCAL -201
LOCAL -200
LOCAL -196
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.PrepCall
CALL 5
LDLC -201
ALIGNC
LDLW -200
LDLW -196
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.Call
CALL 5
JUMP L804
LABEL L766
!             ELSE S.Mark("not a procedure")
LINE 569
CONST 16
GLOBAL OMSPP.%57
GLOBAL OMSPS.Mark
CALL 2
JUMP L804
LABEL L760
!           ELSIF x.mode = B.Typ THEN S.Mark("illegal assignment")
LINE 571
LDLW -44
CONST 5
JNEQ L771
CONST 19
GLOBAL OMSPP.%54
GLOBAL OMSPS.Mark
CALL 2
JUMP L804
LABEL L771
!           ELSE S.Mark("not a procedure")
LINE 572
CONST 16
GLOBAL OMSPP.%57
GLOBAL OMSPS.Mark
CALL 2
JUMP L804
LABEL L709
!       ELSIF sym = S.if THEN
LINE 575
LDGW OMSPP.sym
CONST 32
JNEQ L775
!         S.Get(sym); expression(x); CheckBool(x); G.CFJump(x);
LINE 576
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -52
LDGW OMSPP.expression
NCHECK 576
CALL 2
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPP.CheckBool
CALL 2
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.CFJump
CALL 2
!         Check(S.then, "no THEN");
LINE 577
CONST 8
GLOBAL OMSPP.%59
CONST 47
GLOBAL OMSPP.Check
CALL 3
!         StatSequence; L0 := 0;
LINE 578
GLOBAL OMSPP.StatSequence
CALL 0
CONST 0
STLW -188
LABEL L776
!         WHILE sym = S.elsif DO
LINE 579
LDGW OMSPP.sym
CONST 56
JNEQ L778
!           S.Get(sym); G.FJump(L0); G.fixup(x); expression(x); CheckBool(x);
LINE 580
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LOCAL -188
GLOBAL OMSPG.FJump
CALL 1
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.fixup
CALL 2
GLOBAL OMSPG.Item
LOCAL -52
LDGW OMSPP.expression
NCHECK 580
CALL 2
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPP.CheckBool
CALL 2
!           G.CFJump(x); Check(S.then, "no THEN"); StatSequence
LINE 581
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.CFJump
CALL 2
CONST 8
GLOBAL OMSPP.%59
CONST 47
GLOBAL OMSPP.Check
CALL 3
GLOBAL OMSPP.StatSequence
CALL 0
JUMP L776
LABEL L778
!         IF sym = S.else THEN S.Get(sym); G.FJump(L0); G.fixup(x); StatSequence
LINE 583
LDGW OMSPP.sym
CONST 55
JNEQ L781
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LOCAL -188
GLOBAL OMSPG.FJump
CALL 1
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.fixup
CALL 2
GLOBAL OMSPP.StatSequence
CALL 0
JUMP L779
LABEL L781
!         ELSE G.fixup(x)
LINE 584
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.fixup
CALL 2
LABEL L779
!         G.FixLink(L0); Check(S.end, "no END")
LINE 586
LDLW -188
GLOBAL OMSPG.FixLink
CALL 1
CONST 7
GLOBAL OMSPP.%60
CONST 53
GLOBAL OMSPP.Check
CALL 3
JUMP L804
LABEL L775
!       ELSIF sym = S.while THEN
LINE 587
LDGW OMSPP.sym
CONST 34
JNEQ L783
!         S.Get(sym); L0 := G.Here(); expression(x); CheckBool(x); G.CFJump(x);
LINE 588
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Here
CALLW 0
STLW -188
GLOBAL OMSPG.Item
LOCAL -52
LDGW OMSPP.expression
NCHECK 588
CALL 2
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPP.CheckBool
CALL 2
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.CFJump
CALL 2
!         Check(S.do, "no DO"); StatSequence; G.BJump(L0);
LINE 589
CONST 6
GLOBAL OMSPP.%61
CONST 49
GLOBAL OMSPP.Check
CALL 3
GLOBAL OMSPP.StatSequence
CALL 0
LDLW -188
GLOBAL OMSPG.BJump
CALL 1
LABEL L784
!         WHILE sym = S.elsif DO
LINE 590
LDGW OMSPP.sym
CONST 56
JNEQ L786
!           S.Get(sym); G.fixup(x); expression(x); CheckBool(x); G.CFJump(x);
LINE 591
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.fixup
CALL 2
GLOBAL OMSPG.Item
LOCAL -52
LDGW OMSPP.expression
NCHECK 591
CALL 2
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPP.CheckBool
CALL 2
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.CFJump
CALL 2
!           Check(S.do, "no DO"); StatSequence; G.BJump(L0)
LINE 592
CONST 6
GLOBAL OMSPP.%61
CONST 49
GLOBAL OMSPP.Check
CALL 3
GLOBAL OMSPP.StatSequence
CALL 0
LDLW -188
GLOBAL OMSPG.BJump
CALL 1
JUMP L784
LABEL L786
!         G.fixup(x); Check(S.end, "no END")
LINE 594
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.fixup
CALL 2
CONST 7
GLOBAL OMSPP.%60
CONST 53
GLOBAL OMSPP.Check
CALL 3
JUMP L804
LABEL L783
!       ELSIF sym = S.repeat THEN
LINE 595
LDGW OMSPP.sym
CONST 35
JNEQ L788
!         S.Get(sym); L0 := G.Here(); StatSequence;
LINE 596
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Here
CALLW 0
STLW -188
GLOBAL OMSPP.StatSequence
CALL 0
!         IF sym = S.until THEN
LINE 597
LDGW OMSPP.sym
CONST 57
JNEQ L791
!           S.Get(sym); expression(x); CheckBool(x); G.CBJump(x, L0)
LINE 598
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -52
LDGW OMSPP.expression
NCHECK 598
CALL 2
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPP.CheckBool
CALL 2
LDLW -188
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.CBJump
CALL 3
JUMP L804
LABEL L791
!         ELSE S.Mark("missing UNTIL")
LINE 599
CONST 14
GLOBAL OMSPP.%62
GLOBAL OMSPS.Mark
CALL 2
JUMP L804
LABEL L788
!       ELSIF sym = S.for THEN
LINE 601
LDGW OMSPP.sym
CONST 37
JNEQ L793
!         S.Get(sym);
LINE 602
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!         IF sym = S.ident THEN
LINE 603
LDGW OMSPP.sym
CONST 31
JNEQ L796
!           qualident(obj); G.MakeItem(x, obj, level); CheckInt(x); CheckReadOnly(x);
LINE 604
LOCAL -4
GLOBAL OMSPP.qualident
CALL 1
LDGW OMSPP.level
LDLW -4
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.MakeItem
CALL 4
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPP.CheckReadOnly
CALL 2
!           IF sym = S.becomes THEN
LINE 605
LDGW OMSPP.sym
CONST 42
JNEQ L799
!             S.Get(sym); expression(y); CheckInt(y); G.For0(x, y); L0 := G.Here();
LINE 606
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -96
LDGW OMSPP.expression
NCHECK 606
CALL 2
GLOBAL OMSPG.Item
LOCAL -96
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -96
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.For0
CALL 4
GLOBAL OMSPG.Here
CALLW 0
STLW -188
!             Check(S.to, "no TO"); expression(z); CheckInt(z); obj.rdo := TRUE;
LINE 607
CONST 6
GLOBAL OMSPP.%63
CONST 50
GLOBAL OMSPP.Check
CALL 3
GLOBAL OMSPG.Item
LOCAL -140
LDGW OMSPP.expression
NCHECK 607
CALL 2
GLOBAL OMSPG.Item
LOCAL -140
GLOBAL OMSPP.CheckInt
CALL 2
CONST 1
LDLW -4
NCHECK 607
CONST 5
STIC
!             IF sym = S.by THEN S.Get(sym); expression(w); CheckConst(w); CheckInt(w)
LINE 608
LDGW OMSPP.sym
CONST 51
JNEQ L802
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -184
LDGW OMSPP.expression
NCHECK 608
CALL 2
GLOBAL OMSPG.Item
LOCAL -184
GLOBAL OMSPP.CheckConst
CALL 2
GLOBAL OMSPG.Item
LOCAL -184
GLOBAL OMSPP.CheckInt
CALL 2
JUMP L800
LABEL L802
!             ELSE G.MakeConstItem(w, B.intType, 1)
LINE 609
CONST 1
LDGW OMSPB.intType
GLOBAL OMSPG.Item
LOCAL -184
GLOBAL OMSPG.MakeConstItem
CALL 4
LABEL L800
!             Check(S.do, "no DO"); G.For1(x, y, z, w, L1);
LINE 611
CONST 6
GLOBAL OMSPP.%61
CONST 49
GLOBAL OMSPP.Check
CALL 3
LOCAL -192
GLOBAL OMSPG.Item
LOCAL -184
GLOBAL OMSPG.Item
LOCAL -140
GLOBAL OMSPG.Item
LOCAL -96
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.For1
CALL 9
!             StatSequence; Check(S.end, "no END");
LINE 612
GLOBAL OMSPP.StatSequence
CALL 0
CONST 7
GLOBAL OMSPP.%60
CONST 53
GLOBAL OMSPP.Check
CALL 3
!             G.For2(x, y, w); G.BJump(L0); G.FixLink(L1); obj.rdo := FALSE
LINE 613
GLOBAL OMSPG.Item
LOCAL -184
GLOBAL OMSPG.Item
LOCAL -96
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.For2
CALL 6
LDLW -188
GLOBAL OMSPG.BJump
CALL 1
LDLW -192
GLOBAL OMSPG.FixLink
CALL 1
CONST 0
LDLW -4
NCHECK 613
CONST 5
STIC
JUMP L804
LABEL L799
!           ELSE S.Mark(":= expected")
LINE 614
CONST 12
GLOBAL OMSPP.%64
GLOBAL OMSPS.Mark
CALL 2
JUMP L804
LABEL L796
!         ELSE S.Mark("identifier expected")
LINE 616
CONST 20
GLOBAL OMSPP.%2
GLOBAL OMSPS.Mark
CALL 2
JUMP L804
LABEL L793
!       ELSIF sym = S.case THEN
LINE 618
LDGW OMSPP.sym
CONST 36
JNEQ L804
!         S.Get(sym);
LINE 619
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!         IF sym = S.ident THEN
LINE 620
LDGW OMSPP.sym
CONST 31
JNEQ L807
!           qualident(obj); orgtype := obj.type;
LINE 621
LOCAL -4
GLOBAL OMSPP.qualident
CALL 1
LDLW -4
NCHECK 621
LDNW 20
STLW -8
!           IF (orgtype.form = B.Pointer) OR (orgtype.form = B.Record) & (obj.class = B.Par) THEN
LINE 622
LDLW -8
NCHECK 622
LOADW
CONST 7
JEQ L812
LDLW -8
NCHECK 622
LOADW
CONST 13
JNEQ L813
LDLW -4
NCHECK 622
LOADC
CONST 3
JNEQ L813
LABEL L812
!             Check(S.of, "OF expected"); TypeCase(obj, x); L0 := 0;
LINE 623
CONST 12
GLOBAL OMSPP.%65
CONST 48
GLOBAL OMSPP.Check
CALL 3
GLOBAL OMSPG.Item
LOCAL -52
LDLW -4
LOCAL 0
STATLINK
GLOBAL OMSPP.%119.TypeCase
CALL 3
CONST 0
STLW -188
LABEL L814
!             WHILE sym = S.bar DO
LINE 624
LDGW OMSPP.sym
CONST 54
JNEQ L816
!               S.Get(sym); G.FJump(L0); G.fixup(x); obj.type := orgtype; TypeCase(obj, x)
LINE 625
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LOCAL -188
GLOBAL OMSPG.FJump
CALL 1
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.fixup
CALL 2
LDLW -8
LDLW -4
NCHECK 625
STNW 20
GLOBAL OMSPG.Item
LOCAL -52
LDLW -4
LOCAL 0
STATLINK
GLOBAL OMSPP.%119.TypeCase
CALL 3
JUMP L814
LABEL L816
!             G.fixup(x); G.FixLink(L0); obj.type := orgtype
LINE 627
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.fixup
CALL 2
LDLW -188
GLOBAL OMSPG.FixLink
CALL 1
LDLW -8
LDLW -4
NCHECK 627
STNW 20
JUMP L805
LABEL L813
!           ELSE S.Mark("numeric case not implemented");
LINE 628
CONST 29
GLOBAL OMSPP.%66
GLOBAL OMSPS.Mark
CALL 2
!             Check(S.of, "OF expected"); SkipCase;
LINE 629
CONST 12
GLOBAL OMSPP.%65
CONST 48
GLOBAL OMSPP.Check
CALL 3
LOCAL 0
STATLINK
GLOBAL OMSPP.%120.SkipCase
CALL 0
LABEL L809
!             WHILE sym = S.bar DO SkipCase END
LINE 630
LDGW OMSPP.sym
CONST 54
JNEQ L805
LOCAL 0
STATLINK
GLOBAL OMSPP.%120.SkipCase
CALL 0
JUMP L809
LABEL L807
!         ELSE S.Mark("ident expected")
LINE 632
CONST 15
GLOBAL OMSPP.%67
GLOBAL OMSPS.Mark
CALL 2
LABEL L805
!         Check(S.end, "no END")
LINE 634
CONST 7
GLOBAL OMSPP.%60
CONST 53
GLOBAL OMSPP.Check
CALL 3
LABEL L804
!       G.CheckRegs;
LINE 636
GLOBAL OMSPG.CheckRegs
CALL 0
!       IF sym = S.semicolon THEN S.Get(sym)
LINE 637
LDGW OMSPP.sym
CONST 52
JNEQ L821
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
JUMP L823
LABEL L821
!       ELSIF sym < S.semicolon THEN S.Mark("missing semicolon?")
LINE 638
LDGW OMSPP.sym
CONST 52
JGEQ L823
CONST 19
GLOBAL OMSPP.%68
GLOBAL OMSPS.Mark
CALL 2
LABEL L823
!     UNTIL sym > S.semicolon
LINE 640
LDGW OMSPP.sym
CONST 52
JLEQ L698
RETURN
END

PROC OMSPP.IdentList 4 4 0x00210001
!   PROCEDURE IdentList(class: INTEGER; VAR first: B.Object);
LINE 645
!     IF sym = S.ident THEN
LINE 648
LDGW OMSPP.sym
CONST 31
JNEQ L826
!       B.NewObj(first, S.id, class); S.Get(sym); CheckExport(first.expo); CheckUnsafeMarking(first.unsafe);
LINE 649
LDLW 12
GLOBAL OMSPS.id
LDLW 16
GLOBAL OMSPB.NewObj
CALL 3
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW 16
LOADW
NCHECK 649
CONST 3
OFFSET
GLOBAL OMSPP.CheckExport
CALL 1
LDLW 16
LOADW
NCHECK 649
CONST 4
OFFSET
GLOBAL OMSPP.CheckUnsafeMarking
CALL 1
LABEL L827
!       WHILE sym = S.comma DO
LINE 650
LDGW OMSPP.sym
CONST 40
JNEQ L829
!         S.Get(sym);
LINE 651
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!         IF sym = S.ident THEN B.NewObj(obj, S.id, class); S.Get(sym); CheckExport(obj.expo); CheckUnsafeMarking(obj.unsafe)
LINE 652
LDGW OMSPP.sym
CONST 31
JNEQ L832
LDLW 12
GLOBAL OMSPS.id
LOCAL -4
GLOBAL OMSPB.NewObj
CALL 3
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW -4
NCHECK 652
CONST 3
OFFSET
GLOBAL OMSPP.CheckExport
CALL 1
LDLW -4
NCHECK 652
CONST 4
OFFSET
GLOBAL OMSPP.CheckUnsafeMarking
CALL 1
JUMP L827
LABEL L832
!         ELSE S.Mark("ident?")
LINE 653
CONST 7
GLOBAL OMSPP.%25
GLOBAL OMSPS.Mark
CALL 2
JUMP L827
LABEL L829
!       IF sym = S.colon THEN S.Get(sym) ELSE S.Mark(":?") END
LINE 656
LDGW OMSPP.sym
CONST 41
JNEQ L835
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
RETURN
LABEL L835
CONST 3
GLOBAL OMSPP.%69
GLOBAL OMSPS.Mark
CALL 2
RETURN
LABEL L826
!     ELSE first := NIL
LINE 657
CONST 0
LDLW 16
STOREW
RETURN
END

PROC OMSPP.ArrayType 52 3 0x00100621
!   PROCEDURE ArrayType(VAR type: B.Type);
LINE 661
!   BEGIN NEW(typ); typ.form := B.NoTyp;
LINE 663
CONST 44
GLOBAL OMSPB.TypeDesc
GLOBAL NEW
CALLW 2
STLW -48
CONST 9
LDLW -48
NCHECK 663
STOREW
!     expression(x);
LINE 664
GLOBAL OMSPG.Item
LOCAL -44
LDGW OMSPP.expression
NCHECK 664
CALL 2
!     IF (x.mode = B.Const) & (x.type.form = B.Int) & (x.a >= 0) THEN len := x.a
LINE 665
LDLW -36
CONST 1
JNEQ L838
LDLW -32
NCHECK 665
LOADW
CONST 4
JNEQ L838
LDLW -24
JLTZ L838
LDLW -24
STLW -52
JUMP L836
LABEL L838
!     ELSE len := 1; S.Mark("not a valid length")
LINE 666
CONST 1
STLW -52
CONST 19
GLOBAL OMSPP.%70
GLOBAL OMSPS.Mark
CALL 2
LABEL L836
!     IF sym = S.of THEN S.Get(sym); Type(typ.base);
LINE 668
LDGW OMSPP.sym
CONST 48
JNEQ L843
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW -48
NCHECK 668
CONST 28
OFFSET
LDGW OMSPP.Type
NCHECK 668
CALL 1
!       IF (typ.base.form = B.Array) & (typ.base.len < 0) THEN S.Mark("dyn array not allowed") END
LINE 669
LDLW -48
NCHECK 669
LDNW 28
NCHECK 669
LOADW
CONST 12
JNEQ L841
LDLW -48
NCHECK 669
LDNW 28
NCHECK 669
LDNW 16
JGEQZ L841
CONST 22
GLOBAL OMSPP.%71
GLOBAL OMSPS.Mark
CALL 2
JUMP L841
LABEL L843
!     ELSIF sym = S.comma THEN S.Get(sym); ArrayType(typ.base)
LINE 670
LDGW OMSPP.sym
CONST 40
JNEQ L849
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW -48
NCHECK 670
CONST 28
OFFSET
GLOBAL OMSPP.ArrayType
CALL 1
JUMP L841
LABEL L849
!     ELSE S.Mark("missing OF"); typ.base := B.intType
LINE 671
CONST 11
GLOBAL OMSPP.%72
GLOBAL OMSPS.Mark
CALL 2
LDGW OMSPB.intType
LDLW -48
NCHECK 671
STNW 28
LABEL L841
!     typ.size := (len * typ.base.size + (G.WordSize - 1)) DIV G.WordSize * G.WordSize;
LINE 673
LDLW -52
LDLW -48
NCHECK 673
LDNW 28
NCHECK 673
LDNW 32
TIMES
INC
CONST 2
DIV
CONST 2
TIMES
LDLW -48
NCHECK 673
STNW 32
!     typ.form := B.Array; typ.len := len; type := typ
LINE 674
CONST 12
LDLW -48
NCHECK 674
STOREW
LDLW -52
LDLW -48
NCHECK 674
STNW 16
LDLW -48
LDLW 12
STOREW
RETURN
END

PROC OMSPP.RecordType 40 5 0x0011fc01
!   PROCEDURE RecordType(VAR type: B.Type);
LINE 677
!   BEGIN NEW(typ); typ.form := B.NoTyp; typ.base := NIL; typ.mno := -level; typ.nofpar := 0; offset := 0; bot := NIL;
LINE 681
CONST 44
GLOBAL OMSPB.TypeDesc
GLOBAL NEW
CALLW 2
STLW -24
CONST 9
LDLW -24
NCHECK 681
STOREW
CONST 0
LDLW -24
NCHECK 681
STNW 28
LDGW OMSPP.level
UMINUS
LDLW -24
NCHECK 681
STNW 8
CONST 0
LDLW -24
NCHECK 681
STNW 12
CONST 0
STLW -32
CONST 0
STLW -16
!     IF sym = S.lparen THEN
LINE 682
LDGW OMSPP.sym
CONST 28
JNEQ L852
!       S.Get(sym); (*record extension*)
LINE 683
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!       IF level # 0 THEN S.Mark("extension of local types not implemented") END ;
LINE 684
LDGW OMSPP.level
JEQZ L855
CONST 41
GLOBAL OMSPP.%73
GLOBAL OMSPS.Mark
CALL 2
LABEL L855
!       IF sym = S.ident THEN
LINE 685
LDGW OMSPP.sym
CONST 31
JNEQ L858
!         qualident(base);
LINE 686
LOCAL -20
GLOBAL OMSPP.qualident
CALL 1
!         IF base.class = B.Typ THEN
LINE 687
LDLW -20
NCHECK 687
LOADC
CONST 5
JNEQ L861
!           IF base.type.form = B.Record THEN typ.base := base.type
LINE 688
LDLW -20
NCHECK 688
LDNW 20
NCHECK 688
LOADW
CONST 13
JNEQ L864
LDLW -20
NCHECK 688
LDNW 20
LDLW -24
NCHECK 688
STNW 28
JUMP L862
LABEL L864
!           ELSE typ.base := B.intType; S.Mark("invalid extension")
LINE 689
LDGW OMSPB.intType
LDLW -24
NCHECK 689
STNW 28
CONST 18
GLOBAL OMSPP.%74
GLOBAL OMSPS.Mark
CALL 2
LABEL L862
!           typ.nofpar := typ.base.nofpar + 1; (*"nofpar" here abused for extension level*)
LINE 691
LDLW -24
NCHECK 691
LDNW 28
NCHECK 691
LDNW 12
INC
LDLW -24
NCHECK 691
STNW 12
!           bot := typ.base.dsc; offset := typ.base.size
LINE 692
LDLW -24
NCHECK 692
LDNW 28
NCHECK 692
LDNW 20
STLW -16
LDLW -24
NCHECK 692
LDNW 28
NCHECK 692
LDNW 32
STLW -32
JUMP L856
LABEL L861
!         ELSE S.Mark("type expected")
LINE 693
CONST 14
GLOBAL OMSPP.%75
GLOBAL OMSPS.Mark
CALL 2
JUMP L856
LABEL L858
!       ELSE S.Mark("ident expected")
LINE 695
CONST 15
GLOBAL OMSPP.%67
GLOBAL OMSPS.Mark
CALL 2
LABEL L856
!       Check(S.rparen, "no )")
LINE 697
CONST 5
GLOBAL OMSPP.%16
CONST 44
GLOBAL OMSPP.Check
CALL 3
LABEL L852
!     WHILE sym = S.ident DO  (*fields*)
LINE 699
LDGW OMSPP.sym
CONST 31
JNEQ L867
!       n := 0; obj := bot;
LINE 700
CONST 0
STLW -40
LDLW -16
STLW -4
LABEL L868
!       WHILE sym = S.ident DO
LINE 701
LDGW OMSPP.sym
CONST 31
JNEQ L870
!         obj0 := obj;
LINE 702
LDLW -4
STLW -8
LABEL L871
!         WHILE (obj0 # NIL) & (obj0.name # S.id) DO obj0 := obj0.next END ;
LINE 703
LDLW -8
JEQZ L873
CONST 32
GLOBAL OMSPS.id
LDLW -8
NCHECK 703
CONST 24
OFFSET
CONST 32
SWAP
GLOBAL COMPARE
CALLW 4
JEQZ L873
LDLW -8
NCHECK 703
LDNW 12
STLW -8
JUMP L871
LABEL L873
!         IF obj0 # NIL THEN S.Mark("mult def") END ;
LINE 704
LDLW -8
JEQZ L877
CONST 9
GLOBAL OMSPP.%76
GLOBAL OMSPS.Mark
CALL 2
LABEL L877
!         NEW(new); S.CopyId(new.name); new.class := B.Fld; new.next := obj; obj := new; INC(n);
LINE 705
CONST 60
GLOBAL OMSPB.ObjDesc
GLOBAL NEW
CALLW 2
STLW -12
LDLW -12
NCHECK 705
CONST 24
OFFSET
GLOBAL OMSPS.CopyId
CALL 1
CONST 4
LDLW -12
NCHECK 705
STOREC
LDLW -4
LDLW -12
NCHECK 705
STNW 12
LDLW -12
STLW -4
INCL -40
!         S.Get(sym); CheckExport(new.expo);
LINE 706
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW -12
NCHECK 706
CONST 3
OFFSET
GLOBAL OMSPP.CheckExport
CALL 1
!         IF (sym # S.comma) & (sym # S.colon) THEN S.Mark("comma expected")
LINE 707
LDGW OMSPP.sym
CONST 40
JEQ L880
LDGW OMSPP.sym
CONST 41
JEQ L880
CONST 15
GLOBAL OMSPP.%77
GLOBAL OMSPS.Mark
CALL 2
JUMP L868
LABEL L880
!         ELSIF sym = S.comma THEN S.Get(sym)
LINE 708
LDGW OMSPP.sym
CONST 40
JNEQ L868
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
JUMP L868
LABEL L870
!       Check(S.colon, "colon expected"); Type(tp);
LINE 711
CONST 15
GLOBAL OMSPP.%78
CONST 41
GLOBAL OMSPP.Check
CALL 3
LOCAL -28
LDGW OMSPP.Type
NCHECK 711
CALL 1
!       IF (tp.form = B.Array) & (tp.len < 0) THEN S.Mark("dyn array not allowed") END ;
LINE 712
LDLW -28
NCHECK 712
LOADW
CONST 12
JNEQ L886
LDLW -28
NCHECK 712
LDNW 16
JGEQZ L886
CONST 22
GLOBAL OMSPP.%71
GLOBAL OMSPS.Mark
CALL 2
LABEL L886
!       IF tp.size > 1 THEN offset := (offset + (G.WordSize-1)) DIV G.WordSize * G.WordSize END ;
LINE 713
LDLW -28
NCHECK 713
LDNW 32
CONST 1
JLEQ L890
LDLW -32
INC
CONST 2
DIV
CONST 2
TIMES
STLW -32
LABEL L890
!       offset := offset + n * tp.size; off := offset; obj0 := obj;
LINE 714
LDLW -32
LDLW -40
LDLW -28
NCHECK 714
LDNW 32
TIMES
PLUS
STLW -32
LDLW -32
STLW -36
LDLW -4
STLW -8
LABEL L891
!       WHILE obj0 # bot DO obj0.type := tp; obj0.lev := 0; off := off - tp.size; obj0.val := off; obj0 := obj0.next END ;
LINE 715
LDLW -8
LDLW -16
JEQ L893
LDLW -28
LDLW -8
NCHECK 715
STNW 20
CONST 0
LDLW -8
NCHECK 715
STNW 8
LDLW -36
LDLW -28
NCHECK 715
LDNW 32
MINUS
STLW -36
LDLW -36
LDLW -8
NCHECK 715
STNW 56
LDLW -8
NCHECK 715
LDNW 12
STLW -8
JUMP L891
LABEL L893
!       bot := obj;
LINE 716
LDLW -4
STLW -16
!       IF sym = S.semicolon THEN S.Get(sym) ELSIF sym # S.end THEN S.Mark(" ; or END") END
LINE 717
LDGW OMSPP.sym
CONST 52
JNEQ L896
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
JUMP L852
LABEL L896
LDGW OMSPP.sym
CONST 53
JEQ L852
CONST 10
GLOBAL OMSPP.%79
GLOBAL OMSPS.Mark
CALL 2
JUMP L852
LABEL L867
!     typ.form := B.Record; typ.dsc := bot;
LINE 719
CONST 13
LDLW -24
NCHECK 719
STOREW
LDLW -16
LDLW -24
NCHECK 719
STNW 20
!     typ.size := (offset + (G.WordSize - 1)) DIV G.WordSize * G.WordSize;
LINE 720
LDLW -32
INC
CONST 2
DIV
CONST 2
TIMES
LDLW -24
NCHECK 720
STNW 32
!     type := typ
LINE 721
LDLW -24
LDLW 12
STOREW
RETURN
END

PROC OMSPP.FPSection 32 3 0x0071c001
!   PROCEDURE FPSection(VAR adr: INTEGER; VAR nofpar: INTEGER; VAR inreg: BOOLEAN);
LINE 724
!   BEGIN inreg := FALSE;
LINE 727
CONST 0
LDLW 20
STOREC
!     IF sym = S.var THEN S.Get(sym); cl := B.Par ELSE cl := B.Var END ;
LINE 728
LDGW OMSPP.sym
CONST 65
JNEQ L901
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
CONST 3
STLW -28
JUMP L899
LABEL L901
CONST 2
STLW -28
LABEL L899
!     IdentList(cl, first); FormalType(tp, 0); rdo := FALSE;
LINE 729
LOCAL -8
LDLW -28
GLOBAL OMSPP.IdentList
CALL 2
CONST 0
LOCAL -12
LDGW OMSPP.FormalType
NCHECK 729
CALL 2
CONST 0
STLC -29
!     IF sym = S.times THEN inreg := TRUE; G.SetAllocationMode(G.Register); S.Get(sym) END;
LINE 730
LDGW OMSPP.sym
CONST 1
JNEQ L904
CONST 1
LDLW 20
STOREC
CONST 1
ALIGNC
GLOBAL OMSPG.SetAllocationMode
CALL 1
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LABEL L904
!     IF (cl = B.Var) & (tp.form IN {B.Array, B.Record}) THEN cl := B.Par; rdo := TRUE END ;
LINE 731
LDLW -28
CONST 2
JNEQ L907
CONST 1
LDLW -12
NCHECK 731
LOADW
CONST 32
BOUND 731
LSL
CONST 12288
BITAND
JEQZ L907
CONST 3
STLW -28
CONST 1
STLC -29
LABEL L907
!     IF (tp.form = B.Array) & (tp.len < 0) OR (tp.form = B.Record) THEN
LINE 732
LDLW -12
NCHECK 732
LOADW
CONST 12
JNEQ L912
LDLW -12
NCHECK 732
LDNW 16
JLTZ L910
LABEL L912
LDLW -12
NCHECK 732
LOADW
CONST 13
JNEQ L911
LABEL L910
!       parsize := 2*G.WordSize  (*open array or record, needs second word for length or type tag*)
LINE 733
CONST 4
STLW -16
JUMP L909
LABEL L911
!     ELSE parsize := G.WordSize
LINE 734
CONST 2
STLW -16
LABEL L909
!     obj := first;
LINE 736
LDLW -8
STLW -4
LABEL L914
!     WHILE obj # NIL DO
LINE 737
LDLW -4
JEQZ L916
!       INC(nofpar); obj.class := cl; obj.type := tp; obj.rdo := rdo; obj.lev := level; 
LINE 738
LDLW 16
DUP 0
LOADW
INC
SWAP
STOREW
LDLW -28
CONVNC
LDLW -4
NCHECK 738
STOREC
LDLW -12
LDLW -4
NCHECK 738
STNW 20
LDLC -29
LDLW -4
NCHECK 738
CONST 5
STIC
LDGW OMSPP.level
LDLW -4
NCHECK 738
STNW 8
!       IF inreg THEN obj.register := G.AllocR(); nbregs := parsize DIV G.WordSize;
LINE 739
LDLW 20
LOADC
JEQZ L919
GLOBAL OMSPG.AllocR
CALLW 0
CONVNC
LDLW -4
NCHECK 739
CONST 2
STIC
LDLW -16
CONST 2
DIV
STLW -24
LABEL L920
!         WHILE nbregs > 1 DO dummy := G.AllocR(); DEC(nbregs) END
LINE 740
LDLW -24
CONST 1
JLEQ L917
GLOBAL OMSPG.AllocR
CALLW 0
STLW -20
DECL -24
JUMP L920
LABEL L919
!       ELSE obj.register := 0FFH; INC(adr, parsize); obj.val := G.WordSize - adr
LINE 741
CONST 255
LDLW -4
NCHECK 741
CONST 2
STIC
LDLW 12
DUP 0
LOADW
LDLW -16
PLUS
SWAP
STOREW
CONST 2
LDLW 12
LOADW
MINUS
LDLW -4
NCHECK 741
STNW 56
LABEL L917
!       obj := obj.next
LINE 743
LDLW -4
NCHECK 743
LDNW 12
STLW -4
JUMP L914
LABEL L916
!     IF adr >= 26 THEN S.Mark("too many parameters") END
LINE 745
LDLW 12
LOADW
CONST 26
JLT L925
CONST 20
GLOBAL OMSPP.%80
GLOBAL OMSPS.Mark
CALL 2
LABEL L925
RETURN
END

PROC OMSPP.InsertResultRegister 60 3 0x001040c5
!   PROCEDURE InsertResultRegister(VAR type: B.Type);
LINE 748
!     IF type.leaf & (type.base.form # B.NoTyp) THEN (*make room for the returned value*)
LINE 751
LDLW 12
LOADW
NCHECK 751
CONST 36
LDIC
JEQZ L928
LDLW 12
LOADW
NCHECK 751
LDNW 28
NCHECK 751
LOADW
CONST 9
JEQ L928
!       G.SetRIU({}); G.resultRegister(x); L := G.AllocR(); ASSERT(L = x.reg); (*reserve result register*)
LINE 752
CONST 0
GLOBAL OMSPG.SetRIU
CALL 1
GLOBAL OMSPG.Item
LOCAL -56
GLOBAL OMSPG.resultRegister
CALL 2
GLOBAL OMSPG.AllocR
CALLW 0
STLW -4
LDLW -4
LDLC -56
JEQ L930
CONST 0
CONST 752
GLOBAL EASSERT
CALL 2
LABEL L930
!         loc := type.dsc; L := 0;
LINE 753
LDLW 12
LOADW
NCHECK 753
LDNW 20
STLW -12
CONST 0
STLW -4
LABEL L931
!         WHILE (loc # NIL) & (L < type.nofpar) DO (*allocate registers to parameters, avoiding the result register*)
LINE 754
LDLW -12
JEQZ L933
LDLW -4
LDLW 12
LOADW
NCHECK 754
LDNW 12
JGEQ L933
!           IF (loc.class IN {B.Var, B.Par}) & (loc.register # 0FFH) THEN loc.register := G.AllocR(); (*allocate next free register to param or variable*)
LINE 755
CONST 1
LDLW -12
NCHECK 755
LOADC
CONST 32
BOUND 755
LSL
CONST 12
BITAND
JEQZ L936
LDLW -12
NCHECK 755
CONST 2
LDIC
CONST 255
JEQ L936
GLOBAL OMSPG.AllocR
CALLW 0
CONVNC
LDLW -12
NCHECK 755
CONST 2
STIC
!             tp := loc.type; IF (tp.form = B.Array) & (tp.len < 0) OR (tp.form = B.Record) THEN dummy := G.AllocR() END; (*allocate extra register*)
LINE 756
LDLW -12
NCHECK 756
LDNW 20
STLW -60
LDLW -60
NCHECK 756
LOADW
CONST 12
JNEQ L940
LDLW -60
NCHECK 756
LDNW 16
JLTZ L938
LABEL L940
LDLW -60
NCHECK 756
LOADW
CONST 13
JNEQ L936
LABEL L938
GLOBAL OMSPG.AllocR
CALLW 0
STLW -8
LABEL L936
!           loc := loc.next; INC(L)
LINE 758
LDLW -12
NCHECK 758
LDNW 12
STLW -12
INCL -4
JUMP L931
LABEL L933
!         END; G.freeR(x.reg); (*free sesult register*)
LINE 759
LDLC -56
GLOBAL OMSPG.freeR
CALL 1
LABEL L944
!         WHILE loc # NIL DO (*allocate registers to local variables, including the result register*)
LINE 760
LDLW -12
JEQZ L928
!           IF (loc.class IN {B.Var, B.Par}) & (loc.register # 0FFH) THEN loc.register := G.AllocR() END; (*allocate next free register to param or variable*)
LINE 761
CONST 1
LDLW -12
NCHECK 761
LOADC
CONST 32
BOUND 761
LSL
CONST 12
BITAND
JEQZ L949
LDLW -12
NCHECK 761
CONST 2
LDIC
CONST 255
JEQ L949
GLOBAL OMSPG.AllocR
CALLW 0
CONVNC
LDLW -12
NCHECK 761
CONST 2
STIC
LABEL L949
!           loc := loc.next
LINE 762
LDLW -12
NCHECK 762
LDNW 12
STLW -12
JUMP L944
LABEL L928
RETURN
END

PROC OMSPP.ProcedureType 60 5 0x00310061
!   PROCEDURE ProcedureType(ptype: B.Type; VAR parblksize: INTEGER);
LINE 767
!   BEGIN ptype.base := B.noType; size := parblksize; nofpar := 0; ptype.dsc := NIL; leaf := FALSE;
LINE 769
LDGW OMSPB.noType
LDLW 12
NCHECK 769
STNW 28
LDLW 16
LOADW
STLW -8
CONST 0
STLW -12
CONST 0
LDLW 12
NCHECK 769
STNW 20
CONST 0
STLC -13
!     IF sym = S.lparen THEN
LINE 770
LDGW OMSPP.sym
CONST 28
JNEQ L954
!       S.Get(sym);
LINE 771
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!       IF sym = S.rparen THEN S.Get(sym)
LINE 772
LDGW OMSPP.sym
CONST 44
JNEQ L966
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
JUMP L955
LABEL L966
!       ELSE FPSection(size, nofpar, inreg); IF inreg THEN leaf := TRUE END;
LINE 773
LOCAL -14
LOCAL -12
LOCAL -8
GLOBAL OMSPP.FPSection
CALL 3
LDLC -14
JEQZ L958
CONST 1
STLC -13
LABEL L958
!         WHILE sym = S.semicolon DO S.Get(sym); FPSection(size, nofpar, inreg); IF inreg THEN leaf := TRUE END END ;
LINE 774
LDGW OMSPP.sym
CONST 52
JNEQ L961
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LOCAL -14
LOCAL -12
LOCAL -8
GLOBAL OMSPP.FPSection
CALL 3
LDLC -14
JEQZ L958
CONST 1
STLC -13
JUMP L958
LABEL L961
!         Check(S.rparen, "no )")
LINE 775
CONST 5
GLOBAL OMSPP.%16
CONST 44
GLOBAL OMSPP.Check
CALL 3
LABEL L955
!       IF sym = S.colon THEN  (*function*)
LINE 777
LDGW OMSPP.sym
CONST 41
JNEQ L954
!         S.Get(sym);
LINE 778
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!         IF sym = S.ident THEN
LINE 779
LDGW OMSPP.sym
CONST 31
JNEQ L972
!           qualident(obj); ptype.base := obj.type;
LINE 780
LOCAL -4
GLOBAL OMSPP.qualident
CALL 1
LDLW -4
NCHECK 780
LDNW 20
LDLW 12
NCHECK 780
STNW 28
!           IF ~((obj.class = B.Typ) & (obj.type.form IN {B.Byte .. B.Pointer, B.Proc})) THEN
LINE 781
LDLW -4
NCHECK 781
LOADC
CONST 5
JNEQ L974
CONST 1
LDLW -4
NCHECK 781
LDNW 20
NCHECK 781
LOADW
CONST 32
BOUND 781
LSL
CONST 1278
BITAND
JNEQZ L970
LABEL L974
!             S.Mark("illegal function type")
LINE 782
CONST 22
GLOBAL OMSPP.%81
GLOBAL OMSPS.Mark
CALL 2
JUMP L970
LABEL L972
!         ELSE S.Mark("type identifier expected")
LINE 784
CONST 25
GLOBAL OMSPP.%82
GLOBAL OMSPS.Mark
CALL 2
LABEL L970
!         G.resultRegister(x); INCL(ptype.ur, x.reg) (*include return register in the list of used registers*)
LINE 786
GLOBAL OMSPG.Item
LOCAL -60
GLOBAL OMSPG.resultRegister
CALL 2
LDLW 12
NCHECK 786
CONST 40
OFFSET
DUP 0
LOADW
CONST 1
LDLC -60
CONST 32
BOUND 786
LSL
BITOR
SWAP
STOREW
LABEL L954
!     ptype.nofpar := nofpar; ptype.leaf := leaf; ptype.size := G.WordSize; isLeaf := leaf; parblksize := size
LINE 789
LDLW -12
LDLW 12
NCHECK 789
STNW 12
LDLC -13
LDLW 12
NCHECK 789
CONST 36
STIC
CONST 2
LDLW 12
NCHECK 789
STNW 32
LDLC -13
STGC OMSPP.isLeaf
LDLW -8
LDLW 16
STOREW
RETURN
END

PROC OMSPP.FormalType0 12 4 0x00114001
!   PROCEDURE FormalType0(VAR typ: B.Type; dim: INTEGER);
LINE 792
!     IF sym = S.ident THEN
LINE 795
LDGW OMSPP.sym
CONST 31
JNEQ L979
!       qualident(obj);
LINE 796
LOCAL -4
GLOBAL OMSPP.qualident
CALL 1
!       IF obj.class = B.Typ THEN typ := obj.type ELSE S.Mark("not a type"); typ := B.intType END
LINE 797
LDLW -4
NCHECK 797
LOADC
CONST 5
JNEQ L982
LDLW -4
NCHECK 797
LDNW 20
LDLW 12
STOREW
RETURN
LABEL L982
CONST 11
GLOBAL OMSPP.%50
GLOBAL OMSPS.Mark
CALL 2
LDGW OMSPB.intType
LDLW 12
STOREW
RETURN
LABEL L979
!     ELSIF sym = S.array THEN
LINE 798
LDGW OMSPP.sym
CONST 60
JNEQ L984
!       S.Get(sym); Check(S.of, "OF ?");
LINE 799
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
CONST 5
GLOBAL OMSPP.%83
CONST 48
GLOBAL OMSPP.Check
CALL 3
!       IF dim >= 1 THEN S.Mark("multi-dimensional open arrays not implemented") END ;
LINE 800
LDLW 16
CONST 1
JLT L987
CONST 46
GLOBAL OMSPP.%84
GLOBAL OMSPS.Mark
CALL 2
LABEL L987
!       NEW(typ); typ.form := B.Array; typ.len := -1; typ.size := 2*G.WordSize; 
LINE 801
CONST 44
GLOBAL OMSPB.TypeDesc
GLOBAL NEW
CALLW 2
LDLW 12
STOREW
CONST 12
LDLW 12
LOADW
NCHECK 801
STOREW
CONST -1
LDLW 12
LOADW
NCHECK 801
STNW 16
CONST 4
LDLW 12
LOADW
NCHECK 801
STNW 32
!       FormalType(typ.base, dim+1)
LINE 802
LDLW 16
INC
LDLW 12
LOADW
NCHECK 802
CONST 28
OFFSET
LDGW OMSPP.FormalType
NCHECK 802
CALL 2
RETURN
LABEL L984
!     ELSIF sym = S.procedure THEN
LINE 803
LDGW OMSPP.sym
CONST 66
JNEQ L989
!       S.Get(sym); B.OpenScope;
LINE 804
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPB.OpenScope
CALL 0
!       NEW(t); t.form := B.Proc; dmy := 0; ProcedureType(t, dmy);
LINE 805
CONST 44
GLOBAL OMSPB.TypeDesc
GLOBAL NEW
CALLW 2
STLW -12
CONST 10
LDLW -12
NCHECK 805
STOREW
CONST 0
STLW -8
LOCAL -8
LDLW -12
GLOBAL OMSPP.ProcedureType
CALL 2
!       t.dsc := B.topScope.next; InsertResultRegister(t); B.CloseScope;
LINE 806
LDGW OMSPB.topScope
NCHECK 806
LDNW 12
LDLW -12
NCHECK 806
STNW 20
LOCAL -12
GLOBAL OMSPP.InsertResultRegister
CALL 1
GLOBAL OMSPB.CloseScope
CALL 0
!       NEW(typ);  typ.form := B.Pointer; typ.size := G.WordSize; typ.base := t
LINE 807
CONST 44
GLOBAL OMSPB.TypeDesc
GLOBAL NEW
CALLW 2
LDLW 12
STOREW
CONST 7
LDLW 12
LOADW
NCHECK 807
STOREW
CONST 2
LDLW 12
LOADW
NCHECK 807
STNW 32
LDLW -12
LDLW 12
LOADW
NCHECK 807
STNW 28
RETURN
LABEL L989
!     ELSE S.Mark("identifier expected"); typ := B.noType
LINE 808
CONST 20
GLOBAL OMSPP.%2
GLOBAL OMSPS.Mark
CALL 2
LDGW OMSPB.noType
LDLW 12
STOREW
RETURN
END

PROC OMSPP.CheckRecLevel 0 3 0
!   PROCEDURE CheckRecLevel(lev: INTEGER);
LINE 812
!     IF lev # 0 THEN S.Mark("ptr base must be global") END
LINE 814
LDLW 12
JEQZ L992
CONST 24
GLOBAL OMSPP.%85
GLOBAL OMSPS.Mark
CALL 2
LABEL L992
RETURN
END

PROC OMSPP.Type0 60 4 0x0010c0c5
!   PROCEDURE Type0(VAR type: B.Type);
LINE 817
!   BEGIN type := B.intType; (*sync*)
LINE 819
LDGW OMSPB.intType
LDLW 12
STOREW
!     IF (sym # S.ident) & (sym < S.array) THEN S.Mark("not a type");
LINE 820
LDGW OMSPP.sym
CONST 31
JEQ L995
LDGW OMSPP.sym
CONST 60
JGEQ L995
CONST 11
GLOBAL OMSPP.%50
GLOBAL OMSPS.Mark
CALL 2
LABEL L996
!       REPEAT S.Get(sym) UNTIL (sym = S.ident) OR (sym >= S.array)
LINE 821
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDGW OMSPP.sym
CONST 31
JEQ L995
LDGW OMSPP.sym
CONST 60
JLT L996
LABEL L995
!     IF sym = S.ident THEN
LINE 823
LDGW OMSPP.sym
CONST 31
JNEQ L1002
!       qualident(obj);
LINE 824
LOCAL -8
GLOBAL OMSPP.qualident
CALL 1
!       IF obj.class = B.Typ THEN
LINE 825
LDLW -8
NCHECK 825
LOADC
CONST 5
JNEQ L1005
!         IF (obj.type # NIL) & (obj.type.form # B.NoTyp) THEN type := obj.type END
LINE 826
LDLW -8
NCHECK 826
LDNW 20
JEQZ L1000
LDLW -8
NCHECK 826
LDNW 20
NCHECK 826
LOADW
CONST 9
JEQ L1000
LDLW -8
NCHECK 826
LDNW 20
LDLW 12
STOREW
RETURN
LABEL L1005
!       ELSE S.Mark("not a type or undefined")
LINE 827
CONST 24
GLOBAL OMSPP.%86
GLOBAL OMSPS.Mark
CALL 2
RETURN
LABEL L1002
!     ELSIF sym = S.array THEN S.Get(sym); ArrayType(type)
LINE 829
LDGW OMSPP.sym
CONST 60
JNEQ L1011
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW 12
GLOBAL OMSPP.ArrayType
CALL 1
RETURN
LABEL L1011
!     ELSIF sym = S.record THEN
LINE 830
LDGW OMSPP.sym
CONST 61
JNEQ L1013
!       S.Get(sym); RecordType(type); Check(S.end, "no END")
LINE 831
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW 12
GLOBAL OMSPP.RecordType
CALL 1
CONST 7
GLOBAL OMSPP.%60
CONST 53
GLOBAL OMSPP.Check
CALL 3
RETURN
LABEL L1013
!     ELSIF sym = S.pointer THEN
LINE 832
LDGW OMSPP.sym
CONST 62
JNEQ L1015
!       S.Get(sym); Check(S.to, "no TO");
LINE 833
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
CONST 6
GLOBAL OMSPP.%63
CONST 50
GLOBAL OMSPP.Check
CALL 3
!       NEW(type);  type.form := B.Pointer; type.size := G.WordSize; type.base := B.intType;
LINE 834
CONST 44
GLOBAL OMSPB.TypeDesc
GLOBAL NEW
CALLW 2
LDLW 12
STOREW
CONST 7
LDLW 12
LOADW
NCHECK 834
STOREW
CONST 2
LDLW 12
LOADW
NCHECK 834
STNW 32
LDGW OMSPB.intType
LDLW 12
LOADW
NCHECK 834
STNW 28
!       IF sym = S.ident THEN
LINE 835
LDGW OMSPP.sym
CONST 31
JNEQ L1022
!         obj := B.thisObj();
LINE 836
GLOBAL OMSPB.thisObj
CALLW 0
STLW -8
!         IF obj # NIL THEN
LINE 837
LDLW -8
JEQZ L1025
!           IF (obj.class = B.Typ) & (obj.type.form IN {B.Record, B.NoTyp}) THEN
LINE 838
LDLW -8
NCHECK 838
LOADC
CONST 5
JNEQ L1028
CONST 1
LDLW -8
NCHECK 838
LDNW 20
NCHECK 838
LOADW
CONST 32
BOUND 838
LSL
CONST 8704
BITAND
JEQZ L1028
!             CheckRecLevel(obj.lev); type.base := obj.type
LINE 839
LDLW -8
NCHECK 839
LDNW 8
GLOBAL OMSPP.CheckRecLevel
CALL 1
LDLW -8
NCHECK 839
LDNW 20
LDLW 12
LOADW
NCHECK 839
STNW 28
JUMP L1023
LABEL L1028
!           ELSIF obj.class = B.Mod THEN S.Mark("external base type not implemented")
LINE 840
LDLW -8
NCHECK 840
LOADC
CONST 8
JNEQ L1031
CONST 35
GLOBAL OMSPP.%87
GLOBAL OMSPS.Mark
CALL 2
JUMP L1023
LABEL L1031
!           ELSE S.Mark("no valid base type")
LINE 841
CONST 19
GLOBAL OMSPP.%88
GLOBAL OMSPS.Mark
CALL 2
JUMP L1023
LABEL L1025
!         ELSE CheckRecLevel(level); (*enter into list of forward references to be fixed in Declarations*)
LINE 843
LDGW OMSPP.level
GLOBAL OMSPP.CheckRecLevel
CALL 1
!           NEW(ptbase); S.CopyId(ptbase.name); ptbase.type := type; ptbase.next := pbsList; pbsList := ptbase
LINE 844
CONST 40
GLOBAL OMSPP.PtrBaseDesc
GLOBAL NEW
CALLW 2
STLW -12
LDLW -12
NCHECK 844
GLOBAL OMSPS.CopyId
CALL 1
LDLW 12
LOADW
LDLW -12
NCHECK 844
STNW 32
LDGW OMSPP.pbsList
LDLW -12
NCHECK 844
STNW 36
LDLW -12
STGW OMSPP.pbsList
LABEL L1023
!         S.Get(sym)
LINE 846
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
RETURN
LABEL L1022
!       ELSE Type(type.base);
LINE 847
LDLW 12
LOADW
NCHECK 847
CONST 28
OFFSET
LDGW OMSPP.Type
NCHECK 847
CALL 1
!         IF (type.base.form # B.Record) OR (type.base.typobj = NIL) THEN S.Mark("must point to named record") END ;
LINE 848
LDLW 12
LOADW
NCHECK 848
LDNW 28
NCHECK 848
LOADW
CONST 13
JNEQ L1018
LDLW 12
LOADW
NCHECK 848
LDNW 28
NCHECK 848
LDNW 24
JNEQZ L1019
LABEL L1018
CONST 27
GLOBAL OMSPP.%89
GLOBAL OMSPS.Mark
CALL 2
LABEL L1019
!         CheckRecLevel(level)
LINE 849
LDGW OMSPP.level
GLOBAL OMSPP.CheckRecLevel
CALL 1
RETURN
LABEL L1015
!     ELSIF sym = S.procedure THEN
LINE 851
LDGW OMSPP.sym
CONST 66
JNEQ L1033
!       S.Get(sym); B.OpenScope;
LINE 852
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPB.OpenScope
CALL 0
!       NEW(t); t.form := B.Proc; dmy := 0;
LINE 853
CONST 44
GLOBAL OMSPB.TypeDesc
GLOBAL NEW
CALLW 2
STLW -60
CONST 10
LDLW -60
NCHECK 853
STOREW
CONST 0
STLW -4
!       t.ur := {4..15}; (*all non saved registers can be destroyed for dynamic procedures*)
LINE 854
CONST 65520
LDLW -60
NCHECK 854
STNW 40
!       IF sym = S.lbrace THEN S.Get(sym); set(sr); CheckConst(sr); Check(S.rbrace, "no }"); t.ur := t.ur - SYSTEM.VAL(SET, sr.a) END;
LINE 855
LDGW OMSPP.sym
CONST 30
JNEQ L1036
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -56
GLOBAL OMSPP.set
CALL 2
GLOBAL OMSPG.Item
LOCAL -56
GLOBAL OMSPP.CheckConst
CALL 2
CONST 5
GLOBAL OMSPP.%43
CONST 46
GLOBAL OMSPP.Check
CALL 3
LDLW -60
NCHECK 855
LDNW 40
LDLW -36
BITNOT
BITAND
LDLW -60
NCHECK 855
STNW 40
LABEL L1036
!       ProcedureType(t, dmy); t.dsc := B.topScope.next; InsertResultRegister(t); B.CloseScope;
LINE 856
LOCAL -4
LDLW -60
GLOBAL OMSPP.ProcedureType
CALL 2
LDGW OMSPB.topScope
NCHECK 856
LDNW 12
LDLW -60
NCHECK 856
STNW 20
LOCAL -60
GLOBAL OMSPP.InsertResultRegister
CALL 1
GLOBAL OMSPB.CloseScope
CALL 0
!       NEW(type);  type.form := B.Pointer; type.size := G.WordSize; type.base := t
LINE 857
CONST 44
GLOBAL OMSPB.TypeDesc
GLOBAL NEW
CALLW 2
LDLW 12
STOREW
CONST 7
LDLW 12
LOADW
NCHECK 857
STOREW
CONST 2
LDLW 12
LOADW
NCHECK 857
STNW 32
LDLW -60
LDLW 12
LOADW
NCHECK 857
STNW 28
RETURN
LABEL L1033
!     ELSE S.Mark("illegal type")
LINE 858
CONST 13
GLOBAL OMSPP.%90
GLOBAL OMSPS.Mark
CALL 2
LABEL L1000
RETURN
END

PROC OMSPP.containsPointer 8 2 0x00110001
!   PROCEDURE containsPointer(type: B.Type): BOOLEAN;
LINE 862
!   BEGIN res := FALSE;
LINE 864
CONST 0
STLC -5
!     IF type.form = B.Pointer THEN res := TRUE
LINE 865
LDLW 12
NCHECK 865
LOADW
CONST 7
JNEQ L1039
CONST 1
STLC -5
JUMP L1050
LABEL L1039
!     ELSIF type.form = B.Record THEN obj := type.dsc;
LINE 866
LDLW 12
NCHECK 866
LOADW
CONST 13
JNEQ L1041
LDLW 12
NCHECK 866
LDNW 20
STLW -4
LABEL L1042
!       WHILE ~res & (obj # NIL) DO 
LINE 867
LDLC -5
JNEQZ L1050
LDLW -4
JEQZ L1050
!         IF obj.type.form = B.NilTyp (*hidden pointer*) THEN res := TRUE
LINE 868
LDLW -4
NCHECK 868
LDNW 20
NCHECK 868
LOADW
CONST 8
JNEQ L1047
CONST 1
STLC -5
JUMP L1045
LABEL L1047
!         ELSE res := containsPointer(obj.type)
LINE 869
LDLW -4
NCHECK 869
LDNW 20
GLOBAL OMSPP.containsPointer
CALLW 1
STLC -5
LABEL L1045
!         obj := obj.next
LINE 871
LDLW -4
NCHECK 871
LDNW 12
STLW -4
JUMP L1042
LABEL L1041
!     ELSIF type.form = B.Array THEN res := containsPointer(type.base)
LINE 873
LDLW 12
NCHECK 873
LOADW
CONST 12
JNEQ L1050
LDLW 12
NCHECK 873
LDNW 28
GLOBAL OMSPP.containsPointer
CALLW 1
STLC -5
LABEL L1050
!     RETURN res
LINE 875
LDLC -5
RETURN
END

PROC OMSPP.Declarations 108 5 0x0031818d
!   PROCEDURE Declarations(VAR varsize: INTEGER; VAR haveinregs: BOOLEAN);
LINE 878
!   BEGIN (*sync*) pbsList := NIL; haveinregs := FALSE;
LINE 883
CONST 0
STGW OMSPP.pbsList
CONST 0
LDLW 16
STOREC
!     IF (sym < S.const) & (sym # S.end) & (sym # S.return) THEN S.Mark("declaration?");
LINE 884
LDGW OMSPP.sym
CONST 63
JGEQ L1053
LDGW OMSPP.sym
CONST 53
JEQ L1053
LDGW OMSPP.sym
CONST 58
JEQ L1053
CONST 13
GLOBAL OMSPP.%91
GLOBAL OMSPS.Mark
CALL 2
LABEL L1054
!       REPEAT S.Get(sym) UNTIL (sym >= S.const) OR (sym = S.end) OR (sym = S.return)
LINE 885
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDGW OMSPP.sym
CONST 63
JGEQ L1053
LDGW OMSPP.sym
CONST 53
JEQ L1053
LDGW OMSPP.sym
CONST 58
JNEQ L1054
LABEL L1053
!     IF sym = S.const THEN
LINE 887
LDGW OMSPP.sym
CONST 63
JNEQ L1062
!       S.Get(sym);
LINE 888
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LABEL L1063
!       WHILE sym = S.ident DO
LINE 889
LDGW OMSPP.sym
CONST 31
JNEQ L1062
!         S.CopyId(id); S.Get(sym); CheckExport(expo);
LINE 890
LOCAL -98
GLOBAL OMSPS.CopyId
CALL 1
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LOCAL -61
GLOBAL OMSPP.CheckExport
CALL 1
!         IF sym = S.eql THEN S.Get(sym) ELSE S.Mark("= ?") END;
LINE 891
LDGW OMSPP.sym
CONST 9
JNEQ L1068
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
JUMP L1066
LABEL L1068
CONST 4
GLOBAL OMSPP.%92
GLOBAL OMSPS.Mark
CALL 2
LABEL L1066
!         expression(x);
LINE 892
GLOBAL OMSPG.Item
LOCAL -52
LDGW OMSPP.expression
NCHECK 892
CALL 2
!         IF (x.type.form = B.String) & (G.Length(x) = 2) THEN G.StrToChar(x) END ;
LINE 893
LDLW -40
NCHECK 893
LOADW
CONST 11
JNEQ L1071
LOCAL -52
GLOBAL OMSPG.Length
CALLW 1
CONST 2
JNEQ L1071
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.StrToChar
CALL 2
LABEL L1071
!         B.NewObj(obj, id, x.mode); obj.expo := expo; obj.type := x.type; obj.lev := x.c;
LINE 894
LDLW -44
LOCAL -98
LOCAL -4
GLOBAL OMSPB.NewObj
CALL 3
LDLC -61
LDLW -4
NCHECK 894
CONST 3
STIC
LDLW -40
LDLW -4
NCHECK 894
STNW 20
LDLW -24
LDLW -4
NCHECK 894
STNW 8
!         obj.val := x.a; obj.rdo := TRUE;
LINE 895
LDLW -32
LDLW -4
NCHECK 895
STNW 56
CONST 1
LDLW -4
NCHECK 895
CONST 5
STIC
!         IF (x.mode = B.StoredConst) & (x.type.form = B.String) THEN ASSERT(x.a < 10000H);
LINE 896
LDLW -44
CONST 9
JNEQ L1075
LDLW -40
NCHECK 896
LOADW
CONST 11
JNEQ L1075
LDLW -32
CONST 65536
JLT L1077
CONST 0
CONST 896
GLOBAL EASSERT
CALL 2
LABEL L1077
!           IF obj.expo THEN obj.exno := exno; INC(exno) END;
LINE 897
LDLW -4
NCHECK 897
CONST 3
LDIC
JEQZ L1080
LDGW OMSPP.exno
CONVNC
LDLW -4
NCHECK 897
CONST 1
STIC
LDGW OMSPP.exno
INC
STGW OMSPP.exno
LABEL L1080
!           INC(obj.val, G.Length(x)*10000H); (*for string constants, encode address and length in obj.val*)
LINE 898
LDLW -4
NCHECK 898
CONST 56
OFFSET
DUP 0
LOADW
LOCAL -52
GLOBAL OMSPG.Length
STKMAP 0x00000009
CALLW 1
CONST 65536
TIMES
PLUS
SWAP
STOREW
JUMP L1083
LABEL L1075
!         ELSIF (x.mode # B.Const) THEN S.Mark("expression not constant"); obj.type := B.intType
LINE 899
LDLW -44
CONST 1
JEQ L1083
CONST 24
GLOBAL OMSPP.%93
GLOBAL OMSPS.Mark
CALL 2
LDGW OMSPB.intType
LDLW -4
NCHECK 899
STNW 20
LABEL L1083
!         Check(S.semicolon, "; missing")
LINE 901
CONST 10
GLOBAL OMSPP.%94
CONST 52
GLOBAL OMSPP.Check
CALL 3
JUMP L1063
LABEL L1062
!     IF sym = S.type THEN
LINE 904
LDGW OMSPP.sym
CONST 64
JNEQ L1086
!       S.Get(sym);
LINE 905
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LABEL L1087
!       WHILE sym = S.ident DO
LINE 906
LDGW OMSPP.sym
CONST 31
JNEQ L1086
!         S.CopyId(id); S.Get(sym); CheckExport(expo);
LINE 907
LOCAL -98
GLOBAL OMSPS.CopyId
CALL 1
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LOCAL -61
GLOBAL OMSPP.CheckExport
CALL 1
!         IF sym = S.eql THEN S.Get(sym) ELSE S.Mark("=?") END ;
LINE 908
LDGW OMSPP.sym
CONST 9
JNEQ L1092
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
JUMP L1090
LABEL L1092
CONST 3
GLOBAL OMSPP.%95
GLOBAL OMSPS.Mark
CALL 2
LABEL L1090
!         Type(tp);
LINE 909
LOCAL -56
LDGW OMSPP.Type
NCHECK 909
CALL 1
!         B.NewObj(obj, id, B.Typ); obj.type := tp; obj.expo := expo; obj.lev := level;
LINE 910
CONST 5
LOCAL -98
LOCAL -4
GLOBAL OMSPB.NewObj
CALL 3
LDLW -56
LDLW -4
NCHECK 910
STNW 20
LDLC -61
LDLW -4
NCHECK 910
CONST 3
STIC
LDGW OMSPP.level
LDLW -4
NCHECK 910
STNW 8
!         IF tp.typobj = NIL THEN tp.typobj := obj END ;
LINE 911
LDLW -56
NCHECK 911
LDNW 24
JNEQZ L1095
LDLW -4
LDLW -56
NCHECK 911
STNW 24
LABEL L1095
!         IF expo & (obj.type.form = B.Record) THEN obj.exno := exno; INC(exno) ELSE obj.exno := 0 END ;
LINE 912
LDLC -61
JEQZ L1098
LDLW -4
NCHECK 912
LDNW 20
NCHECK 912
LOADW
CONST 13
JNEQ L1098
LDGW OMSPP.exno
CONVNC
LDLW -4
NCHECK 912
CONST 1
STIC
LDGW OMSPP.exno
INC
STGW OMSPP.exno
JUMP L1096
LABEL L1098
CONST 0
LDLW -4
NCHECK 912
CONST 1
STIC
LABEL L1096
!         IF tp.form = B.Record THEN
LINE 913
LDLW -56
NCHECK 913
LOADW
CONST 13
JNEQ L1102
!           ptbase := pbsList;  (*check whether this is base of a pointer type; search and fixup*)
LINE 914
LDGW OMSPP.pbsList
STLW -60
LABEL L1103
!           WHILE ptbase # NIL DO
LINE 915
LDLW -60
JEQZ L1105
!             IF obj.name = ptbase.name THEN ptbase.type.base := obj.type END ;
LINE 916
CONST 32
LDLW -60
NCHECK 916
LDLW -4
NCHECK 916
CONST 24
OFFSET
CONST 32
SWAP
GLOBAL COMPARE
CALLW 4
JNEQZ L1108
LDLW -4
NCHECK 916
LDNW 20
LDLW -60
NCHECK 916
LDNW 32
NCHECK 916
STNW 28
LABEL L1108
!             ptbase := ptbase.next
LINE 917
LDLW -60
NCHECK 917
LDNW 36
STLW -60
JUMP L1103
LABEL L1105
!           IF level = 0 THEN G.BuildTD(tp) END    (*type descriptor; len used as its address*)
LINE 919
LDGW OMSPP.level
JNEQZ L1102
LDLW -56
GLOBAL OMSPG.BuildTD
CALL 1
LABEL L1102
!         Check(S.semicolon, "; missing")
LINE 921
CONST 10
GLOBAL OMSPP.%94
CONST 52
GLOBAL OMSPP.Check
CALL 3
JUMP L1087
LABEL L1086
!     IF sym = S.var THEN
LINE 924
LDGW OMSPP.sym
CONST 65
JNEQ L1114
!       S.Get(sym);
LINE 925
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LABEL L1115
!       WHILE sym = S.ident DO inreg := FALSE; onetimeinit := FALSE;
LINE 926
LDGW OMSPP.sym
CONST 31
JNEQ L1114
CONST 0
STLC -65
CONST 0
STLC -66
!         IdentList(B.Var, first); Type(tp);
LINE 927
LOCAL -8
CONST 2
GLOBAL OMSPP.IdentList
CALL 2
LOCAL -56
LDGW OMSPP.Type
NCHECK 927
CALL 1
!         IF sym = S.times THEN
LINE 928
LDGW OMSPP.sym
CONST 1
JNEQ L1120
!           IF level # 0 THEN haveinregs := TRUE; inreg := TRUE; G.SetAllocationMode(G.Register)
LINE 929
LDGW OMSPP.level
JEQZ L1123
CONST 1
LDLW 16
STOREC
CONST 1
STLC -65
CONST 1
ALIGNC
GLOBAL OMSPG.SetAllocationMode
CALL 1
JUMP L1121
LABEL L1123
!           ELSE S.Mark("remove asterisk")
LINE 930
CONST 16
GLOBAL OMSPP.%10
GLOBAL OMSPS.Mark
CALL 2
LABEL L1121
!           END; S.Get(sym) 
LINE 931
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LABEL L1120
!         IF sym = S.minus THEN
LINE 933
LDGW OMSPP.sym
CONST 7
JNEQ L1126
!           IF level = 0 THEN onetimeinit := TRUE
LINE 934
LDGW OMSPP.level
JNEQZ L1129
CONST 1
STLC -66
JUMP L1127
LABEL L1129
!           ELSE S.Mark("remove hyphen")
LINE 935
CONST 14
GLOBAL OMSPP.%96
GLOBAL OMSPS.Mark
CALL 2
LABEL L1127
!           END; S.Get(sym) 
LINE 936
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LABEL L1126
!         IF level = 0 THEN unsafe := FALSE ELSE unsafe := containsPointer(tp) END; (*check for unsafe pointers*)
LINE 938
LDGW OMSPP.level
JNEQZ L1132
CONST 0
STLC -62
JUMP L1130
LABEL L1132
LDLW -56
GLOBAL OMSPP.containsPointer
CALLW 1
STLC -62
LABEL L1130
!         obj := first; umm := FALSE; umf := FALSE;
LINE 939
LDLW -8
STLW -4
CONST 0
STLC -63
CONST 0
STLC -64
LABEL L1133
!         WHILE obj # NIL DO
LINE 940
LDLW -4
JEQZ L1135
!           obj.type := tp; obj.lev := level;
LINE 941
LDLW -56
LDLW -4
NCHECK 941
STNW 20
LDGW OMSPP.level
LDLW -4
NCHECK 941
STNW 8
!           IF onetimeinit THEN obj.rdo := TRUE; obj.class := B.StoredConst;
LINE 942
LDLC -66
JEQZ L1156
CONST 1
LDLW -4
NCHECK 942
CONST 5
STIC
CONST 9
LDLW -4
NCHECK 942
STOREC
!             obj.register := 0FFH; G.MakeConstObject(obj);
LINE 943
CONST 255
LDLW -4
NCHECK 943
CONST 2
STIC
LOCAL -4
GLOBAL OMSPG.MakeConstObject
CALL 1
JUMP L1149
LABEL L1156
!             IF unsafe & ~obj.unsafe THEN umm := TRUE END;
LINE 945
LDLC -62
JEQZ L1139
LDLW -4
NCHECK 945
CONST 4
LDIC
JNEQZ L1139
CONST 1
STLC -63
LABEL L1139
!             IF ~unsafe & obj.unsafe THEN umf := TRUE END;
LINE 946
LDLC -62
JNEQZ L1143
LDLW -4
NCHECK 946
CONST 4
LDIC
JEQZ L1143
CONST 1
STLC -64
LABEL L1143
!             IF inreg & (tp.size > 4) THEN S.Mark("reg alloc forbidden"); inreg := FALSE END;
LINE 947
LDLC -65
JEQZ L1147
LDLW -56
NCHECK 947
LDNW 32
CONST 4
JLEQ L1147
CONST 20
GLOBAL OMSPP.%97
GLOBAL OMSPS.Mark
CALL 2
CONST 0
STLC -65
LABEL L1147
!             IF inreg THEN obj.register := G.AllocR(); nbregs := tp.size DIV G.WordSize;
LINE 948
LDLC -65
JEQZ L1151
GLOBAL OMSPG.AllocR
CALLW 0
CONVNC
LDLW -4
NCHECK 948
CONST 2
STIC
LDLW -56
NCHECK 948
LDNW 32
CONST 2
DIV
STLW -104
LABEL L1152
!               WHILE nbregs > 1 DO dummy := G.AllocR(); DEC(nbregs) END
LINE 949
LDLW -104
CONST 1
JLEQ L1149
GLOBAL OMSPG.AllocR
CALLW 0
STLW -108
DECL -104
JUMP L1152
LABEL L1151
!             ELSE obj.register := 0FFH; G.AllocV(obj, varsize)
LINE 950
CONST 255
LDLW -4
NCHECK 950
CONST 2
STIC
LDLW 12
LDLW -4
GLOBAL OMSPG.AllocV
CALL 2
LABEL L1149
!           IF obj.expo THEN obj.exno := exno; INC(exno) END;
LINE 953
LDLW -4
NCHECK 953
CONST 3
LDIC
JEQZ L1159
LDGW OMSPP.exno
CONVNC
LDLW -4
NCHECK 953
CONST 1
STIC
LDGW OMSPP.exno
INC
STGW OMSPP.exno
LABEL L1159
!           obj := obj.next
LINE 954
LDLW -4
NCHECK 954
LDNW 12
STLW -4
JUMP L1133
LABEL L1135
!         IF umm THEN S.Mark("mark unsafe vars with an exclamation mark") 
LINE 956
LDLC -63
JEQZ L1162
CONST 42
GLOBAL OMSPP.%98
GLOBAL OMSPS.Mark
CALL 2
JUMP L1164
LABEL L1162
!         ELSIF umf THEN S.Mark("remove exclamation mark") END;
LINE 957
LDLC -64
JEQZ L1164
CONST 24
GLOBAL OMSPP.%11
GLOBAL OMSPS.Mark
CALL 2
LABEL L1164
!         Check(S.semicolon, "; missing")
LINE 958
CONST 10
GLOBAL OMSPP.%94
CONST 52
GLOBAL OMSPP.Check
CALL 3
JUMP L1115
LABEL L1114
!     varsize := (varsize + (G.WordSize - 1)) DIV G.WordSize * G.WordSize;
LINE 961
LDLW 12
LOADW
INC
CONST 2
DIV
CONST 2
TIMES
LDLW 12
STOREW
!     ptbase := pbsList;
LINE 962
LDGW OMSPP.pbsList
STLW -60
LABEL L1165
!     WHILE ptbase # NIL DO
LINE 963
LDLW -60
JEQZ L1167
!       IF ptbase.type.base.form = B.Int THEN S.Mark("undefined pointer base of") END ;
LINE 964
LDLW -60
NCHECK 964
LDNW 32
NCHECK 964
LDNW 28
NCHECK 964
LOADW
CONST 4
JNEQ L1170
CONST 26
GLOBAL OMSPP.%99
GLOBAL OMSPS.Mark
CALL 2
LABEL L1170
!       ptbase := ptbase.next
LINE 965
LDLW -60
NCHECK 965
LDNW 36
STLW -60
JUMP L1165
LABEL L1167
!     IF (sym >= S.const) & (sym <= S.var) THEN S.Mark("declaration in bad order") END
LINE 967
LDGW OMSPP.sym
CONST 63
JLT L1173
LDGW OMSPP.sym
CONST 65
JGT L1173
CONST 25
GLOBAL OMSPP.%100
GLOBAL OMSPS.Mark
CALL 2
LABEL L1173
RETURN
END

PROC OMSPP.ProcedureDecl 168 7 OMSPP.ProcedureDecl.%map
!   PROCEDURE ProcedureDecl;
LINE 970
!   BEGIN (* ProcedureDecl *) int := FALSE; nv := 0; S.Get(sym);
LINE 979
CONST 0
STLC -149
CONST 0
STLW -148
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!     IF sym = S.times THEN IF level # 0 THEN S.Mark("interrupt handler must be global") END;
LINE 980
LDGW OMSPP.sym
CONST 1
JNEQ L1178
LDGW OMSPP.level
JEQZ L1181
CONST 33
GLOBAL OMSPP.%101
GLOBAL OMSPS.Mark
CALL 2
LABEL L1181
!       int := TRUE; S.Get(sym); IF sym # S.lparen THEN S.Mark("no (") END;
LINE 981
CONST 1
STLC -149
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDGW OMSPP.sym
CONST 28
JEQ L1184
CONST 5
GLOBAL OMSPP.%15
GLOBAL OMSPS.Mark
CALL 2
LABEL L1184
!       REPEAT S.Get(sym); expression(x); CheckInt(x); CheckConst(x); v[nv] := x.a; INC(nv); UNTIL sym # S.comma;
LINE 982
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -88
LDGW OMSPP.expression
NCHECK 982
CALL 2
GLOBAL OMSPG.Item
LOCAL -88
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -88
GLOBAL OMSPP.CheckConst
CALL 2
LDLW -68
CONVNC
LOCAL -168
LDLW -148
CONST 8
BOUND 982
OFFSET
STOREC
INCL -148
LDGW OMSPP.sym
CONST 40
JEQ L1184
!       Check(S.rparen, "no )")
LINE 983
CONST 5
GLOBAL OMSPP.%16
CONST 44
GLOBAL OMSPP.Check
CALL 3
LABEL L1178
!     END; isInt := int;
LINE 984
LDLC -149
STGC OMSPP.isInt
!     IF sym = S.lbrace THEN S.Get(sym); set(sr); CheckConst(sr); Check(S.rbrace, "no }"); savedregs := SYSTEM.VAL(SET, sr.a)
LINE 985
LDGW OMSPP.sym
CONST 30
JNEQ L1189
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -132
GLOBAL OMSPP.set
CALL 2
GLOBAL OMSPG.Item
LOCAL -132
GLOBAL OMSPP.CheckConst
CALL 2
CONST 5
GLOBAL OMSPP.%43
CONST 46
GLOBAL OMSPP.Check
CALL 3
LDLW -112
STLW -160
JUMP L1187
LABEL L1189
!     ELSE savedregs := {}
LINE 986
CONST 0
STLW -160
LABEL L1187
!     IF sym = S.ident THEN
LINE 988
LDGW OMSPP.sym
CONST 31
JNEQ L1192
!       S.CopyId(procid); S.Get(sym); B.NewObj(proc, S.id, B.StoredConst);
LINE 989
LOCAL -44
GLOBAL OMSPS.CopyId
CALL 1
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
CONST 9
GLOBAL OMSPS.id
LOCAL -4
GLOBAL OMSPB.NewObj
CALL 3
!       parblksize := 0; NEW(type);
LINE 990
CONST 0
STLW -140
CONST 44
GLOBAL OMSPB.TypeDesc
GLOBAL NEW
CALLW 2
STLW -12
!       IF int THEN type.form := B.Handler ELSE type.form := B.Proc END;
LINE 991
LDLC -149
JEQZ L1195
CONST 15
LDLW -12
NCHECK 991
STOREW
JUMP L1193
LABEL L1195
CONST 10
LDLW -12
NCHECK 991
STOREW
LABEL L1193
!       G.SetRIU({}); G.SetPRU({}); proc.type := type; proc.val := -1; proc.lev := level; 
LINE 992
CONST 0
GLOBAL OMSPG.SetRIU
CALL 1
CONST 0
GLOBAL OMSPG.SetPRU
CALL 1
LDLW -12
LDLW -4
NCHECK 992
STNW 20
CONST -1
LDLW -4
NCHECK 992
STNW 56
LDGW OMSPP.level
LDLW -4
NCHECK 992
STNW 8
!       CheckExport(proc.expo);
LINE 993
LDLW -4
NCHECK 993
CONST 3
OFFSET
GLOBAL OMSPP.CheckExport
CALL 1
!       IF int & proc.expo THEN proc.expo := FALSE; S.Mark("remove asterisk") END;
LINE 994
LDLC -149
JEQZ L1198
LDLW -4
NCHECK 994
CONST 3
LDIC
JEQZ L1198
CONST 0
LDLW -4
NCHECK 994
CONST 3
STIC
CONST 16
GLOBAL OMSPP.%10
GLOBAL OMSPS.Mark
CALL 2
LABEL L1198
!       IF proc.expo THEN proc.exno := exno; INC(exno) END ;
LINE 995
LDLW -4
NCHECK 995
CONST 3
LDIC
JEQZ L1202
LDGW OMSPP.exno
CONVNC
LDLW -4
NCHECK 995
CONST 1
STIC
LDGW OMSPP.exno
INC
STGW OMSPP.exno
LABEL L1202
!       B.OpenScope; INC(level); type.base := B.noType;
LINE 996
GLOBAL OMSPB.OpenScope
CALL 0
LDGW OMSPP.level
INC
STGW OMSPP.level
LDGW OMSPB.noType
LDLW -12
NCHECK 996
STNW 28
!       ProcedureType(type, parblksize); (*formal parameter list*)
LINE 997
LOCAL -140
LDLW -12
GLOBAL OMSPP.ProcedureType
CALL 2
!       IF int & (parblksize # 0) THEN S.Mark("remove params") END;
LINE 998
LDLC -149
JEQZ L1205
LDLW -140
JEQZ L1205
CONST 14
GLOBAL OMSPP.%102
GLOBAL OMSPS.Mark
CALL 2
LABEL L1205
!       Check(S.semicolon, "no ;");
LINE 999
CONST 5
GLOBAL OMSPP.%103
CONST 52
GLOBAL OMSPP.Check
CALL 3
!       locblksize := 0; (*local variables are located immediately after return address/status register copy*)
LINE 1000
CONST 0
STLW -136
!       Declarations(locblksize, haveinregs); IF haveinregs THEN type.leaf := TRUE; isLeaf := TRUE END;
LINE 1001
LOCAL -150
LOCAL -136
GLOBAL OMSPP.Declarations
CALL 2
LDLC -150
JEQZ L1209
CONST 1
LDLW -12
NCHECK 1001
CONST 36
STIC
CONST 1
STGC OMSPP.isLeaf
LABEL L1209
!       loc := B.topScope.next; L := 0; (*fix .val offsets of parameters*)
LINE 1007
LDGW OMSPB.topScope
NCHECK 1007
LDNW 12
STLW -8
CONST 0
STLW -144
LABEL L1210
!       WHILE loc # NIL DO (*fix .val offsets of parameters and local variables*)
LINE 1008
LDLW -8
JEQZ L1212
!         IF (loc.class IN {B.Var, B.Par}) & (loc.register = 0FFH) THEN (*stored in stack*)
LINE 1009
CONST 1
LDLW -8
NCHECK 1009
LOADC
CONST 32
BOUND 1009
LSL
CONST 12
BITAND
JEQZ L1215
LDLW -8
NCHECK 1009
CONST 2
LDIC
CONST 255
JNEQ L1215
!           IF L < type.nofpar THEN (*parameter*) INC(loc.val, parblksize)
LINE 1010
LDLW -144
LDLW -12
NCHECK 1010
LDNW 12
JGEQ L1218
LDLW -8
NCHECK 1010
CONST 56
OFFSET
DUP 0
LOADW
LDLW -140
PLUS
SWAP
STOREW
JUMP L1215
LABEL L1218
!           ELSE (*local variable*) DEC(loc.val, locblksize)
LINE 1011
LDLW -8
NCHECK 1011
CONST 56
OFFSET
DUP 0
LOADW
LDLW -136
MINUS
SWAP
STOREW
LABEL L1215
!         loc := loc.next; INC(L)
LINE 1014
LDLW -8
NCHECK 1014
LDNW 12
STLW -8
INCL -144
JUMP L1210
LABEL L1212
!       proc.type.dsc := B.topScope.next;
LINE 1017
LDGW OMSPB.topScope
NCHECK 1017
LDNW 12
LDLW -4
NCHECK 1017
LDNW 20
NCHECK 1017
STNW 20
!       InsertResultRegister(type);
LINE 1018
LOCAL -12
GLOBAL OMSPP.InsertResultRegister
CALL 1
!       IF sym = S.procedure THEN
LINE 1020
LDGW OMSPP.sym
CONST 66
JNEQ L1222
!         riu := G.RIU; proc.type.ur := G.PRU;
LINE 1021
LDGW OMSPG.RIU
STLW -156
LDGW OMSPG.PRU
LDLW -4
NCHECK 1021
LDNW 20
NCHECK 1021
STNW 40
LABEL L1223
!         REPEAT ProcedureDecl; Check(S.semicolon, "no ;") UNTIL sym # S.procedure;
LINE 1022
GLOBAL OMSPP.ProcedureDecl
CALL 0
CONST 5
GLOBAL OMSPP.%103
CONST 52
GLOBAL OMSPP.Check
CALL 3
LDGW OMSPP.sym
CONST 66
JEQ L1223
!         proc.type.dsc := B.topScope.next;
LINE 1023
LDGW OMSPB.topScope
NCHECK 1023
LDNW 12
LDLW -4
NCHECK 1023
LDNW 20
NCHECK 1023
STNW 20
!         G.SetRIU(riu); G.SetPRU(proc.type.ur); (*restore current procedure RIU and PRU*)
LINE 1024
LDLW -156
GLOBAL OMSPG.SetRIU
CALL 1
LDLW -4
NCHECK 1024
LDNW 20
NCHECK 1024
LDNW 40
GLOBAL OMSPG.SetPRU
CALL 1
!         isInt := int
LINE 1025
LDLC -149
STGC OMSPP.isInt
LABEL L1222
!       G.AllocP(proc);
LINE 1027
LDLW -4
GLOBAL OMSPG.AllocP
CALL 1
LABEL L1225
!       WHILE nv > 0 DO DEC(nv); G.SetVector(v[nv], proc) END;
LINE 1028
LDLW -148
JLEQZ L1227
DECL -148
LOCAL -4
LOCAL -168
LDLW -148
CONST 8
BOUND 1028
OFFSET
LOADC
GLOBAL OMSPG.SetVector
CALL 2
JUMP L1225
LABEL L1227
!       IF isLeaf THEN G.SetAllocationMode(G.Register) ELSE G.SetAllocationMode(G.Stack) END;
LINE 1029
LDGC OMSPP.isLeaf
JEQZ L1230
CONST 1
ALIGNC
GLOBAL OMSPG.SetAllocationMode
CALL 1
JUMP L1228
LABEL L1230
CONST 0
ALIGNC
GLOBAL OMSPG.SetAllocationMode
CALL 1
LABEL L1228
!       IF int THEN G.LimitRegisters(savedregs) END;
LINE 1030
LDLC -149
JEQZ L1233
LDLW -160
GLOBAL OMSPG.LimitRegisters
CALL 1
LABEL L1233
!       G.Enter(locblksize, int, savedregs);
LINE 1031
LDLW -160
LDLC -149
ALIGNC
LDLW -136
GLOBAL OMSPG.Enter
CALL 3
!       IF sym = S.begin THEN S.Get(sym); StatSequence END;
LINE 1032
LDGW OMSPP.sym
CONST 67
JNEQ L1236
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPP.StatSequence
CALL 0
LABEL L1236
!       IF sym = S.return THEN
LINE 1033
LDGW OMSPP.sym
CONST 58
JNEQ L1239
!         S.Get(sym); expression(x);
LINE 1034
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -88
LDGW OMSPP.expression
NCHECK 1034
CALL 2
!         IF type.base = B.noType THEN S.Mark("this is not a function")
LINE 1035
LDLW -12
NCHECK 1035
LDNW 28
LDGW OMSPB.noType
JNEQ L1242
CONST 23
GLOBAL OMSPP.%104
GLOBAL OMSPS.Mark
CALL 2
JUMP L1246
LABEL L1242
!         ELSIF ~CompTypes(type.base, x.type, FALSE) THEN S.Mark("wrong result type")
LINE 1036
CONST 0
ALIGNC
LDLW -76
LDLW -12
NCHECK 1036
LDNW 28
GLOBAL OMSPP.CompTypes
CALLW 3
JNEQZ L1246
CONST 18
GLOBAL OMSPP.%105
GLOBAL OMSPS.Mark
CALL 2
JUMP L1246
LABEL L1239
!       ELSIF type.base.form # B.NoTyp THEN
LINE 1038
LDLW -12
NCHECK 1038
LDNW 28
NCHECK 1038
LOADW
CONST 9
JEQ L1246
!         S.Mark("function without result"); type.base := B.noType
LINE 1039
CONST 24
GLOBAL OMSPP.%106
GLOBAL OMSPS.Mark
CALL 2
LDGW OMSPB.noType
LDLW -12
NCHECK 1039
STNW 28
LABEL L1246
!       G.Return(type.base.form, x, locblksize, int, savedregs);
LINE 1041
LDLW -160
LDLC -149
ALIGNC
LDLW -136
GLOBAL OMSPG.Item
LOCAL -88
LDLW -12
NCHECK 1041
LDNW 28
NCHECK 1041
LOADW
GLOBAL OMSPG.Return
CALL 6
!       G.EndP(proc);
LINE 1042
LDLW -4
GLOBAL OMSPG.EndP
CALL 1
!       proc.type.ur := G.PRU;
LINE 1043
LDGW OMSPG.PRU
LDLW -4
NCHECK 1043
LDNW 20
NCHECK 1043
STNW 40
!       B.CloseScope; DEC(level); Check(S.end, "no END");
LINE 1044
GLOBAL OMSPB.CloseScope
CALL 0
LDGW OMSPP.level
DEC
STGW OMSPP.level
CONST 7
GLOBAL OMSPP.%60
CONST 53
GLOBAL OMSPP.Check
CALL 3
!       isLeaf := FALSE; isInt := FALSE;
LINE 1045
CONST 0
STGC OMSPP.isLeaf
CONST 0
STGC OMSPP.isInt
!       IF sym = S.ident THEN
LINE 1046
LDGW OMSPP.sym
CONST 31
JNEQ L1249
!         IF S.id # procid THEN S.Mark("no match") END ;
LINE 1047
CONST 32
LOCAL -44
CONST 32
GLOBAL OMSPS.id
GLOBAL COMPARE
CALLW 4
JEQZ L1252
CONST 9
GLOBAL OMSPP.%107
GLOBAL OMSPS.Mark
CALL 2
LABEL L1252
!         S.Get(sym)
LINE 1048
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
RETURN
LABEL L1249
!       ELSE S.Mark("no proc id")
LINE 1049
CONST 11
GLOBAL OMSPP.%108
GLOBAL OMSPS.Mark
CALL 2
RETURN
LABEL L1192
!     ELSE S.Mark("proc id expected")
LINE 1051
CONST 17
GLOBAL OMSPP.%109
GLOBAL OMSPS.Mark
CALL 2
RETURN
END

PROC OMSPP.Import 64 3 0
!   PROCEDURE Import;
LINE 1055
!     IF sym = S.ident THEN
LINE 1058
LDGW OMSPP.sym
CONST 31
JNEQ L1255
!       S.CopyId(impid); S.Get(sym);
LINE 1059
LOCAL -32
GLOBAL OMSPS.CopyId
CALL 1
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!       IF sym = S.becomes THEN
LINE 1060
LDGW OMSPP.sym
CONST 42
JNEQ L1258
!         S.Get(sym);
LINE 1061
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!         IF sym = S.ident THEN S.CopyId(impid1); S.Get(sym)
LINE 1062
LDGW OMSPP.sym
CONST 31
JNEQ L1261
LOCAL -64
GLOBAL OMSPS.CopyId
CALL 1
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
JUMP L1256
LABEL L1261
!         ELSE S.Mark("id expected"); impid1 := impid
LINE 1063
CONST 12
GLOBAL OMSPP.%110
GLOBAL OMSPS.Mark
CALL 2
LOCAL -64
LOCAL -32
CONST 32
FIXCOPY
JUMP L1256
LABEL L1258
!       ELSE impid1 := impid
LINE 1065
LOCAL -64
LOCAL -32
CONST 32
FIXCOPY
LABEL L1256
!       END; G.CheckRTImport(impid1);
LINE 1066
LOCAL -64
GLOBAL OMSPG.CheckRTImport
CALL 1
!       B.Import(impid, impid1)
LINE 1067
LOCAL -64
LOCAL -32
GLOBAL OMSPB.Import
CALL 2
RETURN
LABEL L1255
!     ELSE S.Mark("id expected")
LINE 1068
CONST 12
GLOBAL OMSPP.%110
GLOBAL OMSPS.Mark
CALL 2
RETURN
END

PROC OMSPP.Module 16 5 0
!   PROCEDURE Module;
LINE 1072
!   BEGIN isLeaf := FALSE; isInt := FALSE; Texts.WriteString(W, "  compiling "); S.Get(sym);
LINE 1074
CONST 0
STGC OMSPP.isLeaf
CONST 0
STGC OMSPP.isInt
CONST 13
GLOBAL OMSPP.%111
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteString
CALL 4
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!     IF sym = S.module THEN S.Get(sym);
LINE 1075
LDGW OMSPP.sym
CONST 69
JNEQ L1264
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!       IF sym = S.times THEN codeseg := 1 (*execute from RAM*); Texts.Write(W, "*"); S.Get(sym)
LINE 1076
LDGW OMSPP.sym
CONST 1
JNEQ L1267
CONST 1
STGC OMSPP.codeseg
CONST 42
ALIGNC
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.Write
CALL 3
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
JUMP L1265
LABEL L1267
!       ELSE codeseg := 0 (*execute from Flash*) END;
LINE 1077
CONST 0
STGC OMSPP.codeseg
LABEL L1265
!       G.Open;
LINE 1078
GLOBAL OMSPG.Open
CALL 0
!       initmode := FALSE;
LINE 1079
CONST 0
STGC OMSPP.initmode
!       B.Init; B.OpenScope;
LINE 1080
GLOBAL OMSPB.Init
CALL 0
GLOBAL OMSPB.OpenScope
CALL 0
!       IF sym = S.ident THEN
LINE 1081
LDGW OMSPP.sym
CONST 31
JNEQ L1270
!         S.CopyId(modid); S.Get(sym);
LINE 1082
GLOBAL OMSPP.modid
GLOBAL OMSPS.CopyId
CALL 1
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!         Texts.WriteString(W, modid); Texts.Append(Oberon.Log, W.buf)
LINE 1083
CONST 32
GLOBAL OMSPP.modid
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteString
CALL 4
LDGW OMSPP.W
LDGW Oberon.Log
GLOBAL Texts.Append
CALL 2
JUMP L1268
LABEL L1270
!       ELSE S.Mark("identifier expected")
LINE 1084
CONST 20
GLOBAL OMSPP.%2
GLOBAL OMSPS.Mark
CALL 2
LABEL L1268
!       Check(S.semicolon, "no ;"); level := 0; exno := 1; key := 0;
LINE 1086
CONST 5
GLOBAL OMSPP.%103
CONST 52
GLOBAL OMSPP.Check
CALL 3
CONST 0
STGW OMSPP.level
CONST 1
STGW OMSPP.exno
CONST 0
STLW -4
!       IF sym = S.import THEN
LINE 1087
LDGW OMSPP.sym
CONST 68
JNEQ L1273
!         S.Get(sym); Import;
LINE 1088
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPP.Import
CALL 0
LABEL L1274
!         WHILE sym = S.comma DO S.Get(sym); Import END ;
LINE 1089
LDGW OMSPP.sym
CONST 40
JNEQ L1276
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPP.Import
CALL 0
JUMP L1274
LABEL L1276
!         Check(S.semicolon, "; missing")
LINE 1090
CONST 10
GLOBAL OMSPP.%94
CONST 52
GLOBAL OMSPP.Check
CALL 3
LABEL L1273
!       Declarations(dmyv, dmy);
LINE 1092
LOCAL -13
LOCAL -12
GLOBAL OMSPP.Declarations
CALL 2
LABEL L1277
!       WHILE sym = S.procedure DO ProcedureDecl; Check(S.semicolon, "no ;") END ;
LINE 1093
LDGW OMSPP.sym
CONST 66
JNEQ L1279
GLOBAL OMSPP.ProcedureDecl
CALL 0
CONST 5
GLOBAL OMSPP.%103
CONST 52
GLOBAL OMSPP.Check
CALL 3
JUMP L1277
LABEL L1279
!       initmode := TRUE;
LINE 1094
CONST 1
STGC OMSPP.initmode
!       G.Header;
LINE 1095
GLOBAL OMSPG.Header
CALL 0
!       IF sym = S.begin THEN S.Get(sym); StatSequence END ;
LINE 1096
LDGW OMSPP.sym
CONST 67
JNEQ L1282
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPP.StatSequence
CALL 0
LABEL L1282
!       Check(S.end, "no END");
LINE 1097
CONST 7
GLOBAL OMSPP.%60
CONST 53
GLOBAL OMSPP.Check
CALL 3
!       IF sym = S.ident THEN
LINE 1098
LDGW OMSPP.sym
CONST 31
JNEQ L1285
!         IF S.id # modid THEN S.Mark("no match") END ;
LINE 1099
CONST 32
GLOBAL OMSPP.modid
CONST 32
GLOBAL OMSPS.id
GLOBAL COMPARE
CALLW 4
JEQZ L1288
CONST 9
GLOBAL OMSPP.%107
GLOBAL OMSPS.Mark
CALL 2
LABEL L1288
!         S.Get(sym)
LINE 1100
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
JUMP L1283
LABEL L1285
!       ELSE S.Mark("identifier missing")
LINE 1101
CONST 19
GLOBAL OMSPP.%112
GLOBAL OMSPS.Mark
CALL 2
LABEL L1283
!       IF sym # S.period THEN S.Mark("period missing") END ;
LINE 1103
LDGW OMSPP.sym
CONST 18
JEQ L1291
CONST 15
GLOBAL OMSPP.%113
GLOBAL OMSPS.Mark
CALL 2
LABEL L1291
!       IF S.errcnt = 0 THEN
LINE 1104
LDGW OMSPS.errcnt
JNEQZ L1294
!         B.Export(modid, newSF, key);
LINE 1105
LOCAL -4
GLOBAL OMSPP.newSF
GLOBAL OMSPP.modid
GLOBAL OMSPB.Export
CALL 3
!         IF newSF THEN Texts.WriteString(W, " new symbol file") END
LINE 1106
LDGC OMSPP.newSF
JEQZ L1294
CONST 17
GLOBAL OMSPP.%114
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteString
CALL 4
LABEL L1294
!       IF S.errcnt = 0 THEN G.Close(modid, key, exno, codeseg);
LINE 1108
LDGW OMSPS.errcnt
JNEQZ L1300
LDGC OMSPP.codeseg
LDGW OMSPP.exno
LDLW -4
GLOBAL OMSPP.modid
GLOBAL OMSPG.Close
CALL 4
!         Texts.WriteInt(W, G.Here(), 6); Texts.WriteInt(W, G.varsize, 6); Texts.WriteHex(W, key)
LINE 1109
CONST 6
GLOBAL OMSPG.Here
CALLW 0
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteInt
CALL 4
CONST 6
LDGW OMSPG.varsize
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteInt
CALL 4
LDLW -4
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteHex
CALL 3
JUMP L1298
LABEL L1300
!       ELSE Texts.WriteLn(W); oldCol := W.col; W.col := Display.red; Texts.WriteString(W, "compilation FAILED"); W.col := oldCol 
LINE 1110
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteLn
CALL 2
GLOBAL OMSPP.W
LDNW 4
STLW -8
CONST 224
GLOBAL OMSPP.W
STNW 4
CONST 19
GLOBAL OMSPP.%115
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteString
CALL 4
LDLW -8
GLOBAL OMSPP.W
STNW 4
LABEL L1298
!       Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf);
LINE 1112
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteLn
CALL 2
LDGW OMSPP.W
LDGW Oberon.Log
GLOBAL Texts.Append
CALL 2
!       B.CloseScope; pbsList := NIL
LINE 1113
GLOBAL OMSPB.CloseScope
CALL 0
CONST 0
STGW OMSPP.pbsList
RETURN
LABEL L1264
!     ELSE S.Mark("must start with MODULE")
LINE 1114
CONST 23
GLOBAL OMSPP.%116
GLOBAL OMSPS.Mark
CALL 2
RETURN
END

PROC OMSPP.Option 0 3 0x00100001
!   PROCEDURE Option(VAR S1: Texts.Scanner);
LINE 1118
!   BEGIN newSF := FALSE;
LINE 1119
CONST 0
STGC OMSPP.newSF
!     IF S1.nextCh = "/" THEN
LINE 1120
LDLW 12
CONST 32
LDIC
CONST 47
JNEQ L1303
!       Texts.Scan(S1); Texts.Scan(S1); 
LINE 1121
LDLW 16
LDLW 12
GLOBAL Texts.Scan
CALL 2
LDLW 16
LDLW 12
GLOBAL Texts.Scan
CALL 2
!       IF (S1.class = Texts.Name) & (S1.s[0] = "s") THEN newSF := TRUE END
LINE 1122
LDLW 12
LDNW 40
CONST 1
JNEQ L1303
LDLW 12
CONST 64
LDIC
CONST 115
JNEQ L1303
CONST 1
STGC OMSPP.newSF
LABEL L1303
RETURN
END

PROC OMSPP.Compile 112 5 OMSPP.Compile.%map
!   PROCEDURE Compile*;
LINE 1126
!   BEGIN Texts.OpenScanner(S1, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S1);
LINE 1130
GLOBAL Oberon.Par
LDNW 4
LDGW Oberon.Par
GLOBAL Texts.Scanner
LOCAL -112
GLOBAL Texts.OpenScanner
CALL 4
GLOBAL Texts.Scanner
LOCAL -112
GLOBAL Texts.Scan
CALL 2
!     IF S1.class = Texts.Char THEN
LINE 1131
LDLW -72
CONST 6
JNEQ L1320
!       IF S1.c = "@" THEN
LINE 1132
LDLC -56
CONST 64
JNEQ L1323
!         Option(S1); Oberon.GetSelection(T, beg, end, time);
LINE 1133
GLOBAL Texts.Scanner
LOCAL -112
GLOBAL OMSPP.Option
CALL 2
LOCAL -12
LOCAL -8
LOCAL -4
LOCAL -16
GLOBAL Oberon.GetSelection
CALL 4
!         IF time >= 0 THEN S.Init(T, beg); Module END
LINE 1134
LDLW -12
JLTZ L1311
LDLW -4
LDLW -16
GLOBAL OMSPS.Init
CALL 2
GLOBAL OMSPP.Module
CALL 0
JUMP L1311
LABEL L1323
!       ELSIF S1.c = "^" THEN
LINE 1135
LDLC -56
CONST 94
JNEQ L1311
!         Option(S1); Oberon.GetSelection(T, beg, end, time);
LINE 1136
GLOBAL Texts.Scanner
LOCAL -112
GLOBAL OMSPP.Option
CALL 2
LOCAL -12
LOCAL -8
LOCAL -4
LOCAL -16
GLOBAL Oberon.GetSelection
CALL 4
!         IF time >= 0 THEN
LINE 1137
LDLW -12
JLTZ L1311
!           Texts.OpenScanner(S1, T, beg); Texts.Scan(S1);
LINE 1138
LDLW -4
LDLW -16
GLOBAL Texts.Scanner
LOCAL -112
GLOBAL Texts.OpenScanner
CALL 4
GLOBAL Texts.Scanner
LOCAL -112
GLOBAL Texts.Scan
CALL 2
!           IF S1.class = Texts.Name THEN
LINE 1139
LDLW -72
CONST 1
JNEQ L1311
!             Texts.WriteString(W, S1.s); NEW(T); Texts.Open(T, S1.s);
LINE 1140
CONST 32
LOCAL -48
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteString
CALL 4
CONST 24
GLOBAL Texts.TextDesc
GLOBAL NEW
CALLW 2
STLW -16
CONST 32
LOCAL -48
LDLW -16
GLOBAL Texts.Open
CALL 3
!             IF T.len > 0 THEN S.Init(T, 0); Module
LINE 1141
LDLW -16
NCHECK 1141
LOADW
JLEQZ L1337
CONST 0
LDLW -16
GLOBAL OMSPS.Init
CALL 2
GLOBAL OMSPP.Module
CALL 0
JUMP L1311
LABEL L1337
!             ELSE Texts.WriteString(W, " not found");
LINE 1142
CONST 11
GLOBAL OMSPP.%117
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteString
CALL 4
!               Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)
LINE 1143
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteLn
CALL 2
LDGW OMSPP.W
LDGW Oberon.Log
GLOBAL Texts.Append
CALL 2
JUMP L1311
LABEL L1320
!       WHILE S1.class = Texts.Name DO
LINE 1149
LDLW -72
CONST 1
JNEQ L1311
!         NEW(T); Texts.Open(T, S1.s);
LINE 1150
CONST 24
GLOBAL Texts.TextDesc
GLOBAL NEW
CALLW 2
STLW -16
CONST 32
LOCAL -48
LDLW -16
GLOBAL Texts.Open
CALL 3
!         IF T.len > 0 THEN Option(S1); S.Init(T, 0); Module
LINE 1151
LDLW -16
NCHECK 1151
LOADW
JLEQZ L1314
GLOBAL Texts.Scanner
LOCAL -112
GLOBAL OMSPP.Option
CALL 2
CONST 0
LDLW -16
GLOBAL OMSPS.Init
CALL 2
GLOBAL OMSPP.Module
CALL 0
JUMP L1312
LABEL L1314
!         ELSE Texts.WriteString(W, S1.s); Texts.WriteString(W, " not found");
LINE 1152
CONST 32
LOCAL -48
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteString
CALL 4
CONST 11
GLOBAL OMSPP.%117
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteString
CALL 4
!           Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)
LINE 1153
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteLn
CALL 2
LDGW OMSPP.W
LDGW Oberon.Log
GLOBAL Texts.Append
CALL 2
LABEL L1312
!         IF (T.len # 0) & (S.errcnt = 0) THEN Texts.Scan(S1) ELSE S1.class := 0 END
LINE 1155
LDLW -16
NCHECK 1155
LOADW
JEQZ L1317
LDGW OMSPS.errcnt
JNEQZ L1317
GLOBAL Texts.Scanner
LOCAL -112
GLOBAL Texts.Scan
CALL 2
JUMP L1320
LABEL L1317
CONST 0
STLW -72
JUMP L1320
LABEL L1311
!     Oberon.Collect(0)
LINE 1158
CONST 0
GLOBAL Oberon.Collect
CALL 1
RETURN
END

PROC OMSPP.%main 0 5 0
! BEGIN Texts.OpenWriter(W); Texts.WriteString(W, "OMSP Compiler 19.10.25");
LINE 1161
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.OpenWriter
CALL 2
CONST 23
GLOBAL OMSPP.%118
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteString
CALL 4
!   Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf);
LINE 1162
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteLn
CALL 2
LDGW OMSPP.W
LDGW Oberon.Log
GLOBAL Texts.Append
CALL 2
!   NEW(dummy); dummy.class := B.Var; dummy.type := B.intType; dummy.val := 0;
LINE 1163
CONST 60
GLOBAL OMSPB.ObjDesc
GLOBAL NEW
CALLW 2
STGW OMSPP.dummy
CONST 2
LDGW OMSPP.dummy
NCHECK 1163
STOREC
LDGW OMSPB.intType
LDGW OMSPP.dummy
NCHECK 1163
STNW 20
CONST 0
LDGW OMSPP.dummy
NCHECK 1163
STNW 56
!   expression := expression0; Type := Type0; FormalType := FormalType0
LINE 1164
GLOBAL OMSPP.expression0
STGW OMSPP.expression
GLOBAL OMSPP.Type0
STGW OMSPP.Type
GLOBAL OMSPP.FormalType0
STGW OMSPP.FormalType
RETURN
END

! Global variables
GLOVAR OMSPP.sym 4
GLOVAR OMSPP.level 4
GLOVAR OMSPP.exno 4
GLOVAR OMSPP.newSF 1
GLOVAR OMSPP.initmode 1
GLOVAR OMSPP.expression 4
GLOVAR OMSPP.Type 4
GLOVAR OMSPP.FormalType 4
GLOVAR OMSPP.modid 32
GLOVAR OMSPP.pbsList 4
GLOVAR OMSPP.dummy 4
GLOVAR OMSPP.isLeaf 1
GLOVAR OMSPP.isInt 1
GLOVAR OMSPP.codeseg 1
GLOVAR OMSPP.W 20

! Global pointer map
DEFINE OMSPP.%gcmap
WORD GC_POINTER
WORD OMSPP.pbsList
WORD GC_POINTER
WORD OMSPP.dummy
WORD GC_BASE
WORD OMSPP.W
WORD 0x00000023
WORD GC_END

! String "undef"
DEFINE OMSPP.%1
STRING 756E64656600

! String "identifier expected"
DEFINE OMSPP.%2
STRING 6964656E74696669657220657870656374656400

! String "not Boolean"
DEFINE OMSPP.%3
STRING 6E6F7420426F6F6C65616E00

! String "not Integer"
DEFINE OMSPP.%4
STRING 6E6F7420496E746567657200

! String "not Set"
DEFINE OMSPP.%5
STRING 6E6F742053657400

! String "not Int"
DEFINE OMSPP.%6
STRING 6E6F7420496E7400

! String "invalid set"
DEFINE OMSPP.%7
STRING 696E76616C69642073657400

! String "not a constant"
DEFINE OMSPP.%8
STRING 6E6F74206120636F6E7374616E7400

! String "read-only"
DEFINE OMSPP.%9
STRING 726561642D6F6E6C7900

! String "remove asterisk"
DEFINE OMSPP.%10
STRING 72656D6F766520617374657269736B00

! String "remove exclamation mark"
DEFINE OMSPP.%11
STRING 72656D6F7665206578636C616D6174696F6E206D61726B00

! String "not an extension"
DEFINE OMSPP.%12
STRING 6E6F7420616E20657874656E73696F6E00

! String "incompatible types"
DEFINE OMSPP.%13
STRING 696E636F6D70617469626C6520747970657300

! String "type mismatch"
DEFINE OMSPP.%14
STRING 74797065206D69736D6174636800

! String "no ("
DEFINE OMSPP.%15
STRING 6E6F202800

! String "no )"
DEFINE OMSPP.%16
STRING 6E6F202900

! String "bad type"
DEFINE OMSPP.%17
STRING 626164207479706500

! String "not an array"
DEFINE OMSPP.%18
STRING 6E6F7420616E20617272617900

! String "first op is not a type"
DEFINE OMSPP.%19
STRING 6669727374206F70206973206E6F742061207479706500

! String "casting not allowed"
DEFINE OMSPP.%20
STRING 63617374696E67206E6F7420616C6C6F77656400

! String "must be a type"
DEFINE OMSPP.%21
STRING 6D7573742062652061207479706500

! String "wrong nof params"
DEFINE OMSPP.%22
STRING 77726F6E67206E6F6620706172616D7300

! String "no ]"
DEFINE OMSPP.%23
STRING 6E6F205D00

! String "not a record"
DEFINE OMSPP.%24
STRING 6E6F742061207265636F726400

! String "ident?"
DEFINE OMSPP.%25
STRING 6964656E743F00

! String "not a pointer"
DEFINE OMSPP.%26
STRING 6E6F74206120706F696E74657200

! String "guard type expected"
DEFINE OMSPP.%27
STRING 6775617264207479706520657870656374656400

! String "not an identifier"
DEFINE OMSPP.%28
STRING 6E6F7420616E206964656E74696669657200

! String " ) missing"
DEFINE OMSPP.%29
STRING 2029206D697373696E6700

! String "regs destroyed: "
DEFINE OMSPP.%30
STRING 726567732064657374726F7965643A2000

! String ", "
DEFINE OMSPP.%31
STRING 2C2000

! String "incompatible leafness"
DEFINE OMSPP.%32
STRING 696E636F6D70617469626C65206C6561666E65737300

! String "incompatible parameters"
DEFINE OMSPP.%33
STRING 696E636F6D70617469626C6520706172616D657465727300

! String "comma?"
DEFINE OMSPP.%34
STRING 636F6D6D613F00

! String ") missing"
DEFINE OMSPP.%35
STRING 29206D697373696E6700

! String "too few params"
DEFINE OMSPP.%36
STRING 746F6F2066657720706172616D7300

! String "too many params"
DEFINE OMSPP.%37
STRING 746F6F206D616E7920706172616D7300

! String " } missing"
DEFINE OMSPP.%38
STRING 207D206D697373696E6700

! String "missing comma"
DEFINE OMSPP.%39
STRING 6D697373696E6720636F6D6D6100

! String "expression expected"
DEFINE OMSPP.%40
STRING 65787072657373696F6E20657870656374656400

! String "no call in leaf func"
DEFINE OMSPP.%41
STRING 6E6F2063616C6C20696E206C6561662066756E6300

! String "not a function"
DEFINE OMSPP.%42
STRING 6E6F7420612066756E6374696F6E00

! String "no }"
DEFINE OMSPP.%43
STRING 6E6F207D00

! String "not a factor"
DEFINE OMSPP.%44
STRING 6E6F74206120666163746F7200

! String "not String nor Char"
DEFINE OMSPP.%45
STRING 6E6F7420537472696E67206E6F72204368617200

! String "only = or #"
DEFINE OMSPP.%46
STRING 6F6E6C79203D206F72202300

! String "illegal comparison"
DEFINE OMSPP.%47
STRING 696C6C6567616C20636F6D70617269736F6E00

! String "not allowed here"
DEFINE OMSPP.%48
STRING 6E6F7420616C6C6F776564206865726500

! String "wrong nof parameters"
DEFINE OMSPP.%49
STRING 77726F6E67206E6F6620706172616D657465727300

! String "not a type"
DEFINE OMSPP.%50
STRING 6E6F742061207479706500

! String ": expected"
DEFINE OMSPP.%51
STRING 3A20657870656374656400

! String "type id expected"
DEFINE OMSPP.%52
STRING 7479706520696420657870656374656400

! String "statement expected"
DEFINE OMSPP.%53
STRING 73746174656D656E7420657870656374656400

! String "illegal assignment"
DEFINE OMSPP.%54
STRING 696C6C6567616C2061737369676E6D656E7400

! String "should be :="
DEFINE OMSPP.%55
STRING 73686F756C64206265203A3D00

! String "no call in leaf proc"
DEFINE OMSPP.%56
STRING 6E6F2063616C6C20696E206C6561662070726F6300

! String "not a procedure"
DEFINE OMSPP.%57
STRING 6E6F7420612070726F63656475726500

! String "missing parameters"
DEFINE OMSPP.%58
STRING 6D697373696E6720706172616D657465727300

! String "no THEN"
DEFINE OMSPP.%59
STRING 6E6F205448454E00

! String "no END"
DEFINE OMSPP.%60
STRING 6E6F20454E4400

! String "no DO"
DEFINE OMSPP.%61
STRING 6E6F20444F00

! String "missing UNTIL"
DEFINE OMSPP.%62
STRING 6D697373696E6720554E54494C00

! String "no TO"
DEFINE OMSPP.%63
STRING 6E6F20544F00

! String ":= expected"
DEFINE OMSPP.%64
STRING 3A3D20657870656374656400

! String "OF expected"
DEFINE OMSPP.%65
STRING 4F4620657870656374656400

! String "numeric case not implemented"
DEFINE OMSPP.%66
STRING 6E756D657269632063617365206E6F7420696D706C656D656E74656400

! String "ident expected"
DEFINE OMSPP.%67
STRING 6964656E7420657870656374656400

! String "missing semicolon?"
DEFINE OMSPP.%68
STRING 6D697373696E672073656D69636F6C6F6E3F00

! String ":?"
DEFINE OMSPP.%69
STRING 3A3F00

! String "not a valid length"
DEFINE OMSPP.%70
STRING 6E6F7420612076616C6964206C656E67746800

! String "dyn array not allowed"
DEFINE OMSPP.%71
STRING 64796E206172726179206E6F7420616C6C6F77656400

! String "missing OF"
DEFINE OMSPP.%72
STRING 6D697373696E67204F4600

! String "extension of local types not implemented"
DEFINE OMSPP.%73
STRING 657874656E73696F6E206F66206C6F63616C207479706573206E6F7420696D70
STRING 6C656D656E74656400

! String "invalid extension"
DEFINE OMSPP.%74
STRING 696E76616C696420657874656E73696F6E00

! String "type expected"
DEFINE OMSPP.%75
STRING 7479706520657870656374656400

! String "mult def"
DEFINE OMSPP.%76
STRING 6D756C742064656600

! String "comma expected"
DEFINE OMSPP.%77
STRING 636F6D6D6120657870656374656400

! String "colon expected"
DEFINE OMSPP.%78
STRING 636F6C6F6E20657870656374656400

! String " ; or END"
DEFINE OMSPP.%79
STRING 203B206F7220454E4400

! String "too many parameters"
DEFINE OMSPP.%80
STRING 746F6F206D616E7920706172616D657465727300

! String "illegal function type"
DEFINE OMSPP.%81
STRING 696C6C6567616C2066756E6374696F6E207479706500

! String "type identifier expected"
DEFINE OMSPP.%82
STRING 74797065206964656E74696669657220657870656374656400

! String "OF ?"
DEFINE OMSPP.%83
STRING 4F46203F00

! String "multi-dimensional open arrays not implemented"
DEFINE OMSPP.%84
STRING 6D756C74692D64696D656E73696F6E616C206F70656E20617272617973206E6F
STRING 7420696D706C656D656E74656400

! String "ptr base must be global"
DEFINE OMSPP.%85
STRING 7074722062617365206D75737420626520676C6F62616C00

! String "not a type or undefined"
DEFINE OMSPP.%86
STRING 6E6F7420612074797065206F7220756E646566696E656400

! String "external base type not implemented"
DEFINE OMSPP.%87
STRING 65787465726E616C20626173652074797065206E6F7420696D706C656D656E74
STRING 656400

! String "no valid base type"
DEFINE OMSPP.%88
STRING 6E6F2076616C69642062617365207479706500

! String "must point to named record"
DEFINE OMSPP.%89
STRING 6D75737420706F696E7420746F206E616D6564207265636F726400

! String "illegal type"
DEFINE OMSPP.%90
STRING 696C6C6567616C207479706500

! String "declaration?"
DEFINE OMSPP.%91
STRING 6465636C61726174696F6E3F00

! String "= ?"
DEFINE OMSPP.%92
STRING 3D203F00

! String "expression not constant"
DEFINE OMSPP.%93
STRING 65787072657373696F6E206E6F7420636F6E7374616E7400

! String "; missing"
DEFINE OMSPP.%94
STRING 3B206D697373696E6700

! String "=?"
DEFINE OMSPP.%95
STRING 3D3F00

! String "remove hyphen"
DEFINE OMSPP.%96
STRING 72656D6F76652068797068656E00

! String "reg alloc forbidden"
DEFINE OMSPP.%97
STRING 72656720616C6C6F6320666F7262696464656E00

! String "mark unsafe vars with an exclamation mark"
DEFINE OMSPP.%98
STRING 6D61726B20756E736166652076617273207769746820616E206578636C616D61
STRING 74696F6E206D61726B00

! String "undefined pointer base of"
DEFINE OMSPP.%99
STRING 756E646566696E656420706F696E7465722062617365206F6600

! String "declaration in bad order"
DEFINE OMSPP.%100
STRING 6465636C61726174696F6E20696E20626164206F7264657200

! String "interrupt handler must be global"
DEFINE OMSPP.%101
STRING 696E746572727570742068616E646C6572206D75737420626520676C6F62616C
STRING 00

! String "remove params"
DEFINE OMSPP.%102
STRING 72656D6F766520706172616D7300

! String "no ;"
DEFINE OMSPP.%103
STRING 6E6F203B00

! String "this is not a function"
DEFINE OMSPP.%104
STRING 74686973206973206E6F7420612066756E6374696F6E00

! String "wrong result type"
DEFINE OMSPP.%105
STRING 77726F6E6720726573756C74207479706500

! String "function without result"
DEFINE OMSPP.%106
STRING 66756E6374696F6E20776974686F757420726573756C7400

! String "no match"
DEFINE OMSPP.%107
STRING 6E6F206D6174636800

! String "no proc id"
DEFINE OMSPP.%108
STRING 6E6F2070726F6320696400

! String "proc id expected"
DEFINE OMSPP.%109
STRING 70726F6320696420657870656374656400

! String "id expected"
DEFINE OMSPP.%110
STRING 696420657870656374656400

! String "  compiling "
DEFINE OMSPP.%111
STRING 2020636F6D70696C696E672000

! String "identifier missing"
DEFINE OMSPP.%112
STRING 6964656E746966696572206D697373696E6700

! String "period missing"
DEFINE OMSPP.%113
STRING 706572696F64206D697373696E6700

! String " new symbol file"
DEFINE OMSPP.%114
STRING 206E65772073796D626F6C2066696C6500

! String "compilation FAILED"
DEFINE OMSPP.%115
STRING 636F6D70696C6174696F6E204641494C454400

! String "must start with MODULE"
DEFINE OMSPP.%116
STRING 6D7573742073746172742077697468204D4F44554C4500

! String " not found"
DEFINE OMSPP.%117
STRING 206E6F7420666F756E6400

! String "OMSP Compiler 19.10.25"
DEFINE OMSPP.%118
STRING 4F4D535020436F6D70696C65722031392E31302E323500

! Descriptor for PtrBaseDesc
DEFINE OMSPP.PtrBaseDesc
WORD 0x00000601
WORD 0
WORD OMSPP.PtrBaseDesc.%anc

DEFINE OMSPP.PtrBaseDesc.%anc
WORD OMSPP.PtrBaseDesc

! Pointer maps
DEFINE OMSPP.StandFunc.%map
WORD 12
WORD 24
WORD -32
WORD -28
WORD -76
WORD -72
WORD GC_END

DEFINE OMSPP.StandProc.%map
WORD -40
WORD -36
WORD -84
WORD -80
WORD -128
WORD -124
WORD GC_END

DEFINE OMSPP.StatSequence.%map
WORD -4
WORD -8
WORD -40
WORD -36
WORD -84
WORD -80
WORD -128
WORD -124
WORD -172
WORD -168
WORD GC_END

DEFINE OMSPP.ProcedureDecl.%map
WORD -4
WORD -8
WORD -12
WORD -76
WORD -72
WORD -120
WORD -116
WORD GC_END

DEFINE OMSPP.Compile.%map
WORD -16
WORD -104
WORD -84
WORD GC_END

! End of file
