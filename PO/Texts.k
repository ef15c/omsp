!! (SYMFILE #Texts 0x00030300 #Texts.%main 1 #Texts.Mod)
!! (CONST #Inval* INTCONST 0)
!! (CONST #Name* INTCONST 1)
!! (CONST #String* INTCONST 2)
!! (CONST #Int* INTCONST 3)
!! (CONST #Real* INTCONST 4)
!! (CONST #Char* INTCONST 6)
!! (CONST #TAB* CHAR 9)
!! (CONST #CR* CHAR 10)
!! (CONST #TextTag CHAR 241)
!! (CONST #replace* INTCONST 0)
!! (CONST #insert* INTCONST 1)
!! (CONST #delete* INTCONST 2)
!! (CONST #unmark* INTCONST 3)
!! (TYPE #Piece !1 (POINTER))
!! (TARGET =1 !2 (RECORD #Texts.PieceDesc 24 VOID
!!     (FIELD #f 0 ?3 #POFiles 1 #File (POINTER))
!!     (FIELD #off 4 INTEGER)
!!     (FIELD #len 8 INTEGER)
!!     (FIELD #col 12 INTEGER)
!!     (FIELD #prev 16 =1)
!!     (FIELD #next 20 =1)))
!! (TARGET =3 ?4 #POFiles 2 #FileDesc (RECORD #POFiles.FileDesc 68 VOID
!!     (FIELD #file 0 ?5 #Files 1 #File (POINTER))
!!     (FIELD #tmpName 4 ?6 #POFiles 4 ANON (ARRAY 32 CHAR))
!!     (FIELD #name 36 =6)))
!! (TARGET =5 ?7 #Files 2 #FileDesc (RECORD #Files.FileDesc 8 VOID
!!     (FIELD #file- 0 SYSTEM.LONGPTR)))
!! (TYPE #PieceDesc =2)
!! (TYPE #Text* !8 (POINTER))
!! (TARGET =8 !9 (RECORD #Texts.TextDesc 24 VOID
!!     (FIELD #len* 0 INTEGER)
!!     (FIELD #changed* 4 BOOLEAN)
!!     (FIELD #notify* 8 !10 (PROC 4 VOID
!!         (PARAM #T 12 =8)
!!         (PARAM #op 16 INTEGER)
!!         (PARAM #beg 20 INTEGER)
!!         (PARAM #end 24 INTEGER)))
!!     (FIELD #trailer 12 =1)
!!     (FIELD #pce 16 =1)
!!     (FIELD #org 20 INTEGER)))
!! (TYPE #Notifier* =10)
!! (TYPE #TextDesc* =9)
!! (TYPE #Reader* !11 (RECORD #Texts.Reader 32 VOID
!!     (FIELD #eot* 0 BOOLEAN)
!!     (FIELD #col* 4 INTEGER)
!!     (FIELD #ref 8 =1)
!!     (FIELD #org 12 INTEGER)
!!     (FIELD #off 16 INTEGER)
!!     (FIELD #rider 20 ?12 #POFiles 6 #Rider (RECORD #POFiles.Rider 12 VOID
!!         (FIELD #eof* 0 BOOLEAN)
!!         (FIELD #res* 4 INTEGER)
!!         (FIELD #base 8 =3)))))
!! (TYPE #Scanner* !13 (RECORD #Texts.Scanner 96 =11
!!     (FIELD #eot* 0 BOOLEAN)
!!     (FIELD #col* 4 INTEGER)
!!     (FIELD #ref 8 =1)
!!     (FIELD #org 12 INTEGER)
!!     (FIELD #off 16 INTEGER)
!!     (FIELD #rider 20 =12)
!!     (FIELD #nextCh* 32 CHAR)
!!     (FIELD #line* 36 INTEGER)
!!     (FIELD #class* 40 INTEGER)
!!     (FIELD #i* 44 LONGINT)
!!     (FIELD #x* 52 REAL)
!!     (FIELD #c* 56 CHAR)
!!     (FIELD #len* 60 INTEGER)
!!     (FIELD #s* 64 !14 (ARRAY 32 CHAR))))
!! (TYPE #Buffer* !15 (POINTER))
!! (TARGET =15 !16 (RECORD #Texts.BufDesc 12 VOID
!!     (FIELD #len* 0 INTEGER)
!!     (FIELD #header 4 =1)
!!     (FIELD #last 8 =1)))
!! (TYPE #BufDesc* =16)
!! (TYPE #Writer* !17 (RECORD #Texts.Writer 20 VOID
!!     (FIELD #buf* 0 =15)
!!     (FIELD #col* 4 INTEGER)
!!     (FIELD #rider 8 =12)))
!! (GLOBAL #TrailerFile #Texts.TrailerFile =3)
!! (PROCEDURE #Trailer 73 #Texts.Trailer !18 (PROC 0 =1)
!!   (LOCAL #Q -4 =1))
!! (PROCEDURE #Load* 79 #Texts.Load !19 (PROC 3 VOID
!!     (VPARAM #R 12 =12)
!!     (PARAM #T 20 =8))
!!   (LOCAL #Q -4 =1)
!!   (LOCAL #q -8 =1)
!!   (LOCAL #p -12 =1)
!!   (LOCAL #off -16 INTEGER)
!!   (LOCAL #len -20 INTEGER)
!!   (LOCAL #bt -21 BYTE)
!!   (LOCAL #f -28 =3))
!! (DEF !20 (FLEX CHAR))
!! (PROCEDURE #Open* 95 #Texts.Open !21 (PROC 3 VOID
!!     (PARAM #T 12 =8)
!!     (CPARAM #name 16 =20))
!!   (LOCAL #f -4 =3)
!!   (LOCAL #R -16 =12)
!!   (LOCAL #Q -20 =1)
!!   (LOCAL #q -24 =1)
!!   (LOCAL #tag -25 CHAR)
!!   (LOCAL #len -32 INTEGER))
!! (PROCEDURE #Store* 113 #Texts.Store !22 (PROC 3 VOID
!!     (VPARAM #W 12 =12)
!!     (PARAM #T 20 =8))
!!   (LOCAL #p -4 =1)
!!   (LOCAL #R -16 =12)
!!   (LOCAL #rlen -20 INTEGER)
!!   (LOCAL #ch -21 CHAR))
!! (DEF !23 (FLEX CHAR))
!! (PROCEDURE #Close* 128 #Texts.Close !24 (PROC 3 VOID
!!     (PARAM #T 12 =8)
!!     (CPARAM #name 16 =23))
!!   (LOCAL #f -4 =3)
!!   (LOCAL #w -16 =12))
!! (PROCEDURE #OpenBuf* 136 #Texts.OpenBuf !25 (PROC 1 VOID
!!     (PARAM #B 12 =15)))
!! (PROCEDURE #FindPiece 141 #Texts.FindPiece !26 (PROC 4 VOID
!!     (PARAM #T 12 =8)
!!     (PARAM #pos 16 INTEGER)
!!     (VPARAM #org 20 INTEGER)
!!     (VPARAM #pce 24 =1))
!!   (LOCAL #p -4 =1)
!!   (LOCAL #porg -8 INTEGER))
!! (PROCEDURE #SplitPiece 155 #Texts.SplitPiece !27 (PROC 3 VOID
!!     (PARAM #p 12 =1)
!!     (PARAM #off 16 INTEGER)
!!     (VPARAM #pr 20 =1))
!!   (LOCAL #q -4 =1))
!! (PROCEDURE #Insert* 170 #Texts.Insert !28 (PROC 3 VOID
!!     (PARAM #T 12 =8)
!!     (PARAM #pos 16 INTEGER)
!!     (PARAM #B 20 =15))
!!   (LOCAL #pl -4 =1)
!!   (LOCAL #pr -8 =1)
!!   (LOCAL #p -12 =1)
!!   (LOCAL #qb -16 =1)
!!   (LOCAL #qe -20 =1)
!!   (LOCAL #org -24 INTEGER)
!!   (LOCAL #end -28 INTEGER))
!! (PROCEDURE #Append* 189 #Texts.Append !29 (PROC 2 VOID
!!     (PARAM #T 12 =8)
!!     (PARAM #B 16 =15)))
!! (PROCEDURE #OpenReader* 195 #Texts.OpenReader !30 (PROC 4 VOID
!!     (VPARAM #R 12 =11)
!!     (PARAM #T 20 =8)
!!     (PARAM #pos 24 INTEGER))
!!   (LOCAL #p -4 =1)
!!   (LOCAL #org -8 INTEGER))
!! (PROCEDURE #Read* 202 #Texts.Read !31 (PROC 3 VOID
!!     (VPARAM #R 12 =11)
!!     (VPARAM #ch 20 CHAR)))
!! (PROCEDURE #Pos* 213 #Texts.Pos !32 (PROC 2 INTEGER
!!     (VPARAM #R 12 =11)))
!! (PROCEDURE #OpenScanner* 219 #Texts.OpenScanner !33 (PROC 4 VOID
!!     (VPARAM #S 12 =13)
!!     (PARAM #T 20 =8)
!!     (PARAM #pos 24 INTEGER)))
!! (PROCEDURE #Ten* 227 #Texts.Ten !34 (PROC 1 REAL
!!     (PARAM #n 12 INTEGER))
!!   (LOCAL #t -4 REAL)
!!   (LOCAL #p -8 REAL))
!! (PROCEDURE #Scan* 237 #Texts.Scan !35 (PROC 2 VOID
!!     (VPARAM #S 12 =13))
!!   (CONST #maxExp INTCONST 38)
!!   (CONST #maxM INTCONST 16777216)
!!   (LOCAL #ch -1 CHAR)
!!   (LOCAL #neg -2 BOOLEAN)
!!   (LOCAL #negE -3 BOOLEAN)
!!   (LOCAL #hex -4 BOOLEAN)
!!   (LOCAL #i -8 INTEGER)
!!   (LOCAL #j -12 INTEGER)
!!   (LOCAL #d -16 INTEGER)
!!   (LOCAL #e -20 INTEGER)
!!   (LOCAL #s -24 INTEGER)
!!   (LOCAL #h -32 LONGINT)
!!   (LOCAL #n -40 LONGINT)
!!   (LOCAL #x -44 REAL))
!! (PROCEDURE #OpenWriter* 306 #Texts.OpenWriter !36 (PROC 2 VOID
!!     (VPARAM #W 12 =17)))
!! (PROCEDURE #Write* 312 #Texts.Write !37 (PROC 3 VOID
!!     (VPARAM #W 12 =17)
!!     (PARAM #ch 20 CHAR))
!!   (LOCAL #p -4 =1))
!! (PROCEDURE #WriteLn* 325 #Texts.WriteLn !38 (PROC 2 VOID
!!     (VPARAM #W 12 =17)))
!! (DEF !39 (FLEX CHAR))
!! (PROCEDURE #WriteString* 329 #Texts.WriteString !40 (PROC 4 VOID
!!     (VPARAM #W 12 =17)
!!     (CPARAM #s 20 =39))
!!   (LOCAL #i -4 INTEGER))
!! (PROCEDURE #WriteInt* 335 #Texts.WriteInt !41 (PROC 4 VOID
!!     (VPARAM #W 12 =17)
!!     (PARAM #x 20 INTEGER)
!!     (PARAM #n 24 INTEGER))
!!   (LOCAL #i -4 INTEGER)
!!   (LOCAL #x0 -8 INTEGER)
!!   (LOCAL #a -18 !42 (ARRAY 10 CHAR)))
!! (PROCEDURE #WriteHex* 351 #Texts.WriteHex !43 (PROC 3 VOID
!!     (VPARAM #W 12 =17)
!!     (PARAM #x 20 INTEGER))
!!   (LOCAL #i -4 INTEGER)
!!   (LOCAL #y -8 INTEGER)
!!   (LOCAL #a -18 !44 (ARRAY 10 CHAR)))
!! (PROCEDURE #WriteHexVLen* 362 #Texts.WriteHexVLen !45 (PROC 5 VOID
!!     (VPARAM #W 12 =17)
!!     (PARAM #x 20 INTEGER)
!!     (PARAM #n 24 INTEGER)
!!     (PARAM #leadingZero 28 BOOLEAN))
!!   (LOCAL #i -4 INTEGER)
!!   (LOCAL #y -8 INTEGER)
!!   (LOCAL #a -18 !46 (ARRAY 10 CHAR)))
!! (CHKSUM 0x04379426)
!! 
MODULE Texts 0x04379426 376
IMPORT POFiles 0x1834a231
ENDHDR

PROC Texts.Trailer 4 3 0x00010001
!   PROCEDURE Trailer(): Piece;
LINE 73
!   BEGIN NEW(Q);
LINE 75
CONST 24
GLOBAL Texts.PieceDesc
GLOBAL NEW
CALLW 2
STLW -4
!     Q.f := TrailerFile; Q.off := -1; Q.len := 1; Q.col := 0; RETURN Q
LINE 76
LDGW Texts.TrailerFile
LDLW -4
NCHECK 76
STOREW
CONST -1
LDLW -4
NCHECK 76
STNW 4
CONST 1
LDLW -4
NCHECK 76
STNW 8
CONST 0
LDLW -4
NCHECK 76
STNW 12
LDLW -4
RETURN
END

PROC Texts.Load 28 4 0x0051c401
!   PROCEDURE Load* (VAR R: Files.Rider; T: Text);
LINE 79
!   BEGIN f := Files.Base(R); Q := Trailer(); p := Q;
LINE 83
LDLW 16
LDLW 12
GLOBAL POFiles.Base
CALLW 2
STLW -28
GLOBAL Texts.Trailer
CALLW 0
STLW -4
LDLW -4
STLW -12
!     Files.ReadInt(R, off); Files.ReadInt(R, len);
LINE 84
LOCAL -16
LDLW 16
LDLW 12
GLOBAL POFiles.ReadInt
CALL 3
LOCAL -20
LDLW 16
LDLW 12
GLOBAL POFiles.ReadInt
CALL 3
LABEL L3
!     WHILE len # 0 DO
LINE 85
LDLW -20
JEQZ L5
!       NEW(q); q.len := len;
LINE 86
CONST 24
GLOBAL Texts.PieceDesc
GLOBAL NEW
CALLW 2
STLW -8
LDLW -20
LDLW -8
NCHECK 86
STNW 8
!       Files.ReadByte(R, bt); q.col := bt;
LINE 87
LOCAL -21
LDLW 16
LDLW 12
GLOBAL POFiles.ReadByte
CALL 3
LDLC -21
LDLW -8
NCHECK 87
STNW 12
!       q.f := f; q.off := off; off := off + q.len;
LINE 88
LDLW -28
LDLW -8
NCHECK 88
STOREW
LDLW -16
LDLW -8
NCHECK 88
STNW 4
LDLW -16
LDLW -8
NCHECK 88
LDNW 8
PLUS
STLW -16
!       p.next := q; q.prev := p; p := q; Files.ReadInt(R, len)
LINE 89
LDLW -8
LDLW -12
NCHECK 89
STNW 20
LDLW -12
LDLW -8
NCHECK 89
STNW 16
LDLW -8
STLW -12
LOCAL -20
LDLW 16
LDLW 12
GLOBAL POFiles.ReadInt
CALL 3
JUMP L3
LABEL L5
!     p.next := Q; Q.prev := p;
LINE 91
LDLW -4
LDLW -12
NCHECK 91
STNW 20
LDLW -12
LDLW -4
NCHECK 91
STNW 16
!     T.trailer := Q; Files.ReadInt(R, T.len); (*Files.Set(R, f, Files.Pos(R) + T.len)*)
LINE 92
LDLW -4
LDLW 20
NCHECK 92
STNW 12
LDLW 20
NCHECK 92
LDLW 16
LDLW 12
GLOBAL POFiles.ReadInt
CALL 3
RETURN
END

PROC Texts.Open 32 5 0x00319801
!   PROCEDURE Open* (T: Text; name: ARRAY OF CHAR);
LINE 95
!   BEGIN f := Files.Old(name);
LINE 98
LDLW 20
LDLW 16
GLOBAL POFiles.Old
CALLW 2
STLW -4
!     IF f # NIL THEN
LINE 99
LDLW -4
JEQZ L8
!       Files.Set(R, f, 0); Files.Read(R, tag); 
LINE 100
CONST 0
LDLW -4
GLOBAL POFiles.Rider
LOCAL -16
GLOBAL POFiles.Set
CALL 4
LOCAL -25
GLOBAL POFiles.Rider
LOCAL -16
GLOBAL POFiles.Read
CALL 3
!       IF tag = TextTag THEN Load(R, T)
LINE 101
LDLC -25
CONST 241
JNEQ L11
LDLW 12
GLOBAL POFiles.Rider
LOCAL -16
GLOBAL Texts.Load
CALL 3
JUMP L6
LABEL L11
!         len := Files.Length(f); Q := Trailer();
LINE 103
LDLW -4
GLOBAL POFiles.Length
CALLW 1
STLW -32
GLOBAL Texts.Trailer
CALLW 0
STLW -20
!         NEW(q); q.col := 0E3H; q.f := f; q.off := 0; q.len := len;
LINE 104
CONST 24
GLOBAL Texts.PieceDesc
GLOBAL NEW
CALLW 2
STLW -24
CONST 227
LDLW -24
NCHECK 104
STNW 12
LDLW -4
LDLW -24
NCHECK 104
STOREW
CONST 0
LDLW -24
NCHECK 104
STNW 4
LDLW -32
LDLW -24
NCHECK 104
STNW 8
!         Q.next := q; q.prev := Q; q.next := Q; Q.prev := q; T.trailer := Q; T.len := len
LINE 105
LDLW -24
LDLW -20
NCHECK 105
STNW 20
LDLW -20
LDLW -24
NCHECK 105
STNW 16
LDLW -20
LDLW -24
NCHECK 105
STNW 20
LDLW -24
LDLW -20
NCHECK 105
STNW 16
LDLW -20
LDLW 12
NCHECK 105
STNW 12
LDLW -32
LDLW 12
NCHECK 105
STOREW
JUMP L6
LABEL L8
!       Q := Trailer(); Q.next := Q; Q.prev := Q; T.trailer := Q; T.len := 0
LINE 108
GLOBAL Texts.Trailer
CALLW 0
STLW -20
LDLW -20
LDLW -20
NCHECK 108
STNW 20
LDLW -20
LDLW -20
NCHECK 108
STNW 16
LDLW -20
LDLW 12
NCHECK 108
STNW 12
CONST 0
LDLW 12
NCHECK 108
STOREW
LABEL L6
!     T.changed := FALSE; T.org := -1; T.pce := T.trailer (*init cache*)
LINE 110
CONST 0
LDLW 12
NCHECK 110
CONST 4
STIC
CONST -1
LDLW 12
NCHECK 110
STNW 20
LDLW 12
NCHECK 110
LDNW 12
LDLW 12
NCHECK 110
STNW 16
RETURN
END

PROC Texts.Store 24 6 0x00518001
!   PROCEDURE Store* (VAR W: Files.Rider; T: Text);
LINE 113
!   BEGIN p := T.trailer.next;
LINE 118
LDLW 20
NCHECK 118
LDNW 12
NCHECK 118
LDNW 20
STLW -4
LABEL L12
!     WHILE p # T.trailer DO
LINE 119
LDLW -4
LDLW 20
NCHECK 119
LDNW 12
JEQ L14
!       rlen := p.len; Files.Set(R, p.f, p.off);
LINE 120
LDLW -4
NCHECK 120
LDNW 8
STLW -20
LDLW -4
NCHECK 120
LDNW 4
LDLW -4
NCHECK 120
LOADW
GLOBAL POFiles.Rider
LOCAL -16
GLOBAL POFiles.Set
CALL 4
LABEL L15
!       WHILE rlen > 0 DO Files.Read(R, ch); Files.Write(W, ch); DEC(rlen) END ;
LINE 121
LDLW -20
JLEQZ L17
LOCAL -21
GLOBAL POFiles.Rider
LOCAL -16
GLOBAL POFiles.Read
CALL 3
LDLC -21
ALIGNC
LDLW 16
LDLW 12
GLOBAL POFiles.Write
CALL 3
DECL -20
JUMP L15
LABEL L17
!       p := p.next
LINE 122
LDLW -4
NCHECK 122
LDNW 20
STLW -4
JUMP L12
LABEL L14
!     T.changed := FALSE;
LINE 124
CONST 0
LDLW 20
NCHECK 124
CONST 4
STIC
!     IF T.notify # NIL THEN T.notify(T, unmark, 0, 0) END
LINE 125
LDLW 20
NCHECK 125
LDNW 8
JEQZ L20
CONST 0
CONST 0
CONST 3
LDLW 20
LDLW 20
NCHECK 125
LDNW 8
NCHECK 125
CALL 4
LABEL L20
RETURN
END

PROC Texts.Close 16 5 0x00318001
!   PROCEDURE Close*(T: Text; name: ARRAY OF CHAR);
LINE 128
!   BEGIN f := Files.New(name); Files.Set(w, f, 0);
LINE 130
LDLW 20
LDLW 16
GLOBAL POFiles.New
CALLW 2
STLW -4
CONST 0
LDLW -4
GLOBAL POFiles.Rider
LOCAL -16
GLOBAL POFiles.Set
CALL 4
!     Store(w, T); Files.Register(f)
LINE 131
LDLW 12
GLOBAL POFiles.Rider
LOCAL -16
GLOBAL Texts.Store
CALL 3
LDLW -4
GLOBAL POFiles.Register
CALL 1
RETURN
END

PROC Texts.OpenBuf 0 3 0x00100001
!   PROCEDURE OpenBuf* (B: Buffer);
LINE 136
!   BEGIN NEW(B.header); (*null piece*)
LINE 137
CONST 24
GLOBAL Texts.PieceDesc
GLOBAL NEW
CALLW 2
LDLW 12
NCHECK 137
STNW 4
!     B.last := B.header; B.len := 0
LINE 138
LDLW 12
NCHECK 138
LDNW 4
LDLW 12
NCHECK 138
STNW 8
CONST 0
LDLW 12
NCHECK 138
STOREW
RETURN
END

PROC Texts.FindPiece 8 4 0x00d10001
!   PROCEDURE FindPiece (T: Text; pos: INTEGER; VAR org: INTEGER; VAR pce: Piece);
LINE 141
!   BEGIN p := T.pce; porg := T.org;
LINE 143
LDLW 12
NCHECK 143
LDNW 16
STLW -4
LDLW 12
NCHECK 143
LDNW 20
STLW -8
!     IF pos >= porg THEN
LINE 144
LDLW 16
LDLW -8
JLT L26
!       IF  pos >= porg + p.len THEN REPEAT INC(porg, p.len); p := p.next UNTIL (pos < porg + p.len) OR (p = T.pce) END
LINE 145
LDLW 16
LDLW -8
LDLW -4
NCHECK 145
LDNW 8
PLUS
JLT L23
LABEL L30
LOCAL -8
DUP 0
LOADW
LDLW -4
NCHECK 145
LDNW 8
PLUS
SWAP
STOREW
LDLW -4
NCHECK 145
LDNW 20
STLW -4
LDLW 16
LDLW -8
LDLW -4
NCHECK 145
LDNW 8
PLUS
JLT L23
LDLW -4
LDLW 12
NCHECK 145
LDNW 16
JNEQ L30
JUMP L23
LABEL L26
!       REPEAT p := p.prev; DEC(porg, p.len) UNTIL (pos >= porg) OR (p = T.pce) 
LINE 148
LDLW -4
NCHECK 148
LDNW 16
STLW -4
LOCAL -8
DUP 0
LOADW
LDLW -4
NCHECK 148
LDNW 8
MINUS
SWAP
STOREW
LDLW 16
LDLW -8
JGEQ L23
LDLW -4
LDLW 12
NCHECK 148
LDNW 16
JNEQ L26
LABEL L23
!     T.pce := p; T.org := porg;  (*update cache*)
LINE 151
LDLW -4
LDLW 12
NCHECK 151
STNW 16
LDLW -8
LDLW 12
NCHECK 151
STNW 20
!     pce := p; org := porg
LINE 152
LDLW -4
LDLW 24
STOREW
LDLW -8
LDLW 20
STOREW
RETURN
END

PROC Texts.SplitPiece 4 3 0x00510001
!   PROCEDURE SplitPiece (p: Piece; off: INTEGER; VAR pr: Piece);
LINE 155
!     IF off > 0 THEN NEW(q);
LINE 158
LDLW 16
JLEQZ L35
CONST 24
GLOBAL Texts.PieceDesc
GLOBAL NEW
CALLW 2
STLW -4
!       q.col := p.col;
LINE 159
LDLW 12
NCHECK 159
LDNW 12
LDLW -4
NCHECK 159
STNW 12
!       q.len := p.len - off;
LINE 160
LDLW 12
NCHECK 160
LDNW 8
LDLW 16
MINUS
LDLW -4
NCHECK 160
STNW 8
!       q.f := p.f; q.off := p.off + off;
LINE 161
LDLW 12
NCHECK 161
LOADW
LDLW -4
NCHECK 161
STOREW
LDLW 12
NCHECK 161
LDNW 4
LDLW 16
PLUS
LDLW -4
NCHECK 161
STNW 4
!       p.len := off;
LINE 162
LDLW 16
LDLW 12
NCHECK 162
STNW 8
!       q.next := p.next; p.next := q;
LINE 163
LDLW 12
NCHECK 163
LDNW 20
LDLW -4
NCHECK 163
STNW 20
LDLW -4
LDLW 12
NCHECK 163
STNW 20
!       q.prev := p; q.next.prev := q;
LINE 164
LDLW 12
LDLW -4
NCHECK 164
STNW 16
LDLW -4
LDLW -4
NCHECK 164
LDNW 20
NCHECK 164
STNW 16
!       pr := q
LINE 165
LDLW -4
LDLW 20
STOREW
RETURN
LABEL L35
!     ELSE pr := p
LINE 166
LDLW 12
LDLW 20
STOREW
RETURN
END

PROC Texts.Insert 28 6 0x0051f001
!   PROCEDURE Insert* (T: Text; pos: INTEGER; B: Buffer);
LINE 170
!     FindPiece(T, pos, org, p); SplitPiece(p, pos - org, pr);
LINE 173
LOCAL -12
LOCAL -24
LDLW 16
LDLW 12
GLOBAL Texts.FindPiece
CALL 4
LOCAL -8
LDLW 16
LDLW -24
MINUS
LDLW -12
GLOBAL Texts.SplitPiece
CALL 3
!     IF T.org >= org THEN T.org := org - p.prev.len; T.pce := p.prev END ;
LINE 174
LDLW 12
NCHECK 174
LDNW 20
LDLW -24
JLT L38
LDLW -24
LDLW -12
NCHECK 174
LDNW 16
NCHECK 174
LDNW 8
MINUS
LDLW 12
NCHECK 174
STNW 20
LDLW -12
NCHECK 174
LDNW 16
LDLW 12
NCHECK 174
STNW 16
LABEL L38
!     pl := pr.prev; qb := B.header.next;
LINE 175
LDLW -8
NCHECK 175
LDNW 16
STLW -4
LDLW 20
NCHECK 175
LDNW 4
NCHECK 175
LDNW 20
STLW -16
!     IF (qb # NIL) & (qb.f = pl.f) & (qb.off = pl.off + pl.len)
LINE 176
LDLW -16
JEQZ L41
LDLW -16
NCHECK 176
LOADW
LDLW -4
NCHECK 176
LOADW
JNEQ L41
LDLW -16
NCHECK 176
LDNW 4
LDLW -4
NCHECK 176
LDNW 4
LDLW -4
NCHECK 176
LDNW 8
PLUS
JNEQ L41
LDLW -16
NCHECK 177
LDNW 12
LDLW -4
NCHECK 177
LDNW 12
JNEQ L41
!       pl.len := pl.len + qb.len; qb := qb.next
LINE 178
LDLW -4
NCHECK 178
LDNW 8
LDLW -16
NCHECK 178
LDNW 8
PLUS
LDLW -4
NCHECK 178
STNW 8
LDLW -16
NCHECK 178
LDNW 20
STLW -16
LABEL L41
!     IF qb # NIL THEN qe := B.last;
LINE 180
LDLW -16
JEQZ L47
LDLW 20
NCHECK 180
LDNW 8
STLW -20
!       qb.prev := pl; pl.next := qb; qe.next := pr; pr.prev := qe
LINE 181
LDLW -4
LDLW -16
NCHECK 181
STNW 16
LDLW -16
LDLW -4
NCHECK 181
STNW 20
LDLW -8
LDLW -20
NCHECK 181
STNW 20
LDLW -20
LDLW -8
NCHECK 181
STNW 16
LABEL L47
!     T.len := T.len + B.len; end := pos + B.len;
LINE 183
LDLW 12
NCHECK 183
LOADW
LDLW 20
NCHECK 183
LOADW
PLUS
LDLW 12
NCHECK 183
STOREW
LDLW 16
LDLW 20
NCHECK 183
LOADW
PLUS
STLW -28
!     B.last := B.header; B.last.next := NIL; B.len := 0;
LINE 184
LDLW 20
NCHECK 184
LDNW 4
LDLW 20
NCHECK 184
STNW 8
CONST 0
LDLW 20
NCHECK 184
LDNW 8
NCHECK 184
STNW 20
CONST 0
LDLW 20
NCHECK 184
STOREW
!     T.changed := TRUE;
LINE 185
CONST 1
LDLW 12
NCHECK 185
CONST 4
STIC
!     IF T.notify # NIL THEN  T.notify(T, insert, pos, end) END
LINE 186
LDLW 12
NCHECK 186
LDNW 8
JEQZ L50
LDLW -28
LDLW 16
CONST 1
LDLW 12
LDLW 12
NCHECK 186
LDNW 8
NCHECK 186
CALL 4
LABEL L50
RETURN
END

PROC Texts.Append 0 4 0x00300001
!   PROCEDURE Append* (T: Text; B: Buffer);
LINE 189
!   BEGIN Insert(T, T.len, B)
LINE 190
LDLW 16
LDLW 12
NCHECK 190
LOADW
LDLW 12
GLOBAL Texts.Insert
CALL 3
RETURN
END

PROC Texts.OpenReader 8 5 0x00510001
!   PROCEDURE OpenReader* (VAR R: Reader; T: Text; pos: INTEGER);
LINE 195
!   BEGIN FindPiece(T, pos, org, p);
LINE 197
LOCAL -4
LOCAL -8
LDLW 24
LDLW 20
GLOBAL Texts.FindPiece
CALL 4
!     R.ref := p; R.org := org; R.off := pos - org;
LINE 198
LDLW -4
LDLW 12
STNW 8
LDLW -8
LDLW 12
STNW 12
LDLW 24
LDLW -8
MINUS
LDLW 12
STNW 16
!     Files.Set(R.rider, p.f, p.off + R.off); R.eot := FALSE
LINE 199
LDLW -4
NCHECK 199
LDNW 4
LDLW 12
LDNW 16
PLUS
LDLW -4
NCHECK 199
LOADW
GLOBAL POFiles.Rider
LDLW 12
CONST 20
OFFSET
GLOBAL POFiles.Set
CALL 4
CONST 0
LDLW 12
STOREC
RETURN
END

PROC Texts.Read 0 5 0x00500001
!   PROCEDURE Read* (VAR R: Reader; VAR ch: CHAR);
LINE 202
!   BEGIN Files.Read(R.rider, ch);
LINE 203
LDLW 20
GLOBAL POFiles.Rider
LDLW 12
CONST 20
OFFSET
GLOBAL POFiles.Read
CALL 3
!     R.col := R.ref.col;
LINE 204
LDLW 12
LDNW 8
NCHECK 204
LDNW 12
LDLW 12
STNW 4
!     INC(R.off);
LINE 205
LDLW 12
DUP 0
LDNW 16
INC
SWAP
STNW 16
!     IF R.off = R.ref.len THEN
LINE 206
LDLW 12
LDNW 16
LDLW 12
LDNW 8
NCHECK 206
LDNW 8
JNEQ L53
!       IF R.ref.f = TrailerFile THEN R.eot := TRUE END;
LINE 207
LDLW 12
LDNW 8
NCHECK 207
LOADW
LDGW Texts.TrailerFile
JNEQ L56
CONST 1
LDLW 12
STOREC
LABEL L56
!       R.ref := R.ref.next; R.org := R.org + R.off; R.off := 0;
LINE 208
LDLW 12
LDNW 8
NCHECK 208
LDNW 20
LDLW 12
STNW 8
LDLW 12
LDNW 12
LDLW 12
LDNW 16
PLUS
LDLW 12
STNW 12
CONST 0
LDLW 12
STNW 16
!       Files.Set(R.rider, R.ref.f, R.ref.off)
LINE 209
LDLW 12
LDNW 8
NCHECK 209
LDNW 4
LDLW 12
LDNW 8
NCHECK 209
LOADW
GLOBAL POFiles.Rider
LDLW 12
CONST 20
OFFSET
GLOBAL POFiles.Set
CALL 4
LABEL L53
RETURN
END

PROC Texts.Pos 0 3 0x00100001
!   PROCEDURE Pos* (VAR R: Reader): INTEGER;
LINE 213
!   BEGIN RETURN R.org + R.off
LINE 214
LDLW 12
LDNW 12
LDLW 12
LDNW 16
PLUS
RETURN
END

PROC Texts.OpenScanner 0 5 0x00500001
!   PROCEDURE OpenScanner* (VAR S: Scanner; T: Text; pos: INTEGER);
LINE 219
!   BEGIN OpenReader(S, T, pos); S.line := 0; S.nextCh := " "
LINE 220
LDLW 24
LDLW 20
LDLW 16
LDLW 12
GLOBAL Texts.OpenReader
CALL 4
CONST 0
LDLW 12
STNW 36
CONST 32
LDLW 12
CONST 32
STIC
RETURN
END

PROC Texts.Ten 8 2 0
!   PROCEDURE Ten*(n: INTEGER): REAL;
LINE 227
!   BEGIN t := 1.0; p := 10.0;   (*compute 10^n *)
LINE 229
FCONST 1.0
STLF -4
FCONST 10.0
STLF -8
LABEL L57
!     WHILE n > 0 DO
LINE 230
LDLW 12
JLEQZ L59
!       IF ODD(n) THEN t := p * t END ;
LINE 231
LDLW 12
CONST 1
BITAND
JEQZ L62
LDLF -8
LDLF -4
FTIMES
STLF -4
LABEL L62
!       p := p*p; n := n DIV 2
LINE 232
LDLF -8
LDLF -8
FTIMES
STLF -8
LDLW 12
CONST 2
DIV
STLW 12
JUMP L57
LABEL L59
!     RETURN t
LINE 234
LDLF -4
RETURN
END

PROC Texts.Scan 44 4 0x00100001
!   PROCEDURE Scan* (VAR S: Scanner);
LINE 237
!   BEGIN ch := S.nextCh; i := 0;
LINE 243
LDLW 12
CONST 32
LDIC
STLC -1
CONST 0
STLW -8
LABEL L63
!     WHILE (ch = " ") OR (ch = TAB) OR (ch = CR) DO
LINE 244
LDLC -1
CONST 32
JEQ L64
LDLC -1
CONST 9
JEQ L64
LDLC -1
CONST 10
JNEQ L65
LABEL L64
!       IF ch = CR THEN INC(S.line) END ;
LINE 245
LDLC -1
CONST 10
JNEQ L68
LDLW 12
DUP 0
LDNW 36
INC
SWAP
STNW 36
LABEL L68
!       Read(S, ch)
LINE 246
LOCAL -1
LDLW 16
LDLW 12
GLOBAL Texts.Read
CALL 3
JUMP L63
LABEL L65
!     IF ("A" <= ch) & (ch <= "Z") OR ("a" <= ch) & (ch <= "z") THEN (*name*)
LINE 248
LDLC -1
CONST 65
JLT L154
LDLC -1
CONST 90
JLEQ L142
LABEL L154
LDLC -1
CONST 97
JLT L143
LDLC -1
CONST 122
JGT L143
LABEL L142
!       REPEAT S.s[i] := ch; INC(i); Read(S, ch)
LINE 249
LDLC -1
LDLW 12
CONST 64
OFFSET
LDLW -8
CONST 32
BOUND 249
STIC
INCL -8
LOCAL -1
LDLW 16
LDLW 12
GLOBAL Texts.Read
CALL 3
!       UNTIL ((ch # "_") & ((ch < "0") & (ch # ".") OR ("9" < ch) & (ch < "A") OR ("Z" < ch) & (ch < "a") OR ("z" < ch))) OR (i = 31);
LINE 250
LDLC -1
CONST 95
JEQ L146
LDLC -1
CONST 48
JGEQ L151
LDLC -1
CONST 46
JNEQ L145
LABEL L151
LDLC -1
CONST 57
JLEQ L149
LDLC -1
CONST 65
JLT L145
LABEL L149
LDLC -1
CONST 90
JLEQ L148
LDLC -1
CONST 97
JLT L145
LABEL L148
LDLC -1
CONST 122
JGT L145
LABEL L146
LDLW -8
CONST 31
JNEQ L142
LABEL L145
!       S.s[i] := 0X; S.len := i; S.class := Name
LINE 251
CONST 0
LDLW 12
CONST 64
OFFSET
LDLW -8
CONST 32
BOUND 251
STIC
LDLW -8
LDLW 12
STNW 60
CONST 1
LDLW 12
STNW 40
JUMP L76
LABEL L143
!     ELSIF ch = 22X THEN (*string*)
LINE 252
LDLC -1
CONST 34
JNEQ L158
!       Read(S, ch);
LINE 253
LOCAL -1
LDLW 16
LDLW 12
GLOBAL Texts.Read
CALL 3
LABEL L159
!       WHILE (ch # 22X) & (ch >= " ") & (i # 31) DO S.s[i] := ch; INC(i); Read(S, ch) END;
LINE 254
LDLC -1
CONST 34
JEQ L161
LDLC -1
CONST 32
JLT L161
LDLW -8
CONST 31
JEQ L161
LDLC -1
LDLW 12
CONST 64
OFFSET
LDLW -8
CONST 32
BOUND 254
STIC
INCL -8
LOCAL -1
LDLW 16
LDLW 12
GLOBAL Texts.Read
CALL 3
JUMP L159
LABEL L161
!       S.s[i] := 0X; S.len := i+1; Read(S, ch); S.class := String
LINE 255
CONST 0
LDLW 12
CONST 64
OFFSET
LDLW -8
CONST 32
BOUND 255
STIC
LDLW -8
INC
LDLW 12
STNW 60
LOCAL -1
LDLW 16
LDLW 12
GLOBAL Texts.Read
CALL 3
CONST 2
LDLW 12
STNW 40
JUMP L76
LABEL L158
!     ELSE hex := FALSE;
LINE 256
CONST 0
STLC -4
!       IF ch = "-" THEN neg := TRUE; Read(S, ch) ELSE neg := FALSE END ;
LINE 257
LDLC -1
CONST 45
JNEQ L74
CONST 1
STLC -2
LOCAL -1
LDLW 16
LDLW 12
GLOBAL Texts.Read
CALL 3
JUMP L72
LABEL L74
CONST 0
STLC -2
LABEL L72
!       IF ("0" <= ch) & (ch <= "9") THEN (*number*)
LINE 258
LDLC -1
CONST 48
JLT L80
LDLC -1
CONST 57
JGT L80
!         n := ORD(ch) - 30H; h := n; Read(S, ch);
LINE 259
LDLC -1
CONST 48
MINUS
CONVNQ
STLQ -40
LDLQ -40
STLQ -32
LOCAL -1
LDLW 16
LDLW 12
GLOBAL Texts.Read
CALL 3
LABEL L81
!         WHILE ("0" <= ch) & (ch <= "9") OR ("A" <= ch) & (ch <= "F") DO
LINE 260
LDLC -1
CONST 48
JLT L87
LDLC -1
CONST 57
JLEQ L82
LABEL L87
LDLC -1
CONST 65
JLT L83
LDLC -1
CONST 70
JGT L83
LABEL L82
!           IF ch <= "9" THEN d := ORD(ch) - 30H ELSE d := ORD(ch) - 37H; hex := TRUE END ;
LINE 261
LDLC -1
CONST 57
JGT L86
LDLC -1
CONST 48
MINUS
STLW -16
JUMP L84
LABEL L86
LDLC -1
CONST 55
MINUS
STLW -16
CONST 1
STLC -4
LABEL L84
!           n := n*10 + d; h := h*10H + d; Read(S, ch)
LINE 262
LDLQ -40
CONST 10
CONVNQ
QTIMES
LDLW -16
CONVNQ
QPLUS
STLQ -40
LDLQ -32
CONST 16
CONVNQ
QTIMES
LDLW -16
CONVNQ
QPLUS
STLQ -32
LOCAL -1
LDLW 16
LDLW 12
GLOBAL Texts.Read
CALL 3
JUMP L81
LABEL L83
!         IF ch = "H" THEN (*hex integer*) Read(S, ch);
LINE 264
LDLC -1
CONST 72
JNEQ L98
LOCAL -1
LDLW 16
LDLW 12
GLOBAL Texts.Read
CALL 3
!           S.i := h; S.class := Int  (*neg?*)
LINE 265
LDLQ -32
LDLW 12
CONST 44
OFFSET
STOREQ
CONST 3
LDLW 12
STNW 40
JUMP L76
LABEL L98
!         ELSIF ch = "." THEN (*real number*)
LINE 266
LDLC -1
CONST 46
JNEQ L100
!           Read(S, ch); x := 0.0; e := 0; j := 0;
LINE 267
LOCAL -1
LDLW 16
LDLW 12
GLOBAL Texts.Read
CALL 3
FCONST 0.0
STLF -44
CONST 0
STLW -20
CONST 0
STLW -12
LABEL L101
!           WHILE ("0" <= ch) & (ch <= "9") DO  (*fraction*)
LINE 268
LDLC -1
CONST 48
JLT L103
LDLC -1
CONST 57
JGT L103
!             h := n*10 + (ORD(ch) - 30H);
LINE 269
LDLQ -40
CONST 10
CONVNQ
QTIMES
LDLC -1
CONST 48
MINUS
CONVNQ
QPLUS
STLQ -32
!             IF h < maxM THEN n := h; INC(j) END ;
LINE 270
LDLQ -32
QCONST 16777216
QJGEQ L106
LDLQ -32
STLQ -40
INCL -12
LABEL L106
!             Read(S, ch)
LINE 271
LOCAL -1
LDLW 16
LDLW 12
GLOBAL Texts.Read
CALL 3
JUMP L101
LABEL L103
!           IF ch = "E" THEN (*scale factor*)
LINE 273
LDLC -1
CONST 69
JNEQ L110
!             s := 0; Read(S, ch);
LINE 274
CONST 0
STLW -24
LOCAL -1
LDLW 16
LDLW 12
GLOBAL Texts.Read
CALL 3
!             IF ch = "-" THEN negE := TRUE; Read(S, ch)
LINE 275
LDLC -1
CONST 45
JNEQ L116
CONST 1
STLC -3
LOCAL -1
LDLW 16
LDLW 12
GLOBAL Texts.Read
CALL 3
JUMP L114
LABEL L116
!             ELSE negE := FALSE;
LINE 276
CONST 0
STLC -3
!               IF ch = "+" THEN Read(S, ch) END
LINE 277
LDLC -1
CONST 43
JNEQ L114
LOCAL -1
LDLW 16
LDLW 12
GLOBAL Texts.Read
CALL 3
LABEL L114
!             WHILE ("0" <= ch) & (ch <= "9") DO
LINE 279
LDLC -1
CONST 48
JLT L119
LDLC -1
CONST 57
JGT L119
!               s := s*10 + ORD(ch) - 30H; Read(S, ch)
LINE 280
LDLW -24
CONST 10
TIMES
LDLC -1
PLUS
CONST 48
MINUS
STLW -24
LOCAL -1
LDLW 16
LDLW 12
GLOBAL Texts.Read
CALL 3
JUMP L114
LABEL L119
!             IF negE THEN DEC(e, s) ELSE INC(e, s) END ;
LINE 282
LDLC -3
JEQZ L123
LOCAL -20
DUP 0
LOADW
LDLW -24
MINUS
SWAP
STOREW
JUMP L110
LABEL L123
LOCAL -20
DUP 0
LOADW
LDLW -24
PLUS
SWAP
STOREW
LABEL L110
!           x := FLT(n); DEC(e, j);
LINE 284
LDLQ -40
CONVQN
CONVNF
STLF -44
LOCAL -20
DUP 0
LOADW
LDLW -12
MINUS
SWAP
STOREW
!           IF e < 0 THEN
LINE 285
LDLW -20
JGEQZ L126
!             IF e >= -maxExp THEN x := x / Ten(-e) ELSE x := 0.0 END
LINE 286
LDLW -20
CONST -38
JLT L129
LDLF -44
LDLW -20
UMINUS
GLOBAL Texts.Ten
CALLF 1
FZCHECK 286
FDIV
STLF -44
JUMP L131
LABEL L129
FCONST 0.0
STLF -44
JUMP L131
LABEL L126
!           ELSIF e > 0 THEN
LINE 287
LDLW -20
JLEQZ L131
!             IF e <= maxExp THEN x := Ten(e) * x ELSE x := 0.0 END
LINE 288
LDLW -20
CONST 38
JGT L134
LDLW -20
GLOBAL Texts.Ten
CALLF 1
LDLF -44
FTIMES
STLF -44
JUMP L131
LABEL L134
FCONST 0.0
STLF -44
LABEL L131
!           IF neg THEN S.x := -x ELSE S.x := x END ;
LINE 290
LDLC -2
JEQZ L137
LDLF -44
FUMINUS
LDLW 12
CONST 13
STIF
JUMP L135
LABEL L137
LDLF -44
LDLW 12
CONST 13
STIF
LABEL L135
!           IF hex THEN S.class := 0 ELSE S.class := Real END
LINE 291
LDLC -4
JEQZ L140
CONST 0
LDLW 12
STNW 40
JUMP L76
LABEL L140
CONST 4
LDLW 12
STNW 40
JUMP L76
LABEL L100
!           IF neg THEN n := -n END;
LINE 293
LDLC -2
JEQZ L93
LDLQ -40
QUMINUS
STLQ -40
LABEL L93
!           S.class := Int; S.i := n;
LINE 294
CONST 3
LDLW 12
STNW 40
LDLQ -40
LDLW 12
CONST 44
OFFSET
STOREQ
!           IF hex THEN S.class := Inval END
LINE 295
LDLC -4
JEQZ L76
CONST 0
LDLW 12
STNW 40
JUMP L76
LABEL L80
!       ELSE (*special character*) S.class := Char;
LINE 297
CONST 6
LDLW 12
STNW 40
!         IF neg THEN S.c := "-" ELSE S.c := ch; Read(S, ch) END
LINE 298
LDLC -2
JEQZ L78
CONST 45
LDLW 12
CONST 56
STIC
JUMP L76
LABEL L78
LDLC -1
LDLW 12
CONST 56
STIC
LOCAL -1
LDLW 16
LDLW 12
GLOBAL Texts.Read
CALL 3
LABEL L76
!     S.nextCh := ch
LINE 301
LDLC -1
LDLW 12
CONST 32
STIC
RETURN
END

PROC Texts.OpenWriter 0 5 0x00100001
!   PROCEDURE OpenWriter* (VAR W: Writer);
LINE 306
!   BEGIN NEW(W.buf);
LINE 307
CONST 12
GLOBAL Texts.BufDesc
GLOBAL NEW
CALLW 2
LDLW 12
STOREW
!     OpenBuf(W.buf); W.col := 1FH;
LINE 308
LDLW 12
LOADW
GLOBAL Texts.OpenBuf
CALL 1
CONST 31
LDLW 12
STNW 4
!     Files.Set(W.rider, Files.New(""), 0)
LINE 309
CONST 0
CONST 1
GLOBAL Texts.%1
GLOBAL POFiles.New
CALLW 2
GLOBAL POFiles.Rider
LDLW 12
CONST 8
OFFSET
GLOBAL POFiles.Set
CALL 4
RETURN
END

PROC Texts.Write 4 4 0x00110001
!   PROCEDURE Write* (VAR W: Writer; ch: CHAR);
LINE 312
!     IF W.buf.last.col # W.col THEN
LINE 315
LDLW 12
LOADW
NCHECK 315
LDNW 8
NCHECK 315
LDNW 12
LDLW 12
LDNW 4
JEQ L166
!       NEW(p); p.f := Files.Base(W.rider); p.off := Files.Pos(W.rider); p.len := 0;
LINE 316
CONST 24
GLOBAL Texts.PieceDesc
GLOBAL NEW
CALLW 2
STLW -4
GLOBAL POFiles.Rider
LDLW 12
CONST 8
OFFSET
GLOBAL POFiles.Base
CALLW 2
LDLW -4
NCHECK 316
STOREW
GLOBAL POFiles.Rider
LDLW 12
CONST 8
OFFSET
GLOBAL POFiles.Pos
CALLW 2
LDLW -4
NCHECK 316
STNW 4
CONST 0
LDLW -4
NCHECK 316
STNW 8
!       p.col := W.col;
LINE 317
LDLW 12
LDNW 4
LDLW -4
NCHECK 317
STNW 12
!       p.next := NIL; W.buf.last.next := p;
LINE 318
CONST 0
LDLW -4
NCHECK 318
STNW 20
LDLW -4
LDLW 12
LOADW
NCHECK 318
LDNW 8
NCHECK 318
STNW 20
!       p.prev := W.buf.last; W.buf.last := p
LINE 319
LDLW 12
LOADW
NCHECK 319
LDNW 8
LDLW -4
NCHECK 319
STNW 16
LDLW -4
LDLW 12
LOADW
NCHECK 319
STNW 8
LABEL L166
!     Files.Write(W.rider, ch);
LINE 321
LDLC 20
ALIGNC
GLOBAL POFiles.Rider
LDLW 12
CONST 8
OFFSET
GLOBAL POFiles.Write
CALL 3
!     INC(W.buf.last.len); INC(W.buf.len)
LINE 322
LDLW 12
LOADW
NCHECK 322
LDNW 8
NCHECK 322
DUP 0
LDNW 8
INC
SWAP
STNW 8
LDLW 12
LOADW
NCHECK 322
DUP 0
LOADW
INC
SWAP
STOREW
RETURN
END

PROC Texts.WriteLn 0 4 0x00100001
!   PROCEDURE WriteLn* (VAR W: Writer);
LINE 325
!   BEGIN Write(W, CR)
LINE 326
CONST 10
ALIGNC
LDLW 16
LDLW 12
GLOBAL Texts.Write
CALL 3
RETURN
END

PROC Texts.WriteString 4 4 0x00500001
!   PROCEDURE WriteString* (VAR W: Writer; s: ARRAY OF CHAR);
LINE 329
!   BEGIN i := 0;
LINE 331
CONST 0
STLW -4
LABEL L167
!     WHILE s[i] >= " " DO Write(W, s[i]); INC(i) END
LINE 332
LDLW 20
LDLW -4
LDLW 24
BOUND 332
LDIC
CONST 32
JLT L169
LDLW 20
LDLW -4
LDLW 24
BOUND 332
LDIC
ALIGNC
LDLW 16
LDLW 12
GLOBAL Texts.Write
CALL 3
INCL -4
JUMP L167
LABEL L169
RETURN
END

PROC Texts.WriteInt 20 5 0x00100001
!   PROCEDURE WriteInt* (VAR W: Writer; x, n: INTEGER);
LINE 335
!     IF ROR(x, 31) = 1 THEN WriteString(W, " -2147483648")
LINE 339
LDLW 20
CONST 31
ROR
CONST 1
JNEQ L185
CONST 13
GLOBAL Texts.%2
LDLW 16
LDLW 12
GLOBAL Texts.WriteString
CALL 4
RETURN
LABEL L185
!     ELSE i := 0;
LINE 340
CONST 0
STLW -4
!       IF x < 0 THEN DEC(n); x0 := -x ELSE x0 := x END;
LINE 341
LDLW 20
JGEQZ L173
DECL 24
LDLW 20
UMINUS
STLW -8
JUMP L171
LABEL L173
LDLW 20
STLW -8
LABEL L171
!         a[i] := CHR(x0 MOD 10 + 30H); x0 := x0 DIV 10; INC(i)
LINE 343
LDLW -8
CONST 10
MOD
CONST 48
PLUS
CONVNC
LOCAL -18
LDLW -4
CONST 10
BOUND 343
STIC
LDLW -8
CONST 10
DIV
STLW -8
INCL -4
!       UNTIL x0 = 0;
LINE 344
LDLW -8
JNEQZ L171
LABEL L176
!       WHILE n > i DO Write(W, " "); DEC(n) END;
LINE 345
LDLW 24
LDLW -4
JLEQ L178
CONST 32
ALIGNC
LDLW 16
LDLW 12
GLOBAL Texts.Write
CALL 3
DECL 24
JUMP L176
LABEL L178
!       IF x < 0 THEN Write(W, "-") END;
LINE 346
LDLW 20
JGEQZ L181
CONST 45
ALIGNC
LDLW 16
LDLW 12
GLOBAL Texts.Write
CALL 3
LABEL L181
!       REPEAT DEC(i); Write(W, a[i]) UNTIL i = 0
LINE 347
DECL -4
LOCAL -18
LDLW -4
CONST 10
BOUND 347
LDIC
ALIGNC
LDLW 16
LDLW 12
GLOBAL Texts.Write
CALL 3
LDLW -4
JNEQZ L181
RETURN
END

PROC Texts.WriteHex 20 4 0x00100001
!   PROCEDURE WriteHex* (VAR W: Writer; x: INTEGER);
LINE 351
!   BEGIN i := 0; Write(W, " ");
LINE 354
CONST 0
STLW -4
CONST 32
ALIGNC
LDLW 16
LDLW 12
GLOBAL Texts.Write
CALL 3
LABEL L186
!     REPEAT y := x MOD 10H;
LINE 355
LDLW 20
CONST 16
MOD
STLW -8
!       IF y < 10 THEN a[i] := CHR(y + 30H) ELSE a[i] := CHR(y + 37H) END;
LINE 356
LDLW -8
CONST 10
JGEQ L190
LDLW -8
CONST 48
PLUS
CONVNC
LOCAL -18
LDLW -4
CONST 10
BOUND 356
STIC
JUMP L188
LABEL L190
LDLW -8
CONST 55
PLUS
CONVNC
LOCAL -18
LDLW -4
CONST 10
BOUND 356
STIC
LABEL L188
!       x := x DIV 10H; INC(i)
LINE 357
LDLW 20
CONST 16
DIV
STLW 20
INCL -4
!     UNTIL i = 8;
LINE 358
LDLW -4
CONST 8
JNEQ L186
LABEL L191
!     REPEAT DEC(i); Write(W, a[i]) UNTIL i = 0
LINE 359
DECL -4
LOCAL -18
LDLW -4
CONST 10
BOUND 359
LDIC
ALIGNC
LDLW 16
LDLW 12
GLOBAL Texts.Write
CALL 3
LDLW -4
JNEQZ L191
RETURN
END

PROC Texts.WriteHexVLen 20 4 0x00100001
!   PROCEDURE WriteHexVLen*(VAR W: Writer; x, n: INTEGER; leadingZero: BOOLEAN);
LINE 362
!   BEGIN ASSERT(n<=10);
LINE 365
LDLW 24
CONST 10
JLEQ L194
CONST 0
CONST 365
GLOBAL EASSERT
CALL 2
LABEL L194
!     i := 0; Write(W, " ");
LINE 366
CONST 0
STLW -4
CONST 32
ALIGNC
LDLW 16
LDLW 12
GLOBAL Texts.Write
CALL 3
LABEL L195
!     REPEAT y := x MOD 10H;
LINE 367
LDLW 20
CONST 16
MOD
STLW -8
!       IF y < 10 THEN a[i] := CHR(y + 30H) ELSE a[i] := CHR(y + 37H) END;
LINE 368
LDLW -8
CONST 10
JGEQ L200
LDLW -8
CONST 48
PLUS
CONVNC
LOCAL -18
LDLW -4
CONST 10
BOUND 368
STIC
JUMP L198
LABEL L200
LDLW -8
CONST 55
PLUS
CONVNC
LOCAL -18
LDLW -4
CONST 10
BOUND 368
STIC
LABEL L198
!       x := x DIV 10H; IF x < 0 THEN INC(x, 10000000H) END; INC(i)
LINE 369
LDLW 20
CONST 16
DIV
STLW 20
LDLW 20
JGEQZ L203
LDLW 20
CONST 268435456
PLUS
STLW 20
LABEL L203
INCL -4
!     UNTIL (i >= n) & (x = 0);
LINE 370
LDLW -4
LDLW 24
JLT L195
LDLW 20
JNEQZ L195
!     IF leadingZero & (a[i-1] > "9") THEN Write(W, "0") END; (*Add a leading 0 if first hex digit is a letter*)
LINE 371
LDLC 28
JEQZ L206
LOCAL -18
LDLW -4
DEC
CONST 10
BOUND 371
LDIC
CONST 57
JLEQ L206
CONST 48
ALIGNC
LDLW 16
LDLW 12
GLOBAL Texts.Write
CALL 3
LABEL L206
!     REPEAT DEC(i); Write(W, a[i]) UNTIL i = 0
LINE 372
DECL -4
LOCAL -18
LDLW -4
CONST 10
BOUND 372
LDIC
ALIGNC
LDLW 16
LDLW 12
GLOBAL Texts.Write
CALL 3
LDLW -4
JNEQZ L206
RETURN
END

PROC Texts.%main 0 3 0
! BEGIN TrailerFile := Files.New("")
LINE 375
CONST 1
GLOBAL Texts.%1
GLOBAL POFiles.New
CALLW 2
STGW Texts.TrailerFile
RETURN
END

! Global variables
GLOVAR Texts.TrailerFile 4

! Global pointer map
DEFINE Texts.%gcmap
WORD GC_POINTER
WORD Texts.TrailerFile
WORD GC_END

! String ""
DEFINE Texts.%1
STRING 00

! String " -2147483648"
DEFINE Texts.%2
STRING 202D3231343734383336343800

! Descriptor for PieceDesc
DEFINE Texts.PieceDesc
WORD 0x00000063
WORD 0
WORD Texts.PieceDesc.%anc

DEFINE Texts.PieceDesc.%anc
WORD Texts.PieceDesc

! Descriptor for TextDesc
DEFINE Texts.TextDesc
WORD 0x00000031
WORD 0
WORD Texts.TextDesc.%anc

DEFINE Texts.TextDesc.%anc
WORD Texts.TextDesc

! Descriptor for Reader
DEFINE Texts.Reader
WORD 0x00000109
WORD 0
WORD Texts.Reader.%anc

DEFINE Texts.Reader.%anc
WORD Texts.Reader

! Descriptor for Scanner
DEFINE Texts.Scanner
WORD 0x00000109
WORD 1
WORD Texts.Scanner.%anc

DEFINE Texts.Scanner.%anc
WORD Texts.Reader
WORD Texts.Scanner

! Descriptor for BufDesc
DEFINE Texts.BufDesc
WORD 0x0000000d
WORD 0
WORD Texts.BufDesc.%anc

DEFINE Texts.BufDesc.%anc
WORD Texts.BufDesc

! Descriptor for Writer
DEFINE Texts.Writer
WORD 0x00000023
WORD 0
WORD Texts.Writer.%anc

DEFINE Texts.Writer.%anc
WORD Texts.Writer

! End of file
