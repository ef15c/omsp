!! (SYMFILE #OMSPA 0x00030300 #OMSPA.%main 1 #OMSPA.Mod)
!! (CONST #maxCode* INTCONST 32000)
!! (CONST #PC* INTCONST 0)
!! (CONST #SP* INTCONST 1)
!! (CONST #SR* INTCONST 2)
!! (CONST #CG1* INTCONST 2)
!! (CONST #CG2* INTCONST 3)
!! (CONST #NE* INTCONST 0)
!! (CONST #EQ* INTCONST 1)
!! (CONST #NC* INTCONST 2)
!! (CONST #C* INTCONST 3)
!! (CONST #N* INTCONST 4)
!! (CONST #GE* INTCONST 5)
!! (CONST #L* INTCONST 6)
!! (CONST #AL* INTCONST 7)
!! (CONST #NV* INTCONST 8)
!! (CONST #Rm* SET 0)
!! (CONST #Im* SET 16)
!! (CONST #IRm* SET 32)
!! (CONST #IRAm* SET 48)
!! (CONST #Rdm* SET 0)
!! (CONST #Idm* SET 128)
!! (CONST #Register* INTCONST 0)
!! (CONST #Indexed* INTCONST 1)
!! (CONST #Symbolic* INTCONST 2)
!! (CONST #Absolute* INTCONST 3)
!! (CONST #Indirect* INTCONST 4)
!! (CONST #IndirectIncr* INTCONST 5)
!! (CONST #Immediate* INTCONST 6)
!! (CONST #Undefined* INTCONST 255)
!! (CONST #Byte* SET 64)
!! (CONST #Word* SET 0)
!! (CONST #EmitOffset* SET 65536)
!! (CONST #JMPh* INTCONST 32)
!! (CONST #MOV* INTCONST 4)
!! (CONST #ADD* INTCONST 5)
!! (CONST #ADDC* INTCONST 6)
!! (CONST #SUBC* INTCONST 7)
!! (CONST #SUB* INTCONST 8)
!! (CONST #CMP* INTCONST 9)
!! (CONST #DADD* INTCONST 10)
!! (CONST #BIT* INTCONST 11)
!! (CONST #BIC* INTCONST 12)
!! (CONST #BIS* INTCONST 13)
!! (CONST #XOR* INTCONST 14)
!! (CONST #AND* INTCONST 15)
!! (CONST #RRC* INTCONST 32)
!! (CONST #SWPB* INTCONST 33)
!! (CONST #RRA* INTCONST 34)
!! (CONST #SXT* INTCONST 35)
!! (CONST #PUSH* INTCONST 36)
!! (CONST #CALL* INTCONST 37)
!! (CONST #RETI* INTCONST 38)
!! (CONST #POP* INTCONST 256)
!! (CONST #RLA* INTCONST 257)
!! (CONST #RLC* INTCONST 258)
!! (CONST #NOP0* INTCONST 259)
!! (CONST #RET* INTCONST 384)
!! (CONST #CLRC* INTCONST 385)
!! (CONST #MUL* INTCONST 0)
!! (CONST #NEG* INTCONST 1)
!! (CONST #DIv* INTCONST 2)
!! (CONST #MOd* INTCONST 3)
!! (TYPE #ModuleCode* !1 (RECORD #OMSPA.ModuleCode 32004 VOID
!!     (FIELD #pc* 0 INTEGER)
!!     (FIELD #code* 4 !2 (ARRAY 32000 BYTE))))
!! (TYPE #Item* !3 (RECORD #OMSPA.Item 8 VOID
!!     (FIELD #reg* 0 BYTE)
!!     (FIELD #am* 1 BYTE)
!!     (FIELD #ofs* 4 INTEGER)))
!! (TYPE #GetOffsetProc* !4 (PROC 2 INTEGER
!!     (VPARAM #x 12 =3)))
!! (TYPE #AllocRegisterProc* !5 (PROC 0 INTEGER))
!! (TYPE #FreeRegisterProc* !6 (PROC 1 VOID
!!     (PARAM #r 12 INTEGER)))
!! (TYPE #SetFlagsCurrentItemProc* !7 (PROC 3 VOID
!!     (VPARAM #x 12 =3)
!!     (PARAM #state 20 BOOLEAN)))
!! (GLOBAL #getOfs #OMSPA.getOfs =4)
!! (GLOBAL #allocR #OMSPA.allocR =5)
!! (GLOBAL #freeR #OMSPA.freeR =6)
!! (GLOBAL #setFCI #OMSPA.setFCI =7)
!! (GLOBAL #enabled- #OMSPA.enabled BOOLEAN)
!! (GLOBAL #PutSO0 #OMSPA.PutSO0 !8 (PROC 6 VOID
!!     (VPARAM #c 12 =1)
!!     (PARAM #op 20 INTEGER)
!!     (VPARAM #ds 24 =3)
!!     (PARAM #params 32 SET)))
!! (PROCEDURE #SetProcs* 90 #OMSPA.SetProcs !9 (PROC 8 VOID
!!     (PARAM #ofsp 12 =4)
!!     (PARAM #ar 20 =5)
!!     (PARAM #fr 28 =6)
!!     (PARAM #sfci 36 =7)))
!! (PROCEDURE #log2* 94 #OMSPA.log2 !10 (PROC 2 INTEGER
!!     (PARAM #m 12 INTEGER)
!!     (VPARAM #e 16 INTEGER)))
!! (PROCEDURE #SetEnabled* 100 #OMSPA.SetEnabled !11 (PROC 1 VOID
!!     (PARAM #e 12 BOOLEAN)))
!! (PROCEDURE #GetWordAt* 106 #OMSPA.GetWordAt !12 (PROC 3 INTEGER
!!     (VPARAM #c 12 =1)
!!     (PARAM #at 20 INTEGER)))
!! (PROCEDURE #PutWordAt* 110 #OMSPA.PutWordAt !13 (PROC 4 VOID
!!     (VPARAM #c 12 =1)
!!     (PARAM #at 20 INTEGER)
!!     (PARAM #val 24 INTEGER)))
!! (PROCEDURE #Emit* 116 #OMSPA.Emit !14 (PROC 3 VOID
!!     (VPARAM #c 12 =1)
!!     (PARAM #val 20 INTEGER)))
!! (PROCEDURE #encSrc 121 #OMSPA.encSrc !15 (PROC 6 VOID
!!     (VPARAM #op 12 INTEGER)
!!     (VPARAM #SReg 16 BYTE)
!!     (PARAM #sam 20 BYTE)
!!     (VPARAM #SOff 24 INTEGER)
!!     (VPARAM #emitSOff 28 BOOLEAN)
!!     (VPARAM #params 32 SET)))
!! (PROCEDURE #Put1 150 #OMSPA.Put1 !16 (PROC 6 VOID
!!     (VPARAM #c 12 =1)
!!     (PARAM #op 20 BYTE)
!!     (PARAM #src 24 BYTE)
!!     (PARAM #dst 28 BYTE)
!!     (PARAM #params 32 SET)))
!! (PROCEDURE #PutDO* 159 #OMSPA.PutDO !17 (PROC 8 VOID
!!     (VPARAM #c 12 =1)
!!     (PARAM #op 20 INTEGER)
!!     (VPARAM #s 24 =3)
!!     (VPARAM #d 32 =3)
!!     (PARAM #params 40 SET))
!!   (LOCAL #emitSOff -1 BOOLEAN)
!!   (LOCAL #emitDOff -2 BOOLEAN)
!!   (LOCAL #t -12 =3)
!!   (LOCAL #ts -20 =3)
!!   (LOCAL #td -28 =3)
!!   (LOCAL #e -32 INTEGER))
!! (PROCEDURE #Put2 211 #OMSPA.Put2 !18 (PROC 5 VOID
!!     (VPARAM #c 12 =1)
!!     (PARAM #op 20 BYTE)
!!     (PARAM #register 24 BYTE)
!!     (PARAM #params 28 SET)))
!! (PROCEDURE #PutSO* 220 #OMSPA.PutSO !19 (PROC 6 VOID
!!     (VPARAM #c 12 =1)
!!     (PARAM #op 20 INTEGER)
!!     (VPARAM #ds 24 =3)
!!     (PARAM #params 32 SET))
!!   (LOCAL #emitDSOff -1 BOOLEAN)
!!   (LOCAL #spi -12 =3)
!!   (LOCAL #t -20 =3)
!!   (LOCAL #tds -28 =3))
!! (PROCEDURE #PutJ* 247 #OMSPA.PutJ !20 (PROC 4 VOID
!!     (VPARAM #c 12 =1)
!!     (PARAM #cond 20 BYTE)
!!     (PARAM #offset 24 INTEGER))
!!   (LOCAL #dummy -8 =3))
!! (PROCEDURE #PutNO* 261 #OMSPA.PutNO !21 (PROC 3 VOID
!!     (VPARAM #c 12 =1)
!!     (PARAM #op 20 INTEGER))
!!   (LOCAL #dummy -8 =3))
!! (PROCEDURE #negated* 273 #OMSPA.negated !22 (PROC 1 INTEGER
!!     (PARAM #cond 12 INTEGER)))
!! (PROCEDURE #fix* 282 #OMSPA.fix !23 (PROC 4 VOID
!!     (VPARAM #c 12 =1)
!!     (PARAM #at 20 INTEGER)
!!     (PARAM #with 24 INTEGER)))
!! (PROCEDURE #FixOne* 296 #OMSPA.FixOne !24 (PROC 3 VOID
!!     (VPARAM #c 12 =1)
!!     (PARAM #at 20 INTEGER)))
!! (PROCEDURE #merged* 301 #OMSPA.merged !25 (PROC 4 INTEGER
!!     (VPARAM #c 12 =1)
!!     (PARAM #L0 20 INTEGER)
!!     (PARAM #L1 24 INTEGER))
!!   (LOCAL #L2 -4 INTEGER)
!!   (LOCAL #L3 -8 INTEGER))
!! (PROCEDURE #PushRegs* 317 #OMSPA.PushRegs !26 (PROC 3 INTEGER
!!     (VPARAM #c 12 =1)
!!     (PARAM #regs 20 SET))
!!   (LOCAL #n -4 INTEGER)
!!   (LOCAL #i -8 INTEGER)
!!   (LOCAL #t -16 =3))
!! (PROCEDURE #PopRegs* 324 #OMSPA.PopRegs !27 (PROC 3 INTEGER
!!     (VPARAM #c 12 =1)
!!     (PARAM #regs 20 SET))
!!   (LOCAL #i -4 INTEGER)
!!   (LOCAL #n -8 INTEGER)
!!   (LOCAL #t -16 =3))
!! (PROCEDURE #Init* 331 #OMSPA.Init !28 (PROC 2 VOID
!!     (VPARAM #c 12 =1)))
!! (CHKSUM 0x18385547)
!! 
MODULE OMSPA 0x18385547 336
IMPORT OMSPS 0x669fb75e
ENDHDR

PROC OMSPA.SetProcs 0 2 0
!   PROCEDURE SetProcs*(ofsp: GetOffsetProc; ar: AllocRegisterProc; fr: FreeRegisterProc; sfci: SetFlagsCurrentItemProc);
LINE 90
!   BEGIN getOfs := ofsp; allocR := ar; freeR := fr; setFCI := sfci
LINE 91
LDLW 16
GCHECK 91
LDLW 12
STGW OMSPA.getOfs
LDLW 24
GCHECK 91
LDLW 20
STGW OMSPA.allocR
LDLW 32
GCHECK 91
LDLW 28
STGW OMSPA.freeR
LDLW 40
GCHECK 91
LDLW 36
STGW OMSPA.setFCI
RETURN
END

PROC OMSPA.log2 0 3 0x00200001
!   PROCEDURE log2*(m: INTEGER; VAR e: INTEGER): INTEGER;
LINE 94
!   BEGIN e := 0;
LINE 95
CONST 0
LDLW 16
STOREW
LABEL L6
!     WHILE ~ODD(m) DO m := LSR(m, 1); INC(e); END;
LINE 96
LDLW 12
CONST 1
BITAND
JNEQZ L8
LDLW 12
CONST 1
LSR
STLW 12
LDLW 16
DUP 0
LOADW
INC
SWAP
STOREW
JUMP L6
LABEL L8
!     RETURN m
LINE 97
LDLW 12
RETURN
END

PROC OMSPA.SetEnabled 0 2 0
!   PROCEDURE SetEnabled*(e: BOOLEAN);
LINE 100
!   BEGIN enabled := e
LINE 101
LDLC 12
STGC OMSPA.enabled
RETURN
END

PROC OMSPA.GetWordAt 0 4 0x00100001
!   PROCEDURE GetWordAt*(VAR c: ModuleCode; at: INTEGER): INTEGER;
LINE 106
!     RETURN 0 + c.code[at] + c.code[at + 1] * 100H
LINE 107
LDLW 12
CONST 4
OFFSET
LDLW 20
CONST 32000
BOUND 107
OFFSET
LOADC
LDLW 12
CONST 4
OFFSET
LDLW 20
INC
CONST 32000
BOUND 107
OFFSET
LOADC
CONST 256
TIMES
PLUS
RETURN
END

PROC OMSPA.PutWordAt 0 4 0x00100001
!   PROCEDURE PutWordAt*(VAR c: ModuleCode; at, val: INTEGER);
LINE 110
!     c.code[at] := val MOD ORD({8});
LINE 112
LDLW 24
CONST 256
MOD
CONVNC
LDLW 12
CONST 4
OFFSET
LDLW 20
CONST 32000
BOUND 112
OFFSET
STOREC
!     c.code[at + 1] := LSR(val, 8) MOD ORD({8})
LINE 113
LDLW 24
CONST 8
LSR
CONST 256
MOD
CONVNC
LDLW 12
CONST 4
OFFSET
LDLW 20
INC
CONST 32000
BOUND 113
OFFSET
STOREC
RETURN
END

PROC OMSPA.Emit 0 5 0x00100001
!   PROCEDURE Emit*(VAR c: ModuleCode; val: INTEGER);
LINE 116
!   BEGIN ASSERT ((val >= -ORD({15})) & (val < ORD({16})));
LINE 117
LDLW 20
CONST -32768
JLT L9
LDLW 20
CONST 65536
JLT L10
LABEL L9
CONST 0
CONST 117
GLOBAL EASSERT
CALL 2
LABEL L10
!     IF enabled THEN PutWordAt(c, c.pc, val); INC(c.pc, 2) END
LINE 118
LDGC OMSPA.enabled
JEQZ L14
LDLW 20
LDLW 12
LOADW
LDLW 16
LDLW 12
GLOBAL OMSPA.PutWordAt
CALL 4
LDLW 12
DUP 0
LOADW
CONST 2
PLUS
SWAP
STOREW
LABEL L14
RETURN
END

PROC OMSPA.encSrc 0 7 0x03b00001
!   PROCEDURE encSrc(VAR op: INTEGER; VAR SReg: BYTE; sam: BYTE; VAR SOff: INTEGER; VAR emitSOff: BOOLEAN; VAR params: SET);
LINE 121
!     IF sam = Register THEN ASSERT(SReg # CG2); params := params + Rm
LINE 123
LDLC 20
JNEQZ L19
LDLW 16
LOADC
CONST 3
JNEQ L21
CONST 0
CONST 123
GLOBAL EASSERT
CALL 2
LABEL L21
LDLW 32
LOADW
LDLW 32
STOREW
RETURN
LABEL L19
!     ELSIF sam = Indexed THEN ASSERT(~(SReg IN {PC, SR, CG2}));
LINE 124
LDLC 20
CONST 1
JNEQ L23
CONST 1
LDLW 16
LOADC
CONST 32
BOUND 124
LSL
CONST 13
BITAND
JEQZ L25
CONST 0
CONST 124
GLOBAL EASSERT
CALL 2
LABEL L25
!       IF (EmitOffset*params # {}) OR (SOff # 0) THEN params := params + Im; emitSOff := TRUE ELSE params := params + IRm END
LINE 125
LDLW 32
LOADW
CONST 65536
BITAND
JNEQZ L27
LDLW 24
LOADW
JEQZ L28
LABEL L27
LDLW 32
LOADW
CONST 16
BITOR
LDLW 32
STOREW
CONST 1
LDLW 28
STOREC
RETURN
LABEL L28
LDLW 32
LOADW
CONST 32
BITOR
LDLW 32
STOREW
RETURN
LABEL L23
!     ELSIF sam = Symbolic THEN SReg := PC; params := params + Im; emitSOff := TRUE
LINE 126
LDLC 20
CONST 2
JNEQ L31
CONST 0
LDLW 16
STOREC
LDLW 32
LOADW
CONST 16
BITOR
LDLW 32
STOREW
CONST 1
LDLW 28
STOREC
RETURN
LABEL L31
!     ELSIF sam = Absolute THEN SReg := SR; params := params + Im; emitSOff := TRUE
LINE 127
LDLC 20
CONST 3
JNEQ L33
CONST 2
LDLW 16
STOREC
LDLW 32
LOADW
CONST 16
BITOR
LDLW 32
STOREW
CONST 1
LDLW 28
STOREC
RETURN
LABEL L33
!     ELSIF sam = Indirect THEN ASSERT(~(SReg IN {SR, CG2})); params := params + IRm
LINE 128
LDLC 20
CONST 4
JNEQ L35
CONST 1
LDLW 16
LOADC
CONST 32
BOUND 128
LSL
CONST 12
BITAND
JEQZ L37
CONST 0
CONST 128
GLOBAL EASSERT
CALL 2
LABEL L37
LDLW 32
LOADW
CONST 32
BITOR
LDLW 32
STOREW
RETURN
LABEL L35
!     ELSIF sam = IndirectIncr THEN ASSERT(~(SReg IN {SR, CG2})); params := params + IRAm
LINE 129
LDLC 20
CONST 5
JNEQ L39
CONST 1
LDLW 16
LOADC
CONST 32
BOUND 129
LSL
CONST 12
BITAND
JEQZ L41
CONST 0
CONST 129
GLOBAL EASSERT
CALL 2
LABEL L41
LDLW 32
LOADW
CONST 48
BITOR
LDLW 32
STOREW
RETURN
LABEL L39
!     ELSIF sam = Immediate THEN
LINE 130
LDLC 20
CONST 6
JNEQ L43
!       IF EmitOffset*params # {} THEN SReg := PC; params := params + IRAm; emitSOff := TRUE (*don't use constant generator*)
LINE 131
LDLW 32
LOADW
CONST 65536
BITAND
JEQZ L46
CONST 0
LDLW 16
STOREC
LDLW 32
LOADW
CONST 48
BITOR
LDLW 32
STOREW
CONST 1
LDLW 28
STOREC
RETURN
LABEL L46
!       ELSIF (SOff = 4) & (op # PUSH) (*W/A CPU4 errata*) THEN SReg := CG1; params := params + IRm
LINE 132
LDLW 24
LOADW
CONST 4
JNEQ L48
LDLW 12
LOADW
CONST 36
JEQ L48
CONST 2
LDLW 16
STOREC
LDLW 32
LOADW
CONST 32
BITOR
LDLW 32
STOREW
RETURN
LABEL L48
!       ELSIF (SOff = 8) & (op # PUSH) THEN SReg := CG1; params := params + IRAm
LINE 133
LDLW 24
LOADW
CONST 8
JNEQ L51
LDLW 12
LOADW
CONST 36
JEQ L51
CONST 2
LDLW 16
STOREC
LDLW 32
LOADW
CONST 48
BITOR
LDLW 32
STOREW
RETURN
LABEL L51
!       ELSIF SOff = 0 THEN SReg := CG2; params := params + Rm
LINE 134
LDLW 24
LOADW
JNEQZ L54
CONST 3
LDLW 16
STOREC
LDLW 32
LOADW
LDLW 32
STOREW
RETURN
LABEL L54
!       ELSIF SOff = 1 THEN SReg := CG2; params := params + Im
LINE 135
LDLW 24
LOADW
CONST 1
JNEQ L56
CONST 3
LDLW 16
STOREC
LDLW 32
LOADW
CONST 16
BITOR
LDLW 32
STOREW
RETURN
LABEL L56
!       ELSIF SOff = 2 THEN SReg := CG2; params := params + IRm
LINE 136
LDLW 24
LOADW
CONST 2
JNEQ L58
CONST 3
LDLW 16
STOREC
LDLW 32
LOADW
CONST 32
BITOR
LDLW 32
STOREW
RETURN
LABEL L58
!       ELSIF (SOff = -1) OR (SOff = 0FFFFH) OR ((SOff = 0FFH) & (params*Byte = Byte)) THEN SReg := CG2; params := params + IRAm
LINE 137
LDLW 24
LOADW
CONST -1
JEQ L59
LDLW 24
LOADW
CONST 65535
JEQ L59
LDLW 24
LOADW
CONST 255
JNEQ L60
LDLW 32
LOADW
CONST 64
BITAND
CONST 64
JNEQ L60
LABEL L59
CONST 3
LDLW 16
STOREC
LDLW 32
LOADW
CONST 48
BITOR
LDLW 32
STOREW
RETURN
LABEL L60
!       ELSIF (op = ADD) & (SOff < -1) THEN op := SUB; SOff := -SOff; encSrc(op, SReg, sam, SOff, emitSOff, params)
LINE 138
LDLW 12
LOADW
CONST 5
JNEQ L65
LDLW 24
LOADW
CONST -1
JGEQ L65
CONST 8
LDLW 12
STOREW
LDLW 24
LOADW
UMINUS
LDLW 24
STOREW
LDLW 32
LDLW 28
LDLW 24
LDLC 20
LDLW 16
LDLW 12
GLOBAL OMSPA.encSrc
CALL 6
RETURN
LABEL L65
!       ELSIF (op = SUB) & (SOff < -1) THEN op := ADD; SOff := -SOff; encSrc(op, SReg, sam, SOff, emitSOff, params)
LINE 139
LDLW 12
LOADW
CONST 8
JNEQ L68
LDLW 24
LOADW
CONST -1
JGEQ L68
CONST 5
LDLW 12
STOREW
LDLW 24
LOADW
UMINUS
LDLW 24
STOREW
LDLW 32
LDLW 28
LDLW 24
LDLC 20
LDLW 16
LDLW 12
GLOBAL OMSPA.encSrc
CALL 6
RETURN
LABEL L68
!       ELSE SReg := PC; params := params + IRAm; emitSOff := TRUE
LINE 140
CONST 0
LDLW 16
STOREC
LDLW 32
LOADW
CONST 48
BITOR
LDLW 32
STOREW
CONST 1
LDLW 28
STOREC
RETURN
LABEL L43
!     ELSE S.DebugHex("encSrc sam", sam); ASSERT(FALSE)
LINE 142
LDLC 20
CONST 11
GLOBAL OMSPA.%1
GLOBAL OMSPS.DebugHex
CALL 3
CONST 0
CONST 142
GLOBAL EASSERT
CALL 2
RETURN
END

PROC OMSPA.Put1 0 4 0x00100001
!   PROCEDURE Put1(VAR c: ModuleCode; op, src, dst: BYTE; params: SET);
LINE 150
!     IF enabled THEN
LINE 152
LDGC OMSPA.enabled
JEQZ L72
!       c.code[c.pc+1] := LSL(op, 4) + src;
LINE 153
LDLC 20
CONST 4
LSL
LDLC 24
PLUS
CONVNC
LDLW 12
CONST 4
OFFSET
LDLW 12
LOADW
INC
CONST 32000
BOUND 153
OFFSET
STOREC
!       c.code[c.pc] := ORD(params) + dst;
LINE 154
LDLW 32
LDLC 28
PLUS
CONVNC
LDLW 12
CONST 4
OFFSET
LDLW 12
LOADW
CONST 32000
BOUND 154
OFFSET
STOREC
!       INC(c.pc, 2)
LINE 155
LDLW 12
DUP 0
LOADW
CONST 2
PLUS
SWAP
STOREW
LABEL L72
RETURN
END

PROC OMSPA.PutDO 32 9 0x02900001
!   PROCEDURE PutDO*(VAR c: ModuleCode; op: INTEGER; VAR s, d: Item; params: SET);
LINE 159
!   BEGIN (*emit format I instruction*) ASSERT(params - (Byte+EmitOffset) = {}); emitSOff := FALSE; emitDOff := FALSE;
LINE 162
LDLW 40
CONST -65601
BITAND
JEQZ L74
CONST 0
CONST 162
GLOBAL EASSERT
CALL 2
LABEL L74
CONST 0
STLC -1
CONST 0
STLC -2
!     ts := s; td := d;
LINE 163
LOCAL -20
LDLW 24
CONST 8
FIXCOPY
LOCAL -28
LDLW 32
CONST 8
FIXCOPY
!     IF op = MUL THEN 
LINE 164
LDLW 20
JNEQZ L107
!       IF s.am = Immediate THEN ASSERT(s.ofs < ORD({16}));
LINE 165
LDLW 24
CONST 1
LDIC
CONST 6
JNEQ L105
LDLW 24
LDNW 4
CONST 65536
JLT L112
CONST 0
CONST 165
GLOBAL EASSERT
CALL 2
LABEL L112
!         IF s.ofs = 0 THEN t.reg := 0; t.am := Immediate; t.ofs := 0; PutDO(c, MOV, t, d, params)
LINE 166
LDLW 24
LDNW 4
JNEQZ L126
CONST 0
STLC -12
CONST 6
STLC -11
CONST 0
STLW -8
LDLW 40
LDLW 36
LDLW 32
GLOBAL OMSPA.Item
LOCAL -12
CONST 4
LDLW 16
LDLW 12
GLOBAL OMSPA.PutDO
CALL 8
JUMP L105
LABEL L126
!         ELSIF s.ofs < 0 THEN (*multiplicator is negative, change sign of multiplicator, do the multiplication, then change the sign of the result*)
LINE 167
LDLW 24
LDNW 4
JGEQZ L128
!           ts.ofs := -ts.ofs; PutDO(c, op, ts, d, params); PutSO0(c, NEG, d, params)
LINE 168
LDLW -16
UMINUS
STLW -16
LDLW 40
LDLW 36
LDLW 32
GLOBAL OMSPA.Item
LOCAL -20
LDLW 20
LDLW 16
LDLW 12
GLOBAL OMSPA.PutDO
CALL 8
LDLW 40
LDLW 36
LDLW 32
CONST 1
LDLW 16
LDLW 12
LDGW OMSPA.PutSO0
NCHECK 168
CALL 6
JUMP L105
LABEL L128
!         ELSE (*multiplicator is positive*) WHILE ~ODD(ts.ofs) DO PutDO(c, ADD, d, d, params); ts.ofs := ts.ofs DIV 2 END;
LINE 169
LDLW -16
CONST 1
BITAND
JNEQZ L116
LDLW 40
LDLW 36
LDLW 32
LDLW 36
LDLW 32
CONST 5
LDLW 16
LDLW 12
GLOBAL OMSPA.PutDO
CALL 8
LDLW -16
CONST 2
DIV
STLW -16
JUMP L128
LABEL L116
!           t.am := Register; t.ofs := 0;
LINE 170
CONST 0
STLC -11
CONST 0
STLW -8
!           IF ts.ofs # 1 THEN t.reg := allocR(); PutDO(c, MOV, d, t, params);
LINE 171
LDLW -16
CONST 1
JEQ L105
LDGW OMSPA.allocR
NCHECK 171
CALLW 0
CONVNC
STLC -12
LDLW 40
GLOBAL OMSPA.Item
LOCAL -12
LDLW 36
LDLW 32
CONST 4
LDLW 16
LDLW 12
GLOBAL OMSPA.PutDO
CALL 8
LABEL L120
!             REPEAT PutDO(c, ADD, t, t, params); ts.ofs := ts.ofs DIV 2;
LINE 172
LDLW 40
GLOBAL OMSPA.Item
LOCAL -12
GLOBAL OMSPA.Item
LOCAL -12
CONST 5
LDLW 16
LDLW 12
GLOBAL OMSPA.PutDO
CALL 8
LDLW -16
CONST 2
DIV
STLW -16
!               IF ODD(ts.ofs) THEN PutDO(c, ADD, t, d, params) END
LINE 173
LDLW -16
CONST 1
BITAND
JEQZ L124
LDLW 40
LDLW 36
LDLW 32
GLOBAL OMSPA.Item
LOCAL -12
CONST 5
LDLW 16
LDLW 12
GLOBAL OMSPA.PutDO
CALL 8
LABEL L124
!             UNTIL ts.ofs = 1;
LINE 174
LDLW -16
CONST 1
JNEQ L120
!             freeR(t.reg)
LINE 175
LDLC -12
LDGW OMSPA.freeR
NCHECK 175
CALL 1
JUMP L105
LABEL L107
!     ELSIF op IN {DIv, MOd} THEN e := 0;
LINE 179
CONST 1
LDLW 20
CONST 32
BOUND 179
LSL
CONST 12
BITAND
JEQZ L130
CONST 0
STLW -32
!       IF (s.am = Immediate) & (s.ofs < ORD({16})) & (log2(s.ofs, e) = 1) THEN
LINE 180
LDLW 24
CONST 1
LDIC
CONST 6
JNEQ L133
LDLW 24
LDNW 4
CONST 65536
JGEQ L133
LOCAL -32
LDLW 24
LDNW 4
GLOBAL OMSPA.log2
CALLW 2
CONST 1
JNEQ L133
!         IF op = DIv THEN WHILE e > 0 DO ASSERT(d.am = Register); PutSO0(c, RRA, d, params - Byte); DEC(e) END
LINE 181
LDLW 20
CONST 2
JNEQ L136
LABEL L137
LDLW -32
JLEQZ L105
LDLW 32
CONST 1
LDIC
JEQZ L141
CONST 0
CONST 181
GLOBAL EASSERT
CALL 2
LABEL L141
LDLW 40
CONST -65
BITAND
LDLW 36
LDLW 32
CONST 34
LDLW 16
LDLW 12
LDGW OMSPA.PutSO0
NCHECK 181
CALL 6
DECL -32
JUMP L137
LABEL L136
!         ELSE (*op = MOd*) t.reg := 0; t.am := Immediate; t.ofs := LSL(1, e) - 1; PutDO(c, AND, t, d, params)
LINE 182
CONST 0
STLC -12
CONST 6
STLC -11
CONST 1
LDLW -32
LSL
DEC
STLW -8
LDLW 40
LDLW 36
LDLW 32
GLOBAL OMSPA.Item
LOCAL -12
CONST 15
LDLW 16
LDLW 12
GLOBAL OMSPA.PutDO
CALL 8
JUMP L105
LABEL L133
!       ELSE S.Mark("not implemented")
LINE 184
CONST 16
GLOBAL OMSPA.%2
GLOBAL OMSPS.Mark
CALL 2
JUMP L105
LABEL L130
!     ELSE ASSERT(op < 10H); ASSERT((op # MOV) OR (s.am # Register) OR (d.am # Register) OR (s.reg # d.reg));
LINE 186
LDLW 20
CONST 16
JLT L77
CONST 0
CONST 186
GLOBAL EASSERT
CALL 2
LABEL L77
LDLW 20
CONST 4
JNEQ L79
LDLW 24
CONST 1
LDIC
JNEQZ L79
LDLW 32
CONST 1
LDIC
JNEQZ L79
LDLW 24
LOADC
LDLW 32
LOADC
JNEQ L79
CONST 0
CONST 186
GLOBAL EASSERT
CALL 2
LABEL L79
!       encSrc(op, ts.reg, ts.am, ts.ofs, emitSOff, params);
LINE 187
LOCAL 40
LOCAL -1
LOCAL -16
LDLC -19
LOCAL -20
LOCAL 20
GLOBAL OMSPA.encSrc
CALL 6
!       IF d.am = Register THEN params := params + Rdm
LINE 189
LDLW 32
CONST 1
LDIC
JNEQZ L87
LDLW 40
STLW 40
JUMP L85
LABEL L87
!       ELSIF td.am = Indexed THEN ASSERT(~(td.reg IN {PC, SR, CG2})); params := params + Idm; emitDOff := TRUE
LINE 190
LDLC -27
CONST 1
JNEQ L89
CONST 1
LDLC -28
CONST 32
BOUND 190
LSL
CONST 13
BITAND
JEQZ L91
CONST 0
CONST 190
GLOBAL EASSERT
CALL 2
LABEL L91
LDLW 40
CONST 128
BITOR
STLW 40
CONST 1
STLC -2
JUMP L85
LABEL L89
!       ELSIF td.am = Symbolic THEN td.reg := PC; params := params + Idm; emitDOff := TRUE
LINE 191
LDLC -27
CONST 2
JNEQ L93
CONST 0
STLC -28
LDLW 40
CONST 128
BITOR
STLW 40
CONST 1
STLC -2
JUMP L85
LABEL L93
!       ELSIF td.am = Absolute THEN td.reg := SR; params := params + Idm; emitDOff := TRUE
LINE 192
LDLC -27
CONST 3
JNEQ L95
CONST 2
STLC -28
LDLW 40
CONST 128
BITOR
STLW 40
CONST 1
STLC -2
JUMP L85
LABEL L95
!       ELSE S.DebugHex("putDO dam", td.am); ASSERT(FALSE)
LINE 193
LDLC -27
CONST 10
GLOBAL OMSPA.%3
GLOBAL OMSPS.DebugHex
CALL 3
CONST 0
CONST 193
GLOBAL EASSERT
CALL 2
LABEL L85
!       ASSERT(ts.reg < 16); ASSERT(td.reg < 16);
LINE 196
LDLC -20
CONST 16
JLT L97
CONST 0
CONST 196
GLOBAL EASSERT
CALL 2
LABEL L97
LDLC -28
CONST 16
JLT L99
CONST 0
CONST 196
GLOBAL EASSERT
CALL 2
LABEL L99
!       Put1(c, op, ts.reg, td.reg, params);
LINE 197
LDLW 40
LDLC -28
LDLC -20
LDLW 20
CONVNC
LDLW 16
LDLW 12
GLOBAL OMSPA.Put1
CALL 6
!       IF emitSOff THEN Emit(c, getOfs(s)) END;
LINE 198
LDLC -1
JEQZ L102
LDLW 28
LDLW 24
LDGW OMSPA.getOfs
NCHECK 198
CALLW 2
LDLW 16
LDLW 12
GLOBAL OMSPA.Emit
CALL 3
LABEL L102
!       IF emitDOff THEN Emit(c, getOfs(d)) END
LINE 199
LDLC -2
JEQZ L105
LDLW 36
LDLW 32
LDGW OMSPA.getOfs
NCHECK 199
CALLW 2
LDLW 16
LDLW 12
GLOBAL OMSPA.Emit
CALL 3
LABEL L105
!     IF op IN {ADD, ADDC, SUBC, SUB, XOR, AND} THEN setFCI(d, TRUE) 
LINE 201
CONST 1
LDLW 20
CONST 32
BOUND 201
LSL
CONST 49632
BITAND
JEQZ L146
CONST 1
ALIGNC
LDLW 36
LDLW 32
LDGW OMSPA.setFCI
NCHECK 201
CALL 3
RETURN
LABEL L146
!     ELSIF op IN {DADD} THEN setFCI(d, FALSE)
LINE 202
CONST 1
LDLW 20
CONST 32
BOUND 202
LSL
CONST 1024
BITAND
JEQZ L148
CONST 0
ALIGNC
LDLW 36
LDLW 32
LDGW OMSPA.setFCI
NCHECK 202
CALL 3
LABEL L148
RETURN
END

PROC OMSPA.Put2 0 4 0x00100001
!   PROCEDURE Put2(VAR c: ModuleCode; op, register: BYTE; params: SET);
LINE 211
!     IF enabled THEN
LINE 213
LDGC OMSPA.enabled
JEQZ L151
!       c.code[c.pc+1] := LSR(op, 1);
LINE 214
LDLC 20
CONST 1
LSR
CONVNC
LDLW 12
CONST 4
OFFSET
LDLW 12
LOADW
INC
CONST 32000
BOUND 214
OFFSET
STOREC
!       c.code[c.pc]   := LSL(ORD(ODD(op)), 7) + ORD(params) + register;
LINE 215
LDLC 20
CONST 1
BITAND
CONST 7
LSL
LDLW 28
PLUS
LDLC 24
PLUS
CONVNC
LDLW 12
CONST 4
OFFSET
LDLW 12
LOADW
CONST 32000
BOUND 215
OFFSET
STOREC
!       INC(c.pc, 2)
LINE 216
LDLW 12
DUP 0
LOADW
CONST 2
PLUS
SWAP
STOREW
LABEL L151
RETURN
END

PROC OMSPA.PutSO 28 9 0x00900001
!   PROCEDURE PutSO*(VAR c: ModuleCode; op: INTEGER; VAR ds: Item; params: SET);
LINE 220
!   BEGIN (*emit format II instruction*) ASSERT(params - (Byte+EmitOffset) = {});
LINE 222
LDLW 32
CONST -65601
BITAND
JEQZ L153
CONST 0
CONST 222
GLOBAL EASSERT
CALL 2
LABEL L153
!     tds := ds;
LINE 223
LOCAL -28
LDLW 24
CONST 8
FIXCOPY
!     emitDSOff := FALSE; spi.reg := SP; spi.am := IndirectIncr; spi.ofs := 0;
LINE 224
CONST 0
STLC -1
CONST 1
STLC -12
CONST 5
STLC -11
CONST 0
STLW -8
!     IF op = POP THEN PutDO(c, MOV, spi, ds, Word) (*emulation*)
LINE 225
LDLW 20
CONST 256
JNEQ L163
CONST 0
LDLW 28
LDLW 24
GLOBAL OMSPA.Item
LOCAL -12
CONST 4
LDLW 16
LDLW 12
GLOBAL OMSPA.PutDO
CALL 8
JUMP L161
LABEL L163
!     ELSIF op = RLA THEN PutDO(c, ADD, ds, ds, params)
LINE 226
LDLW 20
CONST 257
JNEQ L165
LDLW 32
LDLW 28
LDLW 24
LDLW 28
LDLW 24
CONST 5
LDLW 16
LDLW 12
GLOBAL OMSPA.PutDO
CALL 8
JUMP L161
LABEL L165
!     ELSIF op = RLC THEN PutDO(c, ADDC, ds, ds, params)
LINE 227
LDLW 20
CONST 258
JNEQ L167
LDLW 32
LDLW 28
LDLW 24
LDLW 28
LDLW 24
CONST 6
LDLW 16
LDLW 12
GLOBAL OMSPA.PutDO
CALL 8
JUMP L161
LABEL L167
!     ELSIF op = NOP0 THEN (*do nothing*)
LINE 228
LDLW 20
CONST 259
JEQ L161
!     ELSIF op = NEG THEN t.reg := 0; t.am := Immediate; t.ofs := -1; (*emulated by software*)
LINE 229
LDLW 20
CONST 1
JNEQ L171
CONST 0
STLC -20
CONST 6
STLC -19
CONST -1
STLW -16
!       PutDO(c, XOR, t, ds, params); t.ofs := 1; PutDO(c, ADD, t, ds, params)
LINE 230
LDLW 32
LDLW 28
LDLW 24
GLOBAL OMSPA.Item
LOCAL -20
CONST 14
LDLW 16
LDLW 12
GLOBAL OMSPA.PutDO
CALL 8
CONST 1
STLW -16
LDLW 32
LDLW 28
LDLW 24
GLOBAL OMSPA.Item
LOCAL -20
CONST 5
LDLW 16
LDLW 12
GLOBAL OMSPA.PutDO
CALL 8
JUMP L161
LABEL L171
!     ELSE ASSERT(op < 100H);
LINE 231
LDLW 20
CONST 256
JLT L156
CONST 0
CONST 231
GLOBAL EASSERT
CALL 2
LABEL L156
!       encSrc(op, tds.reg, tds.am, tds.ofs, emitDSOff, params);
LINE 232
LOCAL 32
LOCAL -1
LOCAL -24
LDLC -27
LOCAL -28
LOCAL 20
GLOBAL OMSPA.encSrc
CALL 6
!       ASSERT(tds.reg < 16);
LINE 234
LDLC -28
CONST 16
JLT L158
CONST 0
CONST 234
GLOBAL EASSERT
CALL 2
LABEL L158
!       Put2(c, op, tds.reg, params);
LINE 235
LDLW 32
LDLC -28
LDLW 20
CONVNC
LDLW 16
LDLW 12
GLOBAL OMSPA.Put2
CALL 5
!       IF emitDSOff THEN Emit(c, getOfs(ds)) END
LINE 236
LDLC -1
JEQZ L161
LDLW 28
LDLW 24
LDGW OMSPA.getOfs
NCHECK 236
CALLW 2
LDLW 16
LDLW 12
GLOBAL OMSPA.Emit
CALL 3
LABEL L161
!     IF (op = RRC) OR (op = RRA) OR (op = SXT) THEN setFCI(ds, TRUE) 
LINE 238
LDLW 20
CONST 32
JEQ L173
LDLW 20
CONST 34
JEQ L173
LDLW 20
CONST 35
JNEQ L174
LABEL L173
CONST 1
ALIGNC
LDLW 28
LDLW 24
LDGW OMSPA.setFCI
NCHECK 238
CALL 3
RETURN
LABEL L174
!     ELSIF (op = SWPB) OR (op = CALL) OR (op = POP) THEN setFCI(ds, FALSE)
LINE 239
LDLW 20
CONST 33
JEQ L177
LDLW 20
CONST 37
JEQ L177
LDLW 20
CONST 256
JNEQ L178
LABEL L177
CONST 0
ALIGNC
LDLW 28
LDLW 24
LDGW OMSPA.setFCI
NCHECK 239
CALL 3
LABEL L178
RETURN
END

PROC OMSPA.PutJ 8 4 0x00100001
!   PROCEDURE PutJ*(VAR c: ModuleCode; cond: BYTE; offset: INTEGER);
LINE 247
!   BEGIN (*emit jump instruction*) ASSERT (cond <= 8);
LINE 249
LDLC 20
CONST 8
JLEQ L182
CONST 0
CONST 249
GLOBAL EASSERT
CALL 2
LABEL L182
!     ASSERT(~ODD(offset)); offset := offset DIV 2; 
LINE 250
LDLW 24
CONST 1
BITAND
JEQZ L184
CONST 0
CONST 250
GLOBAL EASSERT
CALL 2
LABEL L184
LDLW 24
CONST 2
DIV
STLW 24
!     IF (offset < -ORD({9})) OR (offset >= ORD({9})) THEN S.Mark("jump too far"); offset := 0 END;
LINE 251
LDLW 24
CONST -512
JLT L186
LDLW 24
CONST 512
JLT L187
LABEL L186
CONST 13
GLOBAL OMSPA.%4
GLOBAL OMSPS.Mark
CALL 2
CONST 0
STLW 24
LABEL L187
!     IF cond = NV THEN S.Mark("invalid cond code"); enabled := FALSE END;
LINE 252
LDLC 20
CONST 8
JNEQ L191
CONST 18
GLOBAL OMSPA.%5
GLOBAL OMSPS.Mark
CALL 2
CONST 0
STGC OMSPA.enabled
LABEL L191
!     IF enabled THEN
LINE 253
LDGC OMSPA.enabled
JEQZ L194
!       c.code[c.pc+1] := JMPh + LSL(cond, 2) + LSR(offset, 8) MOD 4;
LINE 254
LDLC 20
CONST 2
LSL
CONST 32
PLUS
LDLW 24
CONST 8
LSR
CONST 4
MOD
PLUS
CONVNC
LDLW 12
CONST 4
OFFSET
LDLW 12
LOADW
INC
CONST 32000
BOUND 254
OFFSET
STOREC
!       c.code[c.pc]   := offset MOD ORD({8});
LINE 255
LDLW 24
CONST 256
MOD
CONVNC
LDLW 12
CONST 4
OFFSET
LDLW 12
LOADW
CONST 32000
BOUND 255
OFFSET
STOREC
!       INC(c.pc, 2)
LINE 256
LDLW 12
DUP 0
LOADW
CONST 2
PLUS
SWAP
STOREW
LABEL L194
!     setFCI(dummy, FALSE)
LINE 258
CONST 0
ALIGNC
GLOBAL OMSPA.Item
LOCAL -8
LDGW OMSPA.setFCI
NCHECK 258
CALL 3
RETURN
END

PROC OMSPA.PutNO 8 7 0x00100001
!   PROCEDURE PutNO*(VAR c: ModuleCode; op: INTEGER);
LINE 261
!     IF op = RET THEN Put1(c, MOV, SP, PC, IRAm + Rdm + Word); setFCI(dummy, FALSE)
LINE 264
LDLW 20
CONST 384
JNEQ L199
CONST 48
CONST 0
CONST 1
CONST 4
LDLW 16
LDLW 12
GLOBAL OMSPA.Put1
CALL 6
CONST 0
ALIGNC
GLOBAL OMSPA.Item
LOCAL -8
LDGW OMSPA.setFCI
NCHECK 264
CALL 3
RETURN
LABEL L199
!     ELSIF op = CLRC THEN Put1(c, BIC, CG2, SR, Im + Rdm + Word)
LINE 265
LDLW 20
CONST 385
JNEQ L201
CONST 16
CONST 2
CONST 3
CONST 12
LDLW 16
LDLW 12
GLOBAL OMSPA.Put1
CALL 6
RETURN
LABEL L201
!     ELSIF op = RETI THEN Put2(c, op, 0, {}); setFCI(dummy, FALSE)
LINE 266
LDLW 20
CONST 38
JNEQ L203
CONST 0
CONST 0
LDLW 20
CONVNC
LDLW 16
LDLW 12
GLOBAL OMSPA.Put2
CALL 5
CONST 0
ALIGNC
GLOBAL OMSPA.Item
LOCAL -8
LDGW OMSPA.setFCI
NCHECK 266
CALL 3
RETURN
LABEL L203
CONST 0
CONST 267
GLOBAL EASSERT
CALL 2
RETURN
END

PROC OMSPA.negated 0 3 0
!   PROCEDURE negated*(cond: INTEGER): INTEGER;
LINE 273
!   BEGIN ASSERT(cond  # N); (*negated of negative condition does not exist*)
LINE 274
LDLW 12
CONST 4
JNEQ L205
CONST 0
CONST 274
GLOBAL EASSERT
CALL 2
LABEL L205
!     IF cond < N THEN cond := SYSTEM.VAL(BYTE, SYSTEM.VAL(SET, cond) / {0})
LINE 275
LDLW 12
CONST 4
JGEQ L208
LDLW 12
CONST 1
BITXOR
STLW 12
JUMP L206
LABEL L208
!     ELSIF cond <= L THEN cond := (L+GE) - cond
LINE 276
LDLW 12
CONST 6
JGT L210
CONST 11
LDLW 12
MINUS
STLW 12
JUMP L206
LABEL L210
!     ELSE cond := (NV+AL) - cond
LINE 277
CONST 15
LDLW 12
MINUS
STLW 12
LABEL L206
!     RETURN cond
LINE 279
LDLW 12
RETURN
END

PROC OMSPA.fix 0 4 0x00100001
!   PROCEDURE fix*(VAR c: ModuleCode; at, with: INTEGER);
LINE 282
!     IF enabled THEN
LINE 285
LDGC OMSPA.enabled
JEQZ L213
!       ASSERT(LSR(c.code[at+1], 5) = LSR(JMPh, 5)); (*Check op code*)
LINE 286
LDLW 12
CONST 4
OFFSET
LDLW 20
INC
CONST 32000
BOUND 286
OFFSET
LOADC
CONST 5
LSR
CONST 1
JEQ L215
CONST 0
CONST 286
GLOBAL EASSERT
CALL 2
LABEL L215
!       ASSERT (~ODD(with)); with := with DIV 2;
LINE 287
LDLW 24
CONST 1
BITAND
JEQZ L217
CONST 0
CONST 287
GLOBAL EASSERT
CALL 2
LABEL L217
LDLW 24
CONST 2
DIV
STLW 24
!       IF (with < -ORD({10})) OR (with >= ORD({10})) THEN S.Mark("jump too far")
LINE 288
LDLW 24
CONST -1024
JLT L219
LDLW 24
CONST 1024
JLT L220
LABEL L219
CONST 13
GLOBAL OMSPA.%4
GLOBAL OMSPS.Mark
CALL 2
RETURN
LABEL L220
!       ELSE with := with MOD ORD({10});
LINE 289
LDLW 24
CONST 1024
MOD
STLW 24
!         c.code[at+1] := LSL(LSR(c.code[at+1], 2), 2) + LSR(with, 8);
LINE 290
LDLW 12
CONST 4
OFFSET
LDLW 20
INC
CONST 32000
BOUND 290
OFFSET
LOADC
CONST 2
LSR
CONST 2
LSL
LDLW 24
CONST 8
LSR
PLUS
CONVNC
LDLW 12
CONST 4
OFFSET
LDLW 20
INC
CONST 32000
BOUND 290
OFFSET
STOREC
!         c.code[at] := with MOD ORD({8})
LINE 291
LDLW 24
CONST 256
MOD
CONVNC
LDLW 12
CONST 4
OFFSET
LDLW 20
CONST 32000
BOUND 291
OFFSET
STOREC
LABEL L213
RETURN
END

PROC OMSPA.FixOne 0 5 0x00100001
!   PROCEDURE FixOne*(VAR c: ModuleCode; at: INTEGER);
LINE 296
!     IF enabled THEN fix(c, at, c.pc-at-2) END
LINE 298
LDGC OMSPA.enabled
JEQZ L224
LDLW 12
LOADW
LDLW 20
MINUS
CONST 2
MINUS
LDLW 20
LDLW 16
LDLW 12
GLOBAL OMSPA.fix
CALL 4
LABEL L224
RETURN
END

PROC OMSPA.merged 8 4 0x00100001
!   PROCEDURE merged*(VAR c: ModuleCode; L0, L1: INTEGER): INTEGER;
LINE 301
!     IF enabled & (L0 # 0) THEN L3 := L0;
LINE 304
LDGC OMSPA.enabled
JEQZ L227
LDLW 20
JEQZ L227
LDLW 20
STLW -8
LABEL L228
!       REPEAT L2 := L3;
LINE 305
LDLW -8
STLW -4
!         ASSERT(LSR(c.code[L2+1], 13) = LSR(JMPh, 5)); (*must be a jump instruction*)
LINE 306
LDLW 12
CONST 4
OFFSET
LDLW -4
INC
CONST 32000
BOUND 306
OFFSET
LOADC
CONST 13
LSR
CONST 1
JEQ L231
CONST 0
CONST 306
GLOBAL EASSERT
CALL 2
LABEL L231
!         L3 := (c.code[L2+1] MOD ORD({2})*ORD({8}) + c.code[L2])*2
LINE 307
LDLW 12
CONST 4
OFFSET
LDLW -4
INC
CONST 32000
BOUND 307
OFFSET
LOADC
CONST 4
MOD
CONST 256
TIMES
LDLW 12
CONST 4
OFFSET
LDLW -4
CONST 32000
BOUND 307
OFFSET
LOADC
PLUS
CONST 2
TIMES
STLW -8
!       UNTIL L3 = 0;
LINE 308
LDLW -8
JNEQZ L228
!       c.code[L2+1] := LSL(LSR(c.code[L2+1], 2), 2) + LSR(L1, 8);
LINE 309
LDLW 12
CONST 4
OFFSET
LDLW -4
INC
CONST 32000
BOUND 309
OFFSET
LOADC
CONST 2
LSR
CONST 2
LSL
LDLW 24
CONST 8
LSR
PLUS
CONVNC
LDLW 12
CONST 4
OFFSET
LDLW -4
INC
CONST 32000
BOUND 309
OFFSET
STOREC
!       c.code[L2] := L1 MOD ORD({8});
LINE 310
LDLW 24
CONST 256
MOD
CONVNC
LDLW 12
CONST 4
OFFSET
LDLW -4
CONST 32000
BOUND 310
OFFSET
STOREC
!       L1 := L0
LINE 311
LDLW 20
STLW 24
LABEL L227
!     RETURN L1
LINE 314
LDLW 24
RETURN
END

PROC OMSPA.PushRegs 16 7 0x00100001
!   PROCEDURE PushRegs*(VAR c: ModuleCode; regs: SET): INTEGER;
LINE 317
!   BEGIN t.am := Register; t.ofs := 0; n := 0;
LINE 319
CONST 0
STLC -15
CONST 0
STLW -12
CONST 0
STLW -4
!     FOR i := 15 TO 0 BY -1 DO IF regs*{i} # {} THEN INC(n); t.reg := i; PutSO(c, PUSH, t, Word) END END
LINE 320
CONST 15
STLW -8
LABEL L233
LDLW -8
JLTZ L234
LDLW 20
CONST 1
LDLW -8
CONST 32
BOUND 320
LSL
BITAND
JEQZ L237
INCL -4
LDLW -8
CONVNC
STLC -16
CONST 0
GLOBAL OMSPA.Item
LOCAL -16
CONST 36
LDLW 16
LDLW 12
GLOBAL OMSPA.PutSO
CALL 6
LABEL L237
DECL -8
JUMP L233
LABEL L234
!     RETURN n
LINE 321
LDLW -4
RETURN
END

PROC OMSPA.PopRegs 16 7 0x00100001
!   PROCEDURE PopRegs*(VAR c: ModuleCode; regs: SET): INTEGER;
LINE 324
!   BEGIN t.am := Register; t.ofs := 0; n := 0;
LINE 326
CONST 0
STLC -15
CONST 0
STLW -12
CONST 0
STLW -8
!     FOR i := 0 TO 15 DO IF regs*{i} # {} THEN INC(n); t.reg := i; PutSO(c, POP, t, Word) END END
LINE 327
CONST 0
STLW -4
LABEL L238
LDLW -4
CONST 15
JGT L239
LDLW 20
CONST 1
LDLW -4
CONST 32
BOUND 327
LSL
BITAND
JEQZ L242
INCL -8
LDLW -4
CONVNC
STLC -16
CONST 0
GLOBAL OMSPA.Item
LOCAL -16
CONST 256
LDLW 16
LDLW 12
GLOBAL OMSPA.PutSO
CALL 6
LABEL L242
INCL -4
JUMP L238
LABEL L239
!     RETURN n
LINE 328
LDLW -8
RETURN
END

PROC OMSPA.Init 0 3 0x00100001
!   PROCEDURE Init*(VAR c: ModuleCode);
LINE 331
!   BEGIN c.pc := 0; enabled := TRUE
LINE 332
CONST 0
LDLW 12
STOREW
CONST 1
STGC OMSPA.enabled
RETURN
END

PROC OMSPA.%main 0 2 0
! BEGIN PutSO0 := PutSO
LINE 335
GLOBAL OMSPA.PutSO
STGW OMSPA.PutSO0
RETURN
END

! Global variables
GLOVAR OMSPA.getOfs 4
GLOVAR OMSPA.allocR 4
GLOVAR OMSPA.freeR 4
GLOVAR OMSPA.setFCI 4
GLOVAR OMSPA.enabled 1
GLOVAR OMSPA.PutSO0 4

! String "encSrc sam"
DEFINE OMSPA.%1
STRING 656E635372632073616D00

! String "not implemented"
DEFINE OMSPA.%2
STRING 6E6F7420696D706C656D656E74656400

! String "putDO dam"
DEFINE OMSPA.%3
STRING 707574444F2064616D00

! String "jump too far"
DEFINE OMSPA.%4
STRING 6A756D7020746F6F2066617200

! String "invalid cond code"
DEFINE OMSPA.%5
STRING 696E76616C696420636F6E6420636F646500

! Descriptor for ModuleCode
DEFINE OMSPA.ModuleCode
WORD 0
WORD 0
WORD OMSPA.ModuleCode.%anc

DEFINE OMSPA.ModuleCode.%anc
WORD OMSPA.ModuleCode

! Descriptor for Item
DEFINE OMSPA.Item
WORD 0
WORD 0
WORD OMSPA.Item.%anc

DEFINE OMSPA.Item.%anc
WORD OMSPA.Item

! End of file
