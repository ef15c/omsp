!! (SYMFILE #OMSPB 0x00030300 #OMSPB.%main 1 #OMSPB.Mod)
!! (CONST #versionkey* INTCONST 3)
!! (CONST #maxTypTab INTCONST 64)
!! (CONST #Head* INTCONST 0)
!! (CONST #Const* INTCONST 1)
!! (CONST #Var* INTCONST 2)
!! (CONST #Par* INTCONST 3)
!! (CONST #Fld* INTCONST 4)
!! (CONST #Typ* INTCONST 5)
!! (CONST #SProc* INTCONST 6)
!! (CONST #SFunc* INTCONST 7)
!! (CONST #Mod* INTCONST 8)
!! (CONST #StoredConst* INTCONST 9)
!! (CONST #Byte* INTCONST 1)
!! (CONST #Bool* INTCONST 2)
!! (CONST #Char* INTCONST 3)
!! (CONST #Int* INTCONST 4)
!! (CONST #Set* INTCONST 6)
!! (CONST #Pointer* INTCONST 7)
!! (CONST #NilTyp* INTCONST 8)
!! (CONST #NoTyp* INTCONST 9)
!! (CONST #Proc* INTCONST 10)
!! (CONST #String* INTCONST 11)
!! (CONST #Array* INTCONST 12)
!! (CONST #Record* INTCONST 13)
!! (CONST #PointerToByte* INTCONST 14)
!! (CONST #Handler* INTCONST 15)
!! (CONST #ByteSet* INTCONST 16)
!! (CONST #PointerToSet* INTCONST 17)
!! (CONST #PointerToByteSet* INTCONST 18)
!! (CONST #LastForm INTCONST 18)
!! (TYPE #Object* !1 (POINTER))
!! (TARGET =1 !2 (RECORD #OMSPB.ObjDesc 60 VOID
!!     (FIELD #class* 0 BYTE)
!!     (FIELD #exno* 1 BYTE)
!!     (FIELD #register* 2 BYTE)
!!     (FIELD #expo* 3 BOOLEAN)
!!     (FIELD #unsafe* 4 BOOLEAN)
!!     (FIELD #rdo* 5 BOOLEAN)
!!     (FIELD #lev* 8 INTEGER)
!!     (FIELD #next* 12 =1)
!!     (FIELD #dsc* 16 =1)
!!     (FIELD #type* 20 !3 (POINTER))
!!     (FIELD #name* 24 ?4 #OMSPS 1 #Ident (ARRAY 32 CHAR))
!!     (FIELD #val* 56 INTEGER)))
!! (TARGET =3 !5 (RECORD #OMSPB.TypeDesc 44 VOID
!!     (FIELD #form* 0 INTEGER)
!!     (FIELD #ref* 4 INTEGER)
!!     (FIELD #mno* 8 INTEGER)
!!     (FIELD #nofpar* 12 INTEGER)
!!     (FIELD #len* 16 INTEGER)
!!     (FIELD #dsc* 20 =1)
!!     (FIELD #typobj* 24 =1)
!!     (FIELD #base* 28 =3)
!!     (FIELD #size* 32 INTEGER)
!!     (FIELD #leaf* 36 BOOLEAN)
!!     (FIELD #ur* 40 SET)))
!! (TYPE #Module* !6 (POINTER))
!! (TARGET =6 !7 (RECORD #OMSPB.ModDesc 92 =2
!!     (FIELD #class* 0 BYTE)
!!     (FIELD #exno* 1 BYTE)
!!     (FIELD #register* 2 BYTE)
!!     (FIELD #expo* 3 BOOLEAN)
!!     (FIELD #unsafe* 4 BOOLEAN)
!!     (FIELD #rdo* 5 BOOLEAN)
!!     (FIELD #lev* 8 INTEGER)
!!     (FIELD #next* 12 =1)
!!     (FIELD #dsc* 16 =1)
!!     (FIELD #type* 20 =3)
!!     (FIELD #name* 24 =4)
!!     (FIELD #val* 56 INTEGER)
!!     (FIELD #orgname* 60 =4)))
!! (TYPE #Type* =3)
!! (TYPE #ObjDesc* =2)
!! (TYPE #ModDesc* =7)
!! (TYPE #TypeDesc* =5)
!! (TYPE #RegRTProcCallback* !8 (PROC 1 VOID
!!     (PARAM #p 12 =1)))
!! (GLOBAL #topScope- #OMSPB.topScope =1)
!! (GLOBAL #universe #OMSPB.universe =1)
!! (GLOBAL #system- #OMSPB.system =1)
!! (GLOBAL #byteType- #OMSPB.byteType =3)
!! (GLOBAL #boolType- #OMSPB.boolType =3)
!! (GLOBAL #charType- #OMSPB.charType =3)
!! (GLOBAL #byteSetType- #OMSPB.byteSetType =3)
!! (GLOBAL #intType- #OMSPB.intType =3)
!! (GLOBAL #setType- #OMSPB.setType =3)
!! (GLOBAL #nilType- #OMSPB.nilType =3)
!! (GLOBAL #noType- #OMSPB.noType =3)
!! (GLOBAL #strType- #OMSPB.strType =3)
!! (GLOBAL #ptrByteType- #OMSPB.ptrByteType =3)
!! (GLOBAL #ptrIntType- #OMSPB.ptrIntType =3)
!! (GLOBAL #ptrByteSetType- #OMSPB.ptrByteSetType =3)
!! (GLOBAL #ptrSetType- #OMSPB.ptrSetType =3)
!! (GLOBAL #nofmod #OMSPB.nofmod INTEGER)
!! (GLOBAL #Ref #OMSPB.Ref INTEGER)
!! (GLOBAL #typtab #OMSPB.typtab !9 (ARRAY 64 =3))
!! (GLOBAL #regRTProc #OMSPB.regRTProc =8)
!! (PROCEDURE #SetRegRTProcCallback* 79 #OMSPB.SetRegRTProcCallback !10 (PROC 2 VOID
!!     (PARAM #p 12 =8)))
!! (PROCEDURE #NewObj* 83 #OMSPB.NewObj !11 (PROC 3 VOID
!!     (VPARAM #obj 12 =1)
!!     (CPARAM #id 16 =4)
!!     (PARAM #class 20 INTEGER))
!!   (LOCAL #new -4 =1)
!!   (LOCAL #x -8 =1))
!! (PROCEDURE #thisObj* 94 #OMSPB.thisObj !12 (PROC 0 =1)
!!   (LOCAL #s -4 =1)
!!   (LOCAL #x -8 =1))
!! (PROCEDURE #thisimport* 104 #OMSPB.thisimport !13 (PROC 1 =1
!!     (PARAM #mod 12 =1))
!!   (LOCAL #obj -4 =1))
!! (PROCEDURE #thisfield* 118 #OMSPB.thisfield !14 (PROC 1 =1
!!     (PARAM #rec 12 =3))
!!   (LOCAL #fld -4 =1))
!! (PROCEDURE #OpenScope* 125 #OMSPB.OpenScope !15 (PROC 0 VOID)
!!   (LOCAL #s -4 =1))
!! (PROCEDURE #CloseScope* 130 #OMSPB.CloseScope !16 (PROC 0 VOID))
!! (DEF !17 (FLEX CHAR))
!! (PROCEDURE #MakeFileName* 136 #OMSPB.MakeFileName !18 (PROC 5 VOID
!!     (VPARAM #FName 12 =4)
!!     (CPARAM #name 16 =17)
!!     (CPARAM #ext 24 =17))
!!   (LOCAL #i -4 INTEGER)
!!   (LOCAL #j -8 INTEGER))
!! (PROCEDURE #ThisModule 144 #OMSPB.ThisModule !19 (PROC 4 =1
!!     (CPARAM #name 12 =4)
!!     (CPARAM #orgname 16 =4)
!!     (PARAM #decl 20 BOOLEAN)
!!     (PARAM #key 24 INTEGER))
!!   (LOCAL #mod -4 =6)
!!   (LOCAL #obj -8 =1)
!!   (LOCAL #obj1 -12 =1))
!! (DEF ?20 #POFiles 6 #Rider (RECORD #POFiles.Rider 12 VOID
!!     (FIELD #eof* 0 BOOLEAN)
!!     (FIELD #res* 4 INTEGER)
!!     (FIELD #base 8 ?21 #POFiles 1 #File (POINTER))))
!! (PROCEDURE #Read 167 #OMSPB.Read !22 (PROC 3 VOID
!!     (VPARAM #R 12 =20)
!!     (VPARAM #x 20 INTEGER))
!!   (LOCAL #b -1 BYTE))
!! (TARGET =21 ?23 #POFiles 2 #FileDesc (RECORD #POFiles.FileDesc 68 VOID
!!     (FIELD #file 0 ?24 #Files 1 #File (POINTER))
!!     (FIELD #tmpName 4 ?25 #POFiles 4 ANON (ARRAY 32 CHAR))
!!     (FIELD #name 36 =25)))
!! (TARGET =24 ?26 #Files 2 #FileDesc (RECORD #Files.FileDesc 8 VOID
!!     (FIELD #file- 0 SYSTEM.LONGPTR)))
!! (PROCEDURE #InType 173 #OMSPB.InType !27 (PROC 4 VOID
!!     (VPARAM #R 12 =20)
!!     (PARAM #thismod 20 =1)
!!     (VPARAM #T 24 =3))
!!   (LOCAL #key -4 INTEGER)
!!   (LOCAL #ref -8 INTEGER)
!!   (LOCAL #class -12 INTEGER)
!!   (LOCAL #form -16 INTEGER)
!!   (LOCAL #np -20 INTEGER)
!!   (LOCAL #tmp -24 INTEGER)
!!   (LOCAL #fld -28 =1)
!!   (LOCAL #par -32 =1)
!!   (LOCAL #obj -36 =1)
!!   (LOCAL #mod -40 =1)
!!   (LOCAL #last -44 =1)
!!   (LOCAL #t -48 =3)
!!   (LOCAL #name -80 =4)
!!   (LOCAL #modname -112 =4))
!! (PROCEDURE #Import* 225 #OMSPB.Import !28 (PROC 2 VOID
!!     (VPARAM #modid 12 =4)
!!     (VPARAM #modid1 16 =4))
!!   (LOCAL #key -4 INTEGER)
!!   (LOCAL #class -8 INTEGER)
!!   (LOCAL #k -12 INTEGER)
!!   (LOCAL #obj -16 =1)
!!   (LOCAL #t -20 =3)
!!   (LOCAL #thismod -24 =1)
!!   (LOCAL #modname -56 =4)
!!   (LOCAL #fname -88 =4)
!!   (LOCAL #F -92 =21)
!!   (LOCAL #R -104 =20))
!! (PROCEDURE #Write 261 #OMSPB.Write !29 (PROC 3 VOID
!!     (VPARAM #R 12 =20)
!!     (PARAM #x 20 INTEGER)))
!! (PROCEDURE #OutType 265 #OMSPB.OutType !30 (PROC 3 VOID
!!     (VPARAM #R 12 =20)
!!     (PARAM #t 20 =3))
!!   (LOCAL #obj -4 =1)
!!   (LOCAL #mod -8 =1)
!!   (LOCAL #fld -12 =1)
!!   (LOCAL #bot -16 =1)
!!   (PROCEDURE #OutPar 268 #OMSPB.%57.OutPar !31 (PROC 4 VOID
!!       (VPARAM #R 12 =20)
!!       (PARAM #par 20 =1)
!!       (PARAM #n 24 INTEGER)))
!!   (PROCEDURE #FindHiddenPointers 279 #OMSPB.%58.FindHiddenPointers !32 (PROC 4 VOID
!!       (VPARAM #R 12 =20)
!!       (PARAM #typ 20 =3)
!!       (PARAM #offset 24 INTEGER))
!!     (LOCAL #fld -8 =1)
!!     (LOCAL #i -12 INTEGER)
!!     (LOCAL #n -16 INTEGER)))
!! (PROCEDURE #Export* 324 #OMSPB.Export !33 (PROC 3 VOID
!!     (VPARAM #modid 12 =4)
!!     (VPARAM #newSF 16 BOOLEAN)
!!     (VPARAM #key 20 INTEGER))
!!   (LOCAL #x -4 INTEGER)
!!   (LOCAL #sum -8 INTEGER)
!!   (LOCAL #oldkey -12 INTEGER)
!!   (LOCAL #obj -16 =1)
!!   (LOCAL #obj0 -20 =1)
!!   (LOCAL #filename -52 =4)
!!   (LOCAL #F -56 =21)
!!   (LOCAL #F1 -60 =21)
!!   (LOCAL #R -72 =20)
!!   (LOCAL #R1 -84 =20)
!!   (LOCAL #oldSF -85 BOOLEAN))
!! (PROCEDURE #Init* 375 #OMSPB.Init !34 (PROC 0 VOID))
!! (PROCEDURE #type2 379 #OMSPB.type2 !35 (PROC 4 =3
!!     (PARAM #ref 12 INTEGER)
!!     (PARAM #form 16 INTEGER)
!!     (PARAM #size 20 INTEGER)
!!     (PARAM #base 24 =3))
!!   (LOCAL #tp -4 =3))
!! (PROCEDURE #type 385 #OMSPB.type !36 (PROC 3 =3
!!     (PARAM #ref 12 INTEGER)
!!     (PARAM #form 16 INTEGER)
!!     (PARAM #size 20 INTEGER)))
!! (DEF !37 (FLEX CHAR))
!! (PROCEDURE #enter 389 #OMSPB.enter !38 (PROC 5 VOID
!!     (CPARAM #name 12 =37)
!!     (PARAM #cl 20 INTEGER)
!!     (PARAM #type 24 =3)
!!     (PARAM #n 28 INTEGER))
!!   (LOCAL #obj -4 =1))
!! (CHKSUM 0x44d6da02)
!! 
MODULE OMSPB 0x44d6da02 465
IMPORT POFiles 0x1834a231
IMPORT CRC32 0x53aa1c15
IMPORT OMSPS 0x669fb75e
ENDHDR

PROC OMSPB.SetRegRTProcCallback 0 2 0
!   PROCEDURE SetRegRTProcCallback*(p: RegRTProcCallback);
LINE 79
!   BEGIN regRTProc := p
LINE 80
LDLW 16
GCHECK 80
LDLW 12
STGW OMSPB.regRTProc
RETURN
END

PROC OMSPB.NewObj 8 5 0x00318001
!   PROCEDURE NewObj*(VAR obj: Object; id: S.Ident; class: INTEGER);  (*insert new Object with name id*)
LINE 83
!   BEGIN x := topScope;
LINE 85
LDGW OMSPB.topScope
STLW -8
LABEL L59
!     WHILE (x.next # NIL) & (x.next.name # id) DO x := x.next END ;
LINE 86
LDLW -8
NCHECK 86
LDNW 12
JEQZ L61
CONST 32
LDLW 16
LDLW -8
NCHECK 86
LDNW 12
NCHECK 86
CONST 24
OFFSET
CONST 32
SWAP
GLOBAL COMPARE
CALLW 4
JEQZ L61
LDLW -8
NCHECK 86
LDNW 12
STLW -8
JUMP L59
LABEL L61
!     IF x.next = NIL THEN
LINE 87
LDLW -8
NCHECK 87
LDNW 12
JNEQZ L65
!       NEW(new); new.name := id; new.class := class; new.next := NIL; new.rdo := FALSE; new.register := 0FFH; new.dsc := NIL;
LINE 88
CONST 60
GLOBAL OMSPB.ObjDesc
GLOBAL NEW
CALLW 2
STLW -4
LDLW -4
NCHECK 88
CONST 24
OFFSET
LDLW 16
CONST 32
FIXCOPY
LDLW 20
CONVNC
LDLW -4
NCHECK 88
STOREC
CONST 0
LDLW -4
NCHECK 88
STNW 12
CONST 0
LDLW -4
NCHECK 88
CONST 5
STIC
CONST 255
LDLW -4
NCHECK 88
CONST 2
STIC
CONST 0
LDLW -4
NCHECK 88
STNW 16
!       x.next := new; obj := new
LINE 89
LDLW -4
LDLW -8
NCHECK 89
STNW 12
LDLW -4
LDLW 12
STOREW
RETURN
LABEL L65
!     ELSE obj := x.next; S.Mark("mult def")
LINE 90
LDLW -8
NCHECK 90
LDNW 12
LDLW 12
STOREW
CONST 9
GLOBAL OMSPB.%1
GLOBAL OMSPS.Mark
CALL 2
RETURN
END

PROC OMSPB.thisObj 8 5 0x00018001
!   PROCEDURE thisObj*(): Object;
LINE 94
!   BEGIN s := topScope;
LINE 96
LDGW OMSPB.topScope
STLW -4
LABEL L66
!     REPEAT x := s.next;
LINE 97
LDLW -4
NCHECK 97
LDNW 12
STLW -8
LABEL L69
!       WHILE (x # NIL) & (x.name # S.id) DO x := x.next END ;
LINE 98
LDLW -8
JEQZ L71
CONST 32
GLOBAL OMSPS.id
LDLW -8
NCHECK 98
CONST 24
OFFSET
CONST 32
SWAP
GLOBAL COMPARE
CALLW 4
JEQZ L71
LDLW -8
NCHECK 98
LDNW 12
STLW -8
JUMP L69
LABEL L71
!       s := s.dsc
LINE 99
LDLW -4
NCHECK 99
LDNW 16
STLW -4
!     UNTIL (x # NIL) OR (s = NIL);
LINE 100
LDLW -8
JNEQZ L67
LDLW -4
JNEQZ L66
LABEL L67
!     RETURN x
LINE 101
LDLW -8
RETURN
END

PROC OMSPB.thisimport 4 5 0x00110001
!   PROCEDURE thisimport*(mod: Object): Object;
LINE 104
!     IF mod.rdo THEN
LINE 107
LDLW 12
NCHECK 107
CONST 5
LDIC
JEQZ L75
!       IF mod.name[0] # 0X THEN
LINE 108
LDLW 12
NCHECK 108
CONST 24
LDIC
JEQZ L78
!         obj := mod.dsc;
LINE 109
LDLW 12
NCHECK 109
LDNW 16
STLW -4
LABEL L79
!         WHILE (obj # NIL) & (obj.name # S.id) DO obj := obj.next END
LINE 110
LDLW -4
JEQZ L73
CONST 32
GLOBAL OMSPS.id
LDLW -4
NCHECK 110
CONST 24
OFFSET
CONST 32
SWAP
GLOBAL COMPARE
CALLW 4
JEQZ L73
LDLW -4
NCHECK 110
LDNW 12
STLW -4
JUMP L79
LABEL L78
!       ELSE obj := NIL
LINE 111
CONST 0
STLW -4
JUMP L73
LABEL L75
!     ELSE obj := NIL
LINE 113
CONST 0
STLW -4
LABEL L73
!     RETURN obj
LINE 115
LDLW -4
RETURN
END

PROC OMSPB.thisfield 4 5 0x00110001
!   PROCEDURE thisfield*(rec: Type): Object;
LINE 118
!   BEGIN fld := rec.dsc;
LINE 120
LDLW 12
NCHECK 120
LDNW 20
STLW -4
LABEL L83
!     WHILE (fld # NIL) & (fld.name # S.id) DO fld := fld.next END ;
LINE 121
LDLW -4
JEQZ L85
CONST 32
GLOBAL OMSPS.id
LDLW -4
NCHECK 121
CONST 24
OFFSET
CONST 32
SWAP
GLOBAL COMPARE
CALLW 4
JEQZ L85
LDLW -4
NCHECK 121
LDNW 12
STLW -4
JUMP L83
LABEL L85
!     RETURN fld
LINE 122
LDLW -4
RETURN
END

PROC OMSPB.OpenScope 4 3 0x00010001
!   PROCEDURE OpenScope*;
LINE 125
!   BEGIN NEW(s); s.class := Head; s.dsc := topScope; s.next := NIL; topScope := s
LINE 127
CONST 60
GLOBAL OMSPB.ObjDesc
GLOBAL NEW
CALLW 2
STLW -4
CONST 0
LDLW -4
NCHECK 127
STOREC
LDGW OMSPB.topScope
LDLW -4
NCHECK 127
STNW 16
CONST 0
LDLW -4
NCHECK 127
STNW 12
LDLW -4
STGW OMSPB.topScope
RETURN
END

PROC OMSPB.CloseScope 0 2 0
!   PROCEDURE CloseScope*;
LINE 130
!   BEGIN topScope := topScope.dsc
LINE 131
LDGW OMSPB.topScope
NCHECK 131
LDNW 16
STGW OMSPB.topScope
RETURN
END

PROC OMSPB.MakeFileName 8 4 0x00b00001
!   PROCEDURE MakeFileName*(VAR FName: S.Ident; name, ext: ARRAY OF CHAR);
LINE 136
!   BEGIN i := 0; j := 0;  (*assume name suffix less than 4 characters*)
LINE 138
CONST 0
STLW -4
CONST 0
STLW -8
LABEL L87
!     WHILE (i < S.IdLen-5) & (name[i] > 0X) DO FName[i] := name[i]; INC(i) END ;
LINE 139
LDLW -4
CONST 27
JGEQ L89
LDLW 16
LDLW -4
LDLW 20
BOUND 139
LDIC
JLEQZ L89
LDLW 16
LDLW -4
LDLW 20
BOUND 139
LDIC
LDLW 12
LDLW -4
CONST 32
BOUND 139
STIC
INCL -4
JUMP L87
LABEL L89
!     REPEAT FName[i]:= ext[j]; INC(i); INC(j) UNTIL ext[j] = 0X;
LINE 140
LDLW 24
LDLW -8
LDLW 28
BOUND 140
LDIC
LDLW 12
LDLW -4
CONST 32
BOUND 140
STIC
INCL -4
INCL -8
LDLW 24
LDLW -8
LDLW 28
BOUND 140
LDIC
JNEQZ L89
!     FName[i] := 0X
LINE 141
CONST 0
LDLW 12
LDLW -4
CONST 32
BOUND 141
STIC
RETURN
END

PROC OMSPB.ThisModule 12 6 0x0031c001
!   PROCEDURE ThisModule(name, orgname: S.Ident; decl: BOOLEAN; key: INTEGER): Object;
LINE 144
!   BEGIN obj1 := topScope; obj := obj1.next;  (*search for module*)
LINE 146
LDGW OMSPB.topScope
STLW -12
LDLW -12
NCHECK 146
LDNW 12
STLW -8
LABEL L93
!     WHILE (obj # NIL) & (obj(Module).orgname # orgname) DO obj1 := obj; obj := obj1.next END ;
LINE 147
LDLW -8
JEQZ L95
CONST 32
LDLW 16
LDLW -8
DUP 0
NCHECK 147
LDNW -4
DUP 0
LDNW 4
CONST 1
JGEQ L99
POP 1
JUMP L98
LABEL L99
LDNW 8
LDNW 4
GLOBAL OMSPB.ModDesc
JEQ L97
LABEL L98
ERROR E_CAST 147
LABEL L97
CONST 60
OFFSET
CONST 32
SWAP
GLOBAL COMPARE
CALLW 4
JEQZ L95
LDLW -8
STLW -12
LDLW -12
NCHECK 147
LDNW 12
STLW -8
JUMP L93
LABEL L95
!     IF obj = NIL THEN  (*new module, search for alias*)
LINE 148
LDLW -8
JNEQZ L102
!       obj := topScope.next;
LINE 149
LDGW OMSPB.topScope
NCHECK 149
LDNW 12
STLW -8
LABEL L103
!       WHILE (obj # NIL) & (obj.name # name) DO obj := obj.next END ;
LINE 150
LDLW -8
JEQZ L105
CONST 32
LDLW 12
LDLW -8
NCHECK 150
CONST 24
OFFSET
CONST 32
SWAP
GLOBAL COMPARE
CALLW 4
JEQZ L105
LDLW -8
NCHECK 150
LDNW 12
STLW -8
JUMP L103
LABEL L105
!       IF obj = NIL THEN (*insert new module*)
LINE 151
LDLW -8
JNEQZ L109
!         NEW(mod); mod.class := Mod; mod.rdo := FALSE;
LINE 152
CONST 92
GLOBAL OMSPB.ModDesc
GLOBAL NEW
CALLW 2
STLW -4
CONST 8
LDLW -4
NCHECK 152
STOREC
CONST 0
LDLW -4
NCHECK 152
CONST 5
STIC
!         mod.name := name; mod.orgname := orgname; mod.val := key;
LINE 153
LDLW -4
NCHECK 153
CONST 24
OFFSET
LDLW 12
CONST 32
FIXCOPY
LDLW -4
NCHECK 153
CONST 60
OFFSET
LDLW 16
CONST 32
FIXCOPY
LDLW 24
LDLW -4
NCHECK 153
STNW 56
!         mod.lev := nofmod; INC(nofmod); mod.dsc := NIL; mod.next := NIL;
LINE 154
LDGW OMSPB.nofmod
LDLW -4
NCHECK 154
STNW 8
LDGW OMSPB.nofmod
INC
STGW OMSPB.nofmod
CONST 0
LDLW -4
NCHECK 154
STNW 16
CONST 0
LDLW -4
NCHECK 154
STNW 12
!         IF decl THEN mod.type := noType ELSE mod.type := nilType END ;
LINE 155
LDLC 20
JEQZ L112
LDGW OMSPB.noType
LDLW -4
NCHECK 155
STNW 20
JUMP L110
LABEL L112
LDGW OMSPB.nilType
LDLW -4
NCHECK 155
STNW 20
LABEL L110
!         obj1.next := mod; obj := mod
LINE 156
LDLW -4
LDLW -12
NCHECK 156
STNW 12
LDLW -4
STLW -8
JUMP L119
LABEL L109
!       ELSIF decl THEN
LINE 157
LDLC 20
JEQZ L114
!         IF obj.type.form = NoTyp THEN S.Mark("mult def") ELSE S.Mark("invalid import order") END
LINE 158
LDLW -8
NCHECK 158
LDNW 20
NCHECK 158
LOADW
CONST 9
JNEQ L117
CONST 9
GLOBAL OMSPB.%1
GLOBAL OMSPS.Mark
CALL 2
JUMP L119
LABEL L117
CONST 21
GLOBAL OMSPB.%2
GLOBAL OMSPS.Mark
CALL 2
JUMP L119
LABEL L114
!       ELSE S.Mark("conflict with alias")
LINE 159
CONST 20
GLOBAL OMSPB.%3
GLOBAL OMSPS.Mark
CALL 2
JUMP L119
LABEL L102
!     ELSIF decl THEN (*module already present, explicit import by declaration*)
LINE 161
LDLC 20
JEQZ L119
!       IF  obj.type.form = NoTyp THEN S.Mark("mult def") ELSE S.Mark("invalid import order") END
LINE 162
LDLW -8
NCHECK 162
LDNW 20
NCHECK 162
LOADW
CONST 9
JNEQ L122
CONST 9
GLOBAL OMSPB.%1
GLOBAL OMSPS.Mark
CALL 2
JUMP L119
LABEL L122
CONST 21
GLOBAL OMSPB.%2
GLOBAL OMSPS.Mark
CALL 2
LABEL L119
!     RETURN obj
LINE 164
LDLW -8
RETURN
END

PROC OMSPB.Read 4 4 0x00500001
!   PROCEDURE Read(VAR R: Files.Rider; VAR x: INTEGER);
LINE 167
!   BEGIN Files.ReadByte(R, b);
LINE 169
LOCAL -1
LDLW 16
LDLW 12
GLOBAL POFiles.ReadByte
CALL 3
!     IF b < 80H THEN x := b ELSE x := b - 100H END
LINE 170
LDLC -1
CONST 128
JGEQ L125
LDLC -1
LDLW 20
STOREW
RETURN
LABEL L125
LDLC -1
CONST 256
MINUS
LDLW 20
STOREW
RETURN
END

PROC OMSPB.InType 112 5 0x00d007e1
!   PROCEDURE InType(VAR R: Files.Rider; thismod: Object; VAR T: Type);
LINE 173
!   BEGIN Read(R, ref);
LINE 179
LOCAL -8
LDLW 16
LDLW 12
GLOBAL OMSPB.Read
CALL 3
!     IF ref < 0 THEN T := typtab[-ref]  (*already read*)
LINE 180
LDLW -8
JGEQZ L165
GLOBAL OMSPB.typtab
LDLW -8
UMINUS
CONST 64
BOUND 180
LDIW
LDLW 24
STOREW
RETURN
LABEL L165
!     ELSE NEW(t); T := t; typtab[ref] := t; t.mno := thismod.lev;
LINE 181
CONST 44
GLOBAL OMSPB.TypeDesc
GLOBAL NEW
CALLW 2
STLW -48
LDLW -48
LDLW 24
STOREW
LDLW -48
GLOBAL OMSPB.typtab
LDLW -8
CONST 64
BOUND 181
STIW
LDLW 20
NCHECK 181
LDNW 8
LDLW -48
NCHECK 181
STNW 8
!       Read(R, form); t.form := form;
LINE 182
LOCAL -16
LDLW 16
LDLW 12
GLOBAL OMSPB.Read
CALL 3
LDLW -16
LDLW -48
NCHECK 182
STOREW
!       IF form = Pointer THEN InType(R, thismod, t.base); t.size := 2
LINE 183
LDLW -16
CONST 7
JNEQ L129
LDLW -48
NCHECK 183
CONST 28
OFFSET
LDLW 20
LDLW 16
LDLW 12
GLOBAL OMSPB.InType
CALL 4
CONST 2
LDLW -48
NCHECK 183
STNW 32
JUMP L150
LABEL L129
!       ELSIF form = Array THEN InType(R, thismod, t.base); Files.ReadNum(R, t.len); Files.ReadNum(R, t.size)
LINE 184
LDLW -16
CONST 12
JNEQ L131
LDLW -48
NCHECK 184
CONST 28
OFFSET
LDLW 20
LDLW 16
LDLW 12
GLOBAL OMSPB.InType
CALL 4
LDLW -48
NCHECK 184
CONST 16
OFFSET
LDLW 16
LDLW 12
GLOBAL POFiles.ReadNum
CALL 3
LDLW -48
NCHECK 184
CONST 32
OFFSET
LDLW 16
LDLW 12
GLOBAL POFiles.ReadNum
CALL 3
JUMP L150
LABEL L131
!       ELSIF form = Record THEN
LINE 185
LDLW -16
CONST 13
JNEQ L133
!         InType(R, thismod, t.base);
LINE 186
LDLW -48
NCHECK 186
CONST 28
OFFSET
LDLW 20
LDLW 16
LDLW 12
GLOBAL OMSPB.InType
CALL 4
!         IF t.base.form = NoTyp THEN t.base := NIL; obj := NIL ELSE obj := t.base.dsc END ;
LINE 187
LDLW -48
NCHECK 187
LDNW 28
NCHECK 187
LOADW
CONST 9
JNEQ L136
CONST 0
LDLW -48
NCHECK 187
STNW 28
CONST 0
STLW -36
JUMP L134
LABEL L136
LDLW -48
NCHECK 187
LDNW 28
NCHECK 187
LDNW 20
STLW -36
LABEL L134
!         Files.ReadNum(R, t.len); (*TD exno*)
LINE 188
LDLW -48
NCHECK 188
CONST 16
OFFSET
LDLW 16
LDLW 12
GLOBAL POFiles.ReadNum
CALL 3
!         Files.ReadNum(R, t.nofpar);  (*ext level*)
LINE 189
LDLW -48
NCHECK 189
CONST 12
OFFSET
LDLW 16
LDLW 12
GLOBAL POFiles.ReadNum
CALL 3
!         Files.ReadNum(R, t.size);
LINE 190
LDLW -48
NCHECK 190
CONST 32
OFFSET
LDLW 16
LDLW 12
GLOBAL POFiles.ReadNum
CALL 3
!         Read(R, class); last := NIL;
LINE 191
LOCAL -12
LDLW 16
LDLW 12
GLOBAL OMSPB.Read
CALL 3
CONST 0
STLW -44
LABEL L137
!         WHILE class # 0 DO  (*fields*)
LINE 192
LDLW -12
JEQZ L139
!           NEW(fld); fld.class := class; Files.ReadString(R, fld.name);
LINE 193
CONST 60
GLOBAL OMSPB.ObjDesc
GLOBAL NEW
CALLW 2
STLW -28
LDLW -12
CONVNC
LDLW -28
NCHECK 193
STOREC
LDLW -28
NCHECK 193
CONST 24
OFFSET
CONST 32
SWAP
LDLW 16
LDLW 12
GLOBAL POFiles.ReadString
CALL 4
!           IF last = NIL THEN t.dsc := fld ELSE last.next := fld END ;
LINE 194
LDLW -44
JNEQZ L142
LDLW -28
LDLW -48
NCHECK 194
STNW 20
JUMP L140
LABEL L142
LDLW -28
LDLW -44
NCHECK 194
STNW 12
LABEL L140
!           last := fld;
LINE 195
LDLW -28
STLW -44
!           IF fld.name[0] # 0X THEN fld.expo := TRUE; InType(R, thismod, fld.type) ELSE fld.expo := FALSE; fld.type := nilType END ;
LINE 196
LDLW -28
NCHECK 196
CONST 24
LDIC
JEQZ L145
CONST 1
LDLW -28
NCHECK 196
CONST 3
STIC
LDLW -28
NCHECK 196
CONST 20
OFFSET
LDLW 20
LDLW 16
LDLW 12
GLOBAL OMSPB.InType
CALL 4
JUMP L143
LABEL L145
CONST 0
LDLW -28
NCHECK 196
CONST 3
STIC
LDGW OMSPB.nilType
LDLW -28
NCHECK 196
STNW 20
LABEL L143
!           Files.ReadNum(R, fld.val); Read(R, class)
LINE 197
LDLW -28
NCHECK 197
CONST 56
OFFSET
LDLW 16
LDLW 12
GLOBAL POFiles.ReadNum
CALL 3
LOCAL -12
LDLW 16
LDLW 12
GLOBAL OMSPB.Read
CALL 3
JUMP L137
LABEL L139
!         IF last = NIL THEN t.dsc := obj ELSE last.next := obj END
LINE 199
LDLW -44
JNEQZ L148
LDLW -36
LDLW -48
NCHECK 199
STNW 20
JUMP L150
LABEL L148
LDLW -36
LDLW -44
NCHECK 199
STNW 12
JUMP L150
LABEL L133
!       ELSIF form = Proc THEN
LINE 200
LDLW -16
CONST 10
JNEQ L150
!         InType(R, thismod, t.base); Read(R, tmp); t.leaf := tmp = 1; Files.ReadSet(R, t.ur);
LINE 201
LDLW -48
NCHECK 201
CONST 28
OFFSET
LDLW 20
LDLW 16
LDLW 12
GLOBAL OMSPB.InType
CALL 4
LOCAL -24
LDLW 16
LDLW 12
GLOBAL OMSPB.Read
CALL 3
LDLW -24
CONST 1
EQ
LDLW -48
NCHECK 201
CONST 36
STIC
LDLW -48
NCHECK 201
CONST 40
OFFSET
LDLW 16
LDLW 12
GLOBAL POFiles.ReadSet
CALL 3
!         obj := NIL; np := 0; Read(R, class);
LINE 202
CONST 0
STLW -36
CONST 0
STLW -20
LOCAL -12
LDLW 16
LDLW 12
GLOBAL OMSPB.Read
CALL 3
LABEL L151
!         WHILE class # 0 DO  (*parameters*)
LINE 203
LDLW -12
JEQZ L153
!           NEW(par); par.class := class; Read(R, tmp); par.rdo := tmp = 1; Files.ReadByte(R, par.register);
LINE 204
CONST 60
GLOBAL OMSPB.ObjDesc
GLOBAL NEW
CALLW 2
STLW -32
LDLW -12
CONVNC
LDLW -32
NCHECK 204
STOREC
LOCAL -24
LDLW 16
LDLW 12
GLOBAL OMSPB.Read
CALL 3
LDLW -24
CONST 1
EQ
LDLW -32
NCHECK 204
CONST 5
STIC
LDLW -32
NCHECK 204
CONST 2
OFFSET
LDLW 16
LDLW 12
GLOBAL POFiles.ReadByte
CALL 3
!           InType(R, thismod, par.type); par.next := obj; obj := par; INC(np); Read(R, class)
LINE 205
LDLW -32
NCHECK 205
CONST 20
OFFSET
LDLW 20
LDLW 16
LDLW 12
GLOBAL OMSPB.InType
CALL 4
LDLW -36
LDLW -32
NCHECK 205
STNW 12
LDLW -32
STLW -36
INCL -20
LOCAL -12
LDLW 16
LDLW 12
GLOBAL OMSPB.Read
CALL 3
JUMP L151
LABEL L153
!         t.dsc := obj; t.nofpar := np; t.size := 2;
LINE 207
LDLW -36
LDLW -48
NCHECK 207
STNW 20
LDLW -20
LDLW -48
NCHECK 207
STNW 12
CONST 2
LDLW -48
NCHECK 207
STNW 32
LABEL L150
!       Files.ReadString(R, modname);
LINE 209
CONST 32
LOCAL -112
LDLW 16
LDLW 12
GLOBAL POFiles.ReadString
CALL 4
!       IF modname[0] #  0X THEN  (*re-import ========*)
LINE 210
LDLC -112
JEQZ L156
!         Files.ReadInt(R, key); Files.ReadString(R, name);
LINE 211
LOCAL -4
LDLW 16
LDLW 12
GLOBAL POFiles.ReadInt
CALL 3
CONST 32
LOCAL -80
LDLW 16
LDLW 12
GLOBAL POFiles.ReadString
CALL 4
!         mod := ThisModule(modname, modname, FALSE, key);
LINE 212
LDLW -4
CONST 0
ALIGNC
LOCAL -112
LOCAL -112
GLOBAL OMSPB.ThisModule
CALLW 4
STLW -40
!         obj := mod.dsc;  (*search type*)
LINE 213
LDLW -40
NCHECK 213
LDNW 16
STLW -36
LABEL L157
!         WHILE (obj # NIL) & (obj.name # name) DO obj := obj.next END ;
LINE 214
LDLW -36
JEQZ L159
CONST 32
LOCAL -80
LDLW -36
NCHECK 214
CONST 24
OFFSET
CONST 32
SWAP
GLOBAL COMPARE
CALLW 4
JEQZ L159
LDLW -36
NCHECK 214
LDNW 12
STLW -36
JUMP L157
LABEL L159
!         IF obj # NIL THEN T := obj.type   (*type object found in object list of mod*)
LINE 215
LDLW -36
JEQZ L163
LDLW -36
NCHECK 215
LDNW 20
LDLW 24
STOREW
JUMP L161
LABEL L163
!           NEW(obj); obj.name := name; obj.class := Typ; obj.next := mod.dsc; mod.dsc := obj; obj.type := t;
LINE 217
CONST 60
GLOBAL OMSPB.ObjDesc
GLOBAL NEW
CALLW 2
STLW -36
LDLW -36
NCHECK 217
CONST 24
OFFSET
LOCAL -80
CONST 32
FIXCOPY
CONST 5
LDLW -36
NCHECK 217
STOREC
LDLW -40
NCHECK 217
LDNW 16
LDLW -36
NCHECK 217
STNW 12
LDLW -36
LDLW -40
NCHECK 217
STNW 16
LDLW -48
LDLW -36
NCHECK 217
STNW 20
!           t.mno := mod.lev; t.typobj := obj; T := t
LINE 218
LDLW -40
NCHECK 218
LDNW 8
LDLW -48
NCHECK 218
STNW 8
LDLW -36
LDLW -48
NCHECK 218
STNW 24
LDLW -48
LDLW 24
STOREW
LABEL L161
!         typtab[ref] := T
LINE 220
LDLW 24
LOADW
GLOBAL OMSPB.typtab
LDLW -8
CONST 64
BOUND 220
STIW
LABEL L156
RETURN
END

PROC OMSPB.Import 104 6 OMSPB.Import.%map
!   PROCEDURE Import*(VAR modid, modid1: S.Ident);
LINE 225
!     IF modid1 = "SYSTEM" THEN
LINE 232
CONST 7
GLOBAL OMSPB.%4
CONST 32
LDLW 16
GLOBAL COMPARE
CALLW 4
JNEQZ L190
!       thismod := ThisModule(modid, modid1, TRUE, 0); DEC(nofmod);
LINE 233
CONST 0
CONST 1
ALIGNC
LDLW 16
LDLW 12
GLOBAL OMSPB.ThisModule
CALLW 4
STLW -24
LDGW OMSPB.nofmod
DEC
STGW OMSPB.nofmod
!       thismod.lev := 0; thismod.dsc := system; thismod.rdo := TRUE
LINE 234
CONST 0
LDLW -24
NCHECK 234
STNW 8
LDGW OMSPB.system
LDLW -24
NCHECK 234
STNW 16
CONST 1
LDLW -24
NCHECK 234
CONST 5
STIC
RETURN
LABEL L190
!     ELSE MakeFileName(fname, modid1, ".sms"); F := Files.Old(fname);
LINE 235
CONST 5
GLOBAL OMSPB.%5
CONST 32
LDLW 16
LOCAL -88
GLOBAL OMSPB.MakeFileName
CALL 5
CONST 32
LOCAL -88
GLOBAL POFiles.Old
CALLW 2
STLW -92
!       IF F # NIL THEN
LINE 236
LDLW -92
JEQZ L169
!         Files.Set(R, F, 0); Files.ReadInt(R, key); Files.ReadInt(R, key); Files.ReadString(R, modname);
LINE 237
CONST 0
LDLW -92
GLOBAL POFiles.Rider
LOCAL -104
GLOBAL POFiles.Set
CALL 4
LOCAL -4
GLOBAL POFiles.Rider
LOCAL -104
GLOBAL POFiles.ReadInt
CALL 3
LOCAL -4
GLOBAL POFiles.Rider
LOCAL -104
GLOBAL POFiles.ReadInt
CALL 3
CONST 32
LOCAL -56
GLOBAL POFiles.Rider
LOCAL -104
GLOBAL POFiles.ReadString
CALL 4
!         thismod := ThisModule(modid, modid1, TRUE, key); thismod.rdo := TRUE;
LINE 238
LDLW -4
CONST 1
ALIGNC
LDLW 16
LDLW 12
GLOBAL OMSPB.ThisModule
CALLW 4
STLW -24
CONST 1
LDLW -24
NCHECK 238
CONST 5
STIC
!         Read(R, class); (*version key*)
LINE 239
LOCAL -8
GLOBAL POFiles.Rider
LOCAL -104
GLOBAL OMSPB.Read
CALL 3
!         IF class # versionkey THEN S.Mark("wrong version") END ;
LINE 240
LDLW -8
CONST 3
JEQ L172
CONST 14
GLOBAL OMSPB.%6
GLOBAL OMSPS.Mark
CALL 2
LABEL L172
!         Read(R, class);
LINE 241
LOCAL -8
GLOBAL POFiles.Rider
LOCAL -104
GLOBAL OMSPB.Read
CALL 3
LABEL L173
!         WHILE class # 0 DO
LINE 242
LDLW -8
JEQZ L167
!           NEW(obj); obj.class := class; Files.ReadString(R, obj.name);
LINE 243
CONST 60
GLOBAL OMSPB.ObjDesc
GLOBAL NEW
CALLW 2
STLW -16
LDLW -8
CONVNC
LDLW -16
NCHECK 243
STOREC
LDLW -16
NCHECK 243
CONST 24
OFFSET
CONST 32
SWAP
GLOBAL POFiles.Rider
LOCAL -104
GLOBAL POFiles.ReadString
CALL 4
!           InType(R, thismod, obj.type); obj.lev := -thismod.lev;
LINE 244
LDLW -16
NCHECK 244
CONST 20
OFFSET
LDLW -24
GLOBAL POFiles.Rider
LOCAL -104
GLOBAL OMSPB.InType
CALL 4
LDLW -24
NCHECK 244
LDNW 8
UMINUS
LDLW -16
NCHECK 244
STNW 8
!           IF class = Typ THEN
LINE 245
LDLW -8
CONST 5
JNEQ L178
!             t := obj.type; t.typobj := obj; Read(R, k);  (*fixup bases of previously declared pointer types*)
LINE 246
LDLW -16
NCHECK 246
LDNW 20
STLW -20
LDLW -16
LDLW -20
NCHECK 246
STNW 24
LOCAL -12
GLOBAL POFiles.Rider
LOCAL -104
GLOBAL OMSPB.Read
CALL 3
LABEL L179
!             WHILE k # 0 DO typtab[k].base := t; Read(R, k) END
LINE 247
LDLW -12
JEQZ L185
LDLW -20
GLOBAL OMSPB.typtab
LDLW -12
CONST 64
BOUND 247
LDIW
NCHECK 247
STNW 28
LOCAL -12
GLOBAL POFiles.Rider
LOCAL -104
GLOBAL OMSPB.Read
CALL 3
JUMP L179
LABEL L178
!           ELSIF class = Const THEN Files.ReadNum(R, obj.val); obj.rdo := TRUE;
LINE 248
LDLW -8
CONST 1
JNEQ L183
LDLW -16
NCHECK 248
CONST 56
OFFSET
GLOBAL POFiles.Rider
LOCAL -104
GLOBAL POFiles.ReadNum
CALL 3
CONST 1
LDLW -16
NCHECK 248
CONST 5
STIC
JUMP L185
LABEL L183
!           ELSIF class IN {Var, StoredConst} THEN Files.ReadNum(R, obj.val); obj.rdo := TRUE; obj.register := 0FFH;
LINE 249
CONST 1
LDLW -8
CONST 32
BOUND 249
LSL
CONST 516
BITAND
JEQZ L185
LDLW -16
NCHECK 249
CONST 56
OFFSET
GLOBAL POFiles.Rider
LOCAL -104
GLOBAL POFiles.ReadNum
CALL 3
CONST 1
LDLW -16
NCHECK 249
CONST 5
STIC
CONST 255
LDLW -16
NCHECK 249
CONST 2
STIC
!             IF obj.type.form = Proc THEN regRTProc(obj) END
LINE 250
LDLW -16
NCHECK 250
LDNW 20
NCHECK 250
LOADW
CONST 10
JNEQ L185
LDLW -16
LDGW OMSPB.regRTProc
NCHECK 250
CALL 1
LABEL L185
!           obj.next := thismod.dsc; thismod.dsc := obj; Read(R, class)
LINE 252
LDLW -24
NCHECK 252
LDNW 16
LDLW -16
NCHECK 252
STNW 12
LDLW -16
LDLW -24
NCHECK 252
STNW 16
LOCAL -8
GLOBAL POFiles.Rider
LOCAL -104
GLOBAL OMSPB.Read
CALL 3
JUMP L173
LABEL L169
!       ELSE S.Mark("import not available")
LINE 254
CONST 21
GLOBAL OMSPB.%7
GLOBAL OMSPS.Mark
CALL 2
LABEL L167
RETURN
END

PROC OMSPB.Write 0 4 0x00100001
!   PROCEDURE Write(VAR R: Files.Rider; x: INTEGER);
LINE 261
!   BEGIN Files.WriteByte(R, x)
LINE 262
LDLW 20
CONVNC
LDLW 16
LDLW 12
GLOBAL POFiles.WriteByte
CALL 3
RETURN
END

PROC OMSPB.%57.OutPar 4 6 0x00500001
SAVELINK
!     PROCEDURE OutPar(VAR R: Files.Rider; par: Object; n: INTEGER);
LINE 268
!       IF n > 0 THEN
LINE 270
LDLW 24
JLEQZ L193
!         OutPar(R, par.next, n-1);
LINE 271
LDLW 24
DEC
LDLW 20
NCHECK 271
LDNW 12
LDLW 16
LDLW 12
LDLW -4
STATLINK
GLOBAL OMSPB.%57.OutPar
CALL 4
!         Write(R, par.class);
LINE 272
LDLW 20
NCHECK 272
LOADC
LDLW 16
LDLW 12
GLOBAL OMSPB.Write
CALL 3
!         IF par.rdo THEN Write(R, 1) ELSE Write(R, 0) END;
LINE 273
LDLW 20
NCHECK 273
CONST 5
LDIC
JEQZ L196
CONST 1
LDLW 16
LDLW 12
GLOBAL OMSPB.Write
CALL 3
JUMP L194
LABEL L196
CONST 0
LDLW 16
LDLW 12
GLOBAL OMSPB.Write
CALL 3
LABEL L194
!         Write(R, par.register);
LINE 274
LDLW 20
NCHECK 274
CONST 2
LDIC
LDLW 16
LDLW 12
GLOBAL OMSPB.Write
CALL 3
!         OutType(R, par.type)
LINE 275
LDLW 20
NCHECK 275
LDNW 20
LDLW 16
LDLW 12
GLOBAL OMSPB.OutType
CALL 3
LABEL L193
RETURN
END

PROC OMSPB.%58.FindHiddenPointers 16 6 0x00508001
SAVELINK
!     PROCEDURE FindHiddenPointers(VAR R: Files.Rider; typ: Type; offset: INTEGER);
LINE 279
!       IF (typ.form = Pointer) OR (typ.form = NilTyp) THEN Write(R, Fld); Write(R, 0); Files.WriteNum(R, offset)
LINE 282
LDLW 20
NCHECK 282
LOADW
CONST 7
JEQ L198
LDLW 20
NCHECK 282
LOADW
CONST 8
JNEQ L199
LABEL L198
CONST 4
LDLW 16
LDLW 12
GLOBAL OMSPB.Write
CALL 3
CONST 0
LDLW 16
LDLW 12
GLOBAL OMSPB.Write
CALL 3
LDLW 24
LDLW 16
LDLW 12
GLOBAL POFiles.WriteNum
CALL 3
RETURN
LABEL L199
!       ELSIF typ.form = Record THEN fld := typ.dsc;
LINE 283
LDLW 20
NCHECK 283
LOADW
CONST 13
JNEQ L202
LDLW 20
NCHECK 283
LDNW 20
STLW -8
LABEL L203
!         WHILE fld # NIL DO FindHiddenPointers(R, fld.type, fld.val + offset); fld := fld.next END
LINE 284
LDLW -8
JEQZ L207
LDLW -8
NCHECK 284
LDNW 56
LDLW 24
PLUS
LDLW -8
NCHECK 284
LDNW 20
LDLW 16
LDLW 12
LDLW -4
STATLINK
GLOBAL OMSPB.%58.FindHiddenPointers
CALL 4
LDLW -8
NCHECK 284
LDNW 12
STLW -8
JUMP L203
LABEL L202
!       ELSIF typ.form = Array THEN i := 0; n := typ.len;
LINE 285
LDLW 20
NCHECK 285
LOADW
CONST 12
JNEQ L207
CONST 0
STLW -12
LDLW 20
NCHECK 285
LDNW 16
STLW -16
LABEL L208
!         WHILE i < n DO FindHiddenPointers(R, typ.base, typ.base.size * i + offset); INC(i) END
LINE 286
LDLW -12
LDLW -16
JGEQ L207
LDLW 20
NCHECK 286
LDNW 28
NCHECK 286
LDNW 32
LDLW -12
TIMES
LDLW 24
PLUS
LDLW 20
NCHECK 286
LDNW 28
LDLW 16
LDLW 12
LDLW -4
STATLINK
GLOBAL OMSPB.%58.FindHiddenPointers
CALL 4
INCL -12
JUMP L208
LABEL L207
RETURN
END

PROC OMSPB.OutType 16 5 0x0051e001
!   PROCEDURE OutType(VAR R: Files.Rider; t: Type);
LINE 265
!     IF t.ref > 0 THEN (*type was already output*) Write(R, -t.ref)
LINE 291
LDLW 20
NCHECK 291
LDNW 4
JLEQZ L254
LDLW 20
NCHECK 291
LDNW 4
UMINUS
LDLW 16
LDLW 12
GLOBAL OMSPB.Write
CALL 3
RETURN
LABEL L254
!     ELSE obj := t.typobj;
LINE 292
LDLW 20
NCHECK 292
LDNW 24
STLW -4
!       IF obj # NIL THEN Write(R, Ref); t.ref := Ref; INC(Ref) ELSE (*anonymous*) Write(R, 0) END ;
LINE 293
LDLW -4
JEQZ L214
LDGW OMSPB.Ref
LDLW 16
LDLW 12
GLOBAL OMSPB.Write
CALL 3
LDGW OMSPB.Ref
LDLW 20
NCHECK 293
STNW 4
LDGW OMSPB.Ref
INC
STGW OMSPB.Ref
JUMP L212
LABEL L214
CONST 0
LDLW 16
LDLW 12
GLOBAL OMSPB.Write
CALL 3
LABEL L212
!       Write(R, t.form);
LINE 294
LDLW 20
NCHECK 294
LOADW
LDLW 16
LDLW 12
GLOBAL OMSPB.Write
CALL 3
!       IF t.form = Pointer THEN OutType(R, t.base)
LINE 295
LDLW 20
NCHECK 295
LOADW
CONST 7
JNEQ L217
LDLW 20
NCHECK 295
LDNW 28
LDLW 16
LDLW 12
GLOBAL OMSPB.OutType
CALL 3
JUMP L235
LABEL L217
!       ELSIF t.form = Array THEN OutType(R, t.base); Files.WriteNum(R, t.len); Files.WriteNum(R, t.size)
LINE 296
LDLW 20
NCHECK 296
LOADW
CONST 12
JNEQ L219
LDLW 20
NCHECK 296
LDNW 28
LDLW 16
LDLW 12
GLOBAL OMSPB.OutType
CALL 3
LDLW 20
NCHECK 296
LDNW 16
LDLW 16
LDLW 12
GLOBAL POFiles.WriteNum
CALL 3
LDLW 20
NCHECK 296
LDNW 32
LDLW 16
LDLW 12
GLOBAL POFiles.WriteNum
CALL 3
JUMP L235
LABEL L219
!       ELSIF t.form = Record THEN
LINE 297
LDLW 20
NCHECK 297
LOADW
CONST 13
JNEQ L221
!         IF t.base # NIL THEN OutType(R, t.base); bot := t.base.dsc ELSE OutType(R, noType); bot := NIL END ;
LINE 298
LDLW 20
NCHECK 298
LDNW 28
JEQZ L224
LDLW 20
NCHECK 298
LDNW 28
LDLW 16
LDLW 12
GLOBAL OMSPB.OutType
CALL 3
LDLW 20
NCHECK 298
LDNW 28
NCHECK 298
LDNW 20
STLW -16
JUMP L222
LABEL L224
LDGW OMSPB.noType
LDLW 16
LDLW 12
GLOBAL OMSPB.OutType
CALL 3
CONST 0
STLW -16
LABEL L222
!         IF obj # NIL THEN Files.WriteNum(R, obj.exno) ELSE Write(R, 0) END ;
LINE 299
LDLW -4
JEQZ L227
LDLW -4
NCHECK 299
CONST 1
LDIC
LDLW 16
LDLW 12
GLOBAL POFiles.WriteNum
CALL 3
JUMP L225
LABEL L227
CONST 0
LDLW 16
LDLW 12
GLOBAL OMSPB.Write
CALL 3
LABEL L225
!         Files.WriteNum(R, t.nofpar); Files.WriteNum(R, t.size);
LINE 300
LDLW 20
NCHECK 300
LDNW 12
LDLW 16
LDLW 12
GLOBAL POFiles.WriteNum
CALL 3
LDLW 20
NCHECK 300
LDNW 32
LDLW 16
LDLW 12
GLOBAL POFiles.WriteNum
CALL 3
!         fld := t.dsc;
LINE 301
LDLW 20
NCHECK 301
LDNW 20
STLW -12
LABEL L228
!         WHILE fld # bot DO  (*fields*)
LINE 302
LDLW -12
LDLW -16
JEQ L230
!           IF fld.expo THEN
LINE 303
LDLW -12
NCHECK 303
CONST 3
LDIC
JEQZ L233
!             Write(R, Fld); Files.WriteString(R, fld.name); OutType(R, fld.type); Files.WriteNum(R, fld.val)  (*offset*)
LINE 304
CONST 4
LDLW 16
LDLW 12
GLOBAL OMSPB.Write
CALL 3
LDLW -12
NCHECK 304
CONST 24
OFFSET
CONST 32
SWAP
LDLW 16
LDLW 12
GLOBAL POFiles.WriteString
CALL 4
LDLW -12
NCHECK 304
LDNW 20
LDLW 16
LDLW 12
GLOBAL OMSPB.OutType
CALL 3
LDLW -12
NCHECK 304
LDNW 56
LDLW 16
LDLW 12
GLOBAL POFiles.WriteNum
CALL 3
JUMP L231
LABEL L233
!           ELSE FindHiddenPointers(R, fld.type, fld.val)
LINE 305
LDLW -12
NCHECK 305
LDNW 56
LDLW -12
NCHECK 305
LDNW 20
LDLW 16
LDLW 12
LOCAL 0
STATLINK
GLOBAL OMSPB.%58.FindHiddenPointers
CALL 4
LABEL L231
!           fld := fld.next
LINE 307
LDLW -12
NCHECK 307
LDNW 12
STLW -12
JUMP L228
LABEL L230
!         Write(R, 0)
LINE 309
CONST 0
LDLW 16
LDLW 12
GLOBAL OMSPB.Write
CALL 3
JUMP L235
LABEL L221
!       ELSIF t.form = Proc THEN OutType(R, t.base); IF t.leaf THEN Write(R, 1) ELSE Write(R, 0) END;
LINE 310
LDLW 20
NCHECK 310
LOADW
CONST 10
JNEQ L235
LDLW 20
NCHECK 310
LDNW 28
LDLW 16
LDLW 12
GLOBAL OMSPB.OutType
CALL 3
LDLW 20
NCHECK 310
CONST 36
LDIC
JEQZ L238
CONST 1
LDLW 16
LDLW 12
GLOBAL OMSPB.Write
CALL 3
JUMP L236
LABEL L238
CONST 0
LDLW 16
LDLW 12
GLOBAL OMSPB.Write
CALL 3
LABEL L236
!         Files.WriteSet(R, t.ur); OutPar(R, t.dsc, t.nofpar); Write(R, 0)
LINE 311
LDLW 20
NCHECK 311
LDNW 40
LDLW 16
LDLW 12
GLOBAL POFiles.WriteSet
CALL 3
LDLW 20
NCHECK 311
LDNW 12
LDLW 20
NCHECK 311
LDNW 20
LDLW 16
LDLW 12
LOCAL 0
STATLINK
GLOBAL OMSPB.%57.OutPar
CALL 4
CONST 0
LDLW 16
LDLW 12
GLOBAL OMSPB.Write
CALL 3
LABEL L235
!       IF (t.mno > 0) & (obj # NIL) THEN  (*re-export, output name*)
LINE 313
LDLW 20
NCHECK 313
LDNW 8
JLEQZ L241
LDLW -4
JEQZ L241
!         mod := topScope.next;
LINE 314
LDGW OMSPB.topScope
NCHECK 314
LDNW 12
STLW -8
LABEL L242
!         WHILE (mod # NIL) & (mod.lev # t.mno) DO mod := mod.next END ;
LINE 315
LDLW -8
JEQZ L244
LDLW -8
NCHECK 315
LDNW 8
LDLW 20
NCHECK 315
LDNW 8
JEQ L244
LDLW -8
NCHECK 315
LDNW 12
STLW -8
JUMP L242
LABEL L244
!         IF mod # NIL THEN Files.WriteString(R, mod(Module).orgname); Files.WriteInt(R, mod.val); Files.WriteString(R, obj.name)
LINE 316
LDLW -8
JEQZ L248
LDLW -8
DUP 0
NCHECK 316
LDNW -4
DUP 0
LDNW 4
CONST 1
JGEQ L251
POP 1
JUMP L250
LABEL L251
LDNW 8
LDNW 4
GLOBAL OMSPB.ModDesc
JEQ L249
LABEL L250
ERROR E_CAST 316
LABEL L249
CONST 60
OFFSET
CONST 32
SWAP
LDLW 16
LDLW 12
GLOBAL POFiles.WriteString
CALL 4
LDLW -8
NCHECK 316
LDNW 56
LDLW 16
LDLW 12
GLOBAL POFiles.WriteInt
CALL 3
LDLW -4
NCHECK 316
CONST 24
OFFSET
CONST 32
SWAP
LDLW 16
LDLW 12
GLOBAL POFiles.WriteString
CALL 4
RETURN
LABEL L248
!         ELSE S.Mark("re-export not found"); Write(R, 0)
LINE 317
CONST 20
GLOBAL OMSPB.%8
GLOBAL OMSPS.Mark
CALL 2
CONST 0
LDLW 16
LDLW 12
GLOBAL OMSPB.Write
CALL 3
RETURN
LABEL L241
!       ELSE Write(R, 0)
LINE 319
CONST 0
LDLW 16
LDLW 12
GLOBAL OMSPB.Write
CALL 3
RETURN
END

PROC OMSPB.Export 88 6 OMSPB.Export.%map
!   PROCEDURE Export*(VAR modid: S.Ident; VAR newSF: BOOLEAN; VAR key: INTEGER);
LINE 324
!   BEGIN Ref := LastForm + 1; MakeFileName(filename, modid, ".sms");
LINE 329
CONST 19
STGW OMSPB.Ref
CONST 5
GLOBAL OMSPB.%5
CONST 32
LDLW 12
LOCAL -52
GLOBAL OMSPB.MakeFileName
CALL 5
!     F1 := Files.Old(filename); (*sum is new key*)
LINE 330
CONST 32
LOCAL -52
GLOBAL POFiles.Old
CALLW 2
STLW -60
!     IF F1 # NIL THEN Files.Set(R1, F1, 4); Files.ReadInt(R1, oldkey);
LINE 331
LDLW -60
JEQZ L257
CONST 4
LDLW -60
GLOBAL POFiles.Rider
LOCAL -84
GLOBAL POFiles.Set
CALL 4
LOCAL -12
GLOBAL POFiles.Rider
LOCAL -84
GLOBAL POFiles.ReadInt
CALL 3
!       Files.Close(F1); oldSF := TRUE
LINE 332
LDLW -60
GLOBAL POFiles.Close
CALL 1
CONST 1
STLC -85
JUMP L255
LABEL L257
!     ELSE oldkey := 0; oldSF := FALSE
LINE 333
CONST 0
STLW -12
CONST 0
STLC -85
LABEL L255
!     F := Files.New(filename); Files.Set(R, F, 0);
LINE 335
CONST 32
LOCAL -52
GLOBAL POFiles.New
CALLW 2
STLW -56
CONST 0
LDLW -56
GLOBAL POFiles.Rider
LOCAL -72
GLOBAL POFiles.Set
CALL 4
!     Files.WriteInt(R, 0); (*placeholder*)
LINE 336
CONST 0
GLOBAL POFiles.Rider
LOCAL -72
GLOBAL POFiles.WriteInt
CALL 3
!     Files.WriteInt(R, 0); (*placeholder for key to be inserted at the end*)
LINE 337
CONST 0
GLOBAL POFiles.Rider
LOCAL -72
GLOBAL POFiles.WriteInt
CALL 3
!     Files.WriteString(R, modid); Write(R, versionkey);
LINE 338
CONST 32
LDLW 12
GLOBAL POFiles.Rider
LOCAL -72
GLOBAL POFiles.WriteString
CALL 4
CONST 3
GLOBAL POFiles.Rider
LOCAL -72
GLOBAL OMSPB.Write
CALL 3
!     obj := topScope.next;
LINE 339
LDGW OMSPB.topScope
NCHECK 339
LDNW 12
STLW -16
LABEL L258
!     WHILE obj # NIL DO
LINE 340
LDLW -16
JEQZ L260
!       IF obj.expo THEN
LINE 341
LDLW -16
NCHECK 341
CONST 3
LDIC
JEQZ L263
!         Write(R, obj.class); Files.WriteString(R, obj.name);
LINE 342
LDLW -16
NCHECK 342
LOADC
GLOBAL POFiles.Rider
LOCAL -72
GLOBAL OMSPB.Write
CALL 3
LDLW -16
NCHECK 342
CONST 24
OFFSET
CONST 32
SWAP
GLOBAL POFiles.Rider
LOCAL -72
GLOBAL POFiles.WriteString
CALL 4
!         OutType(R, obj.type);
LINE 343
LDLW -16
NCHECK 343
LDNW 20
GLOBAL POFiles.Rider
LOCAL -72
GLOBAL OMSPB.OutType
CALL 3
!         IF obj.class = Typ THEN
LINE 344
LDLW -16
NCHECK 344
LOADC
CONST 5
JNEQ L266
!           IF obj.type.form = Record THEN
LINE 345
LDLW -16
NCHECK 345
LDNW 20
NCHECK 345
LOADW
CONST 13
JNEQ L269
!             obj0 := topScope.next;  (*check whether this is base of previously declared pointer types*)
LINE 346
LDGW OMSPB.topScope
NCHECK 346
LDNW 12
STLW -20
LABEL L270
!             WHILE obj0 # obj DO
LINE 347
LDLW -20
LDLW -16
JEQ L269
!               IF (obj0.type.form = Pointer) & (obj0.type.base = obj.type) & (obj0.type.ref > 0) THEN Write(R, obj0.type.ref) END ;
LINE 348
LDLW -20
NCHECK 348
LDNW 20
NCHECK 348
LOADW
CONST 7
JNEQ L275
LDLW -20
NCHECK 348
LDNW 20
NCHECK 348
LDNW 28
LDLW -16
NCHECK 348
LDNW 20
JNEQ L275
LDLW -20
NCHECK 348
LDNW 20
NCHECK 348
LDNW 4
JLEQZ L275
LDLW -20
NCHECK 348
LDNW 20
NCHECK 348
LDNW 4
GLOBAL POFiles.Rider
LOCAL -72
GLOBAL OMSPB.Write
CALL 3
LABEL L275
!               obj0 := obj0.next
LINE 349
LDLW -20
NCHECK 349
LDNW 12
STLW -20
JUMP L270
LABEL L269
!           Write(R, 0)
LINE 352
CONST 0
GLOBAL POFiles.Rider
LOCAL -72
GLOBAL OMSPB.Write
CALL 3
JUMP L263
LABEL L266
!         ELSIF obj.class = Const THEN Files.WriteNum(R, obj.val)
LINE 353
LDLW -16
NCHECK 353
LOADC
CONST 1
JNEQ L279
LDLW -16
NCHECK 353
LDNW 56
GLOBAL POFiles.Rider
LOCAL -72
GLOBAL POFiles.WriteNum
CALL 3
JUMP L263
LABEL L279
!         ELSIF obj.class IN {Var, StoredConst} THEN
LINE 354
CONST 1
LDLW -16
NCHECK 354
LOADC
CONST 32
BOUND 354
LSL
CONST 516
BITAND
JEQZ L263
!           IF obj.type.form = String THEN Files.WriteNum(R, obj.val DIV 10000H*10000H + obj.exno)
LINE 355
LDLW -16
NCHECK 355
LDNW 20
NCHECK 355
LOADW
CONST 11
JNEQ L284
LDLW -16
NCHECK 355
LDNW 56
CONST 65536
DIV
CONST 65536
TIMES
LDLW -16
NCHECK 355
CONST 1
LDIC
PLUS
GLOBAL POFiles.Rider
LOCAL -72
GLOBAL POFiles.WriteNum
CALL 3
JUMP L263
LABEL L284
!           ELSE Files.WriteNum(R, obj.exno)
LINE 356
LDLW -16
NCHECK 356
CONST 1
LDIC
GLOBAL POFiles.Rider
LOCAL -72
GLOBAL POFiles.WriteNum
CALL 3
LABEL L263
!       obj := obj.next
LINE 360
LDLW -16
NCHECK 360
LDNW 12
STLW -16
JUMP L258
LABEL L260
!     REPEAT Write(R, 0) UNTIL Files.Length(F) MOD 4 = 0;
LINE 362
CONST 0
GLOBAL POFiles.Rider
LOCAL -72
GLOBAL OMSPB.Write
CALL 3
LDLW -56
GLOBAL POFiles.Length
CALLW 1
CONST 4
MOD
JNEQZ L260
!     FOR Ref := LastForm + 1 TO maxTypTab-1 DO typtab[Ref] := NIL END ;
LINE 363
CONST 19
STGW OMSPB.Ref
LABEL L287
LDGW OMSPB.Ref
CONST 63
JGT L288
CONST 0
GLOBAL OMSPB.typtab
LDGW OMSPB.Ref
CONST 64
BOUND 363
STIW
LDGW OMSPB.Ref
INC
STGW OMSPB.Ref
JUMP L287
LABEL L288
!     Files.Set(R, F, 0); CRC32.reset; Files.ReadInt(R, x);  (* compute key (checksum) *)
LINE 364
CONST 0
LDLW -56
GLOBAL POFiles.Rider
LOCAL -72
GLOBAL POFiles.Set
CALL 4
GLOBAL CRC32.reset
CALL 0
LOCAL -4
GLOBAL POFiles.Rider
LOCAL -72
GLOBAL POFiles.ReadInt
CALL 3
LABEL L289
!     WHILE ~R.eof DO CRC32.write(x); Files.ReadInt(R, x) END; sum := CRC32.read();
LINE 365
LDLC -72
JNEQZ L291
LDLW -4
GLOBAL CRC32.write
CALL 1
LOCAL -4
GLOBAL POFiles.Rider
LOCAL -72
GLOBAL POFiles.ReadInt
CALL 3
JUMP L289
LABEL L291
GLOBAL CRC32.read
CALLW 0
STLW -8
!     IF ~oldSF OR (sum # oldkey) THEN
LINE 366
LDLC -85
JEQZ L293
LDLW -8
LDLW -12
JEQ L294
LABEL L293
!       IF ~oldSF OR newSF THEN
LINE 367
LDLC -85
JEQZ L296
LDLW 16
LOADC
JEQZ L297
LABEL L296
!         key := sum; newSF := TRUE; Files.Set(R, F, 4); Files.WriteInt(R, sum); Files.Register(F)  (*insert checksum*)
LINE 368
LDLW -8
LDLW 20
STOREW
CONST 1
LDLW 16
STOREC
CONST 4
LDLW -56
GLOBAL POFiles.Rider
LOCAL -72
GLOBAL POFiles.Set
CALL 4
LDLW -8
GLOBAL POFiles.Rider
LOCAL -72
GLOBAL POFiles.WriteInt
CALL 3
LDLW -56
GLOBAL POFiles.Register
CALL 1
RETURN
LABEL L297
!       ELSE S.Mark("new symbol file inhibited")
LINE 369
CONST 26
GLOBAL OMSPB.%9
GLOBAL OMSPS.Mark
CALL 2
RETURN
LABEL L294
!     ELSE newSF := FALSE; key := sum; Files.Close(F)
LINE 371
CONST 0
LDLW 16
STOREC
LDLW -8
LDLW 20
STOREW
LDLW -56
GLOBAL POFiles.Close
CALL 1
RETURN
END

PROC OMSPB.Init 0 2 0
!   PROCEDURE Init*;
LINE 375
!   BEGIN topScope := universe; nofmod := 1
LINE 376
LDGW OMSPB.universe
STGW OMSPB.topScope
CONST 1
STGW OMSPB.nofmod
RETURN
END

PROC OMSPB.type2 4 4 0x00810001
!   PROCEDURE type2(ref, form, size: INTEGER; base: Type): Type;
LINE 379
!   BEGIN NEW(tp); tp.form := form; tp.size := size; tp.ref := ref; tp.base := base;
LINE 381
CONST 44
GLOBAL OMSPB.TypeDesc
GLOBAL NEW
CALLW 2
STLW -4
LDLW 16
LDLW -4
NCHECK 381
STOREW
LDLW 20
LDLW -4
NCHECK 381
STNW 32
LDLW 12
LDLW -4
NCHECK 381
STNW 4
LDLW 24
LDLW -4
NCHECK 381
STNW 28
!     IF ref >= 0 THEN typtab[ref] := tp END; RETURN tp
LINE 382
LDLW 12
JLTZ L302
LDLW -4
GLOBAL OMSPB.typtab
LDLW 12
CONST 64
BOUND 382
STIW
LABEL L302
LDLW -4
RETURN
END

PROC OMSPB.type 0 5 0
!   PROCEDURE type(ref, form, size: INTEGER): Type;
LINE 385
!   BEGIN RETURN  type2(ref, form, size, NIL)
LINE 386
CONST 0
LDLW 20
LDLW 16
LDLW 12
GLOBAL OMSPB.type2
CALLW 4
RETURN
END

PROC OMSPB.enter 4 7 0x00910001
!   PROCEDURE enter(name: ARRAY OF CHAR; cl: INTEGER; type: Type; n: INTEGER);
LINE 389
!   BEGIN NEW(obj); obj.name := name; obj.class := cl; obj.type := type; obj.val := n; obj.dsc := NIL;
LINE 391
CONST 60
GLOBAL OMSPB.ObjDesc
GLOBAL NEW
CALLW 2
STLW -4
LDLW -4
NCHECK 391
CONST 24
OFFSET
CONST 32
SWAP
LDLW 16
LDLW 12
CONST 1
CONST 1
GLOBAL FLEXASSIGN
CALL 6
LDLW 20
CONVNC
LDLW -4
NCHECK 391
STOREC
LDLW 24
LDLW -4
NCHECK 391
STNW 20
LDLW 28
LDLW -4
NCHECK 391
STNW 56
CONST 0
LDLW -4
NCHECK 391
STNW 16
!     IF cl = Typ THEN type.typobj := obj END ;
LINE 392
LDLW 20
CONST 5
JNEQ L305
LDLW -4
LDLW 24
NCHECK 392
STNW 24
LABEL L305
!     obj.next := system; system := obj
LINE 393
LDGW OMSPB.system
LDLW -4
NCHECK 393
STNW 12
LDLW -4
STGW OMSPB.system
RETURN
END

PROC OMSPB.%main 0 6 0
!   byteType := type(Byte, Int, 1);
LINE 397
CONST 1
CONST 4
CONST 1
GLOBAL OMSPB.type
CALLW 3
STGW OMSPB.byteType
!   boolType := type(Bool, Bool, 1);
LINE 398
CONST 1
CONST 2
CONST 2
GLOBAL OMSPB.type
CALLW 3
STGW OMSPB.boolType
!   charType := type(Char, Char,1);
LINE 399
CONST 1
CONST 3
CONST 3
GLOBAL OMSPB.type
CALLW 3
STGW OMSPB.charType
!   byteSetType := type(ByteSet, Set, 1);
LINE 400
CONST 1
CONST 6
CONST 16
GLOBAL OMSPB.type
CALLW 3
STGW OMSPB.byteSetType
!   intType := type(Int, Int, 2);
LINE 401
CONST 2
CONST 4
CONST 4
GLOBAL OMSPB.type
CALLW 3
STGW OMSPB.intType
!   setType := type(Set, Set, 2);
LINE 402
CONST 2
CONST 6
CONST 6
GLOBAL OMSPB.type
CALLW 3
STGW OMSPB.setType
!   nilType := type(NilTyp, NilTyp, 2);
LINE 403
CONST 2
CONST 8
CONST 8
GLOBAL OMSPB.type
CALLW 3
STGW OMSPB.nilType
!   noType := type(NoTyp, NoTyp, 2);
LINE 404
CONST 2
CONST 9
CONST 9
GLOBAL OMSPB.type
CALLW 3
STGW OMSPB.noType
!   strType := type(String, String, 4);
LINE 405
CONST 4
CONST 11
CONST 11
GLOBAL OMSPB.type
CALLW 3
STGW OMSPB.strType
!   ptrByteType := type2(PointerToByte, Pointer, 2, byteType);
LINE 406
LDGW OMSPB.byteType
CONST 2
CONST 7
CONST 14
GLOBAL OMSPB.type2
CALLW 4
STGW OMSPB.ptrByteType
!   ptrIntType := type2(Pointer, Pointer, 2, intType);
LINE 407
LDGW OMSPB.intType
CONST 2
CONST 7
CONST 7
GLOBAL OMSPB.type2
CALLW 4
STGW OMSPB.ptrIntType
!   ptrByteSetType := type2(PointerToByteSet, Pointer, 2, byteSetType);
LINE 408
LDGW OMSPB.byteSetType
CONST 2
CONST 7
CONST 18
GLOBAL OMSPB.type2
CALLW 4
STGW OMSPB.ptrByteSetType
!   ptrSetType := type2(PointerToSet, Pointer, 2, setType);
LINE 409
LDGW OMSPB.setType
CONST 2
CONST 7
CONST 17
GLOBAL OMSPB.type2
CALLW 4
STGW OMSPB.ptrSetType
!   system := NIL;  (*n = procno*10 + nofpar*)
LINE 413
CONST 0
STGW OMSPB.system
!   enter("ABS", SFunc, intType, 1); (*functions*)
LINE 414
CONST 1
LDGW OMSPB.intType
CONST 7
CONST 4
GLOBAL OMSPB.%10
GLOBAL OMSPB.enter
CALL 5
!   enter("ODD", SFunc, boolType, 11);
LINE 415
CONST 11
LDGW OMSPB.boolType
CONST 7
CONST 4
GLOBAL OMSPB.%11
GLOBAL OMSPB.enter
CALL 5
!   enter("ORD", SFunc, intType, 41);
LINE 416
CONST 41
LDGW OMSPB.intType
CONST 7
CONST 4
GLOBAL OMSPB.%12
GLOBAL OMSPB.enter
CALL 5
!   enter("CHR", SFunc, charType, 51);
LINE 417
CONST 51
LDGW OMSPB.charType
CONST 7
CONST 4
GLOBAL OMSPB.%13
GLOBAL OMSPB.enter
CALL 5
!   enter("LEN", SFunc, intType, 61);
LINE 418
CONST 61
LDGW OMSPB.intType
CONST 7
CONST 4
GLOBAL OMSPB.%14
GLOBAL OMSPB.enter
CALL 5
!   enter("TOSET", SFunc, setType, 71);
LINE 419
CONST 71
LDGW OMSPB.setType
CONST 7
CONST 6
GLOBAL OMSPB.%15
GLOBAL OMSPB.enter
CALL 5
!   enter("BIT", SFunc, boolType, 142);
LINE 420
CONST 142
LDGW OMSPB.boolType
CONST 7
CONST 4
GLOBAL OMSPB.%16
GLOBAL OMSPB.enter
CALL 5
!   enter("PTR", SFunc, noType, 152);
LINE 421
CONST 152
LDGW OMSPB.noType
CONST 7
CONST 4
GLOBAL OMSPB.%17
GLOBAL OMSPB.enter
CALL 5
!   enter("INC", SProc, noType, 1); (*procedures*)
LINE 422
CONST 1
LDGW OMSPB.noType
CONST 6
CONST 4
GLOBAL OMSPB.%18
GLOBAL OMSPB.enter
CALL 5
!   enter("DEC", SProc, noType, 11);
LINE 423
CONST 11
LDGW OMSPB.noType
CONST 6
CONST 4
GLOBAL OMSPB.%19
GLOBAL OMSPB.enter
CALL 5
!   enter("INCL", SProc, noType, 22);
LINE 424
CONST 22
LDGW OMSPB.noType
CONST 6
CONST 5
GLOBAL OMSPB.%20
GLOBAL OMSPB.enter
CALL 5
!   enter("EXCL", SProc, noType, 32);
LINE 425
CONST 32
LDGW OMSPB.noType
CONST 6
CONST 5
GLOBAL OMSPB.%21
GLOBAL OMSPB.enter
CALL 5
!   enter("ASSERT", SProc, noType, 41);
LINE 426
CONST 41
LDGW OMSPB.noType
CONST 6
CONST 7
GLOBAL OMSPB.%22
GLOBAL OMSPB.enter
CALL 5
!   enter("BIC", SProc, noType, 52);
LINE 427
CONST 52
LDGW OMSPB.noType
CONST 6
CONST 4
GLOBAL OMSPB.%23
GLOBAL OMSPB.enter
CALL 5
!   enter("BIS", SProc, noType, 62);
LINE 428
CONST 62
LDGW OMSPB.noType
CONST 6
CONST 4
GLOBAL OMSPB.%24
GLOBAL OMSPB.enter
CALL 5
!   enter("XOR", SProc, noType, 72);
LINE 429
CONST 72
LDGW OMSPB.noType
CONST 6
CONST 4
GLOBAL OMSPB.%25
GLOBAL OMSPB.enter
CALL 5
!   enter("AND", SProc, noType, 82); (*91, 101 and 123 are in SYSTEM pseudo-module*)
LINE 430
CONST 82
LDGW OMSPB.noType
CONST 6
CONST 4
GLOBAL OMSPB.%26
GLOBAL OMSPB.enter
CALL 5
!   enter("CLRC", SProc, noType, 130);
LINE 431
CONST 130
LDGW OMSPB.noType
CONST 6
CONST 5
GLOBAL OMSPB.%27
GLOBAL OMSPB.enter
CALL 5
!   enter("NOP", SProc, noType, 140);
LINE 432
CONST 140
LDGW OMSPB.noType
CONST 6
CONST 4
GLOBAL OMSPB.%28
GLOBAL OMSPB.enter
CALL 5
!   enter("ADC", SProc, noType, 152);
LINE 433
CONST 152
LDGW OMSPB.noType
CONST 6
CONST 4
GLOBAL OMSPB.%29
GLOBAL OMSPB.enter
CALL 5
!   enter("SBC", SProc, noType, 162);
LINE 434
CONST 162
LDGW OMSPB.noType
CONST 6
CONST 4
GLOBAL OMSPB.%30
GLOBAL OMSPB.enter
CALL 5
!   enter("RLA", SProc, noType, 172);
LINE 435
CONST 172
LDGW OMSPB.noType
CONST 6
CONST 4
GLOBAL OMSPB.%31
GLOBAL OMSPB.enter
CALL 5
!   enter("RLC", SProc, noType, 181);
LINE 436
CONST 181
LDGW OMSPB.noType
CONST 6
CONST 4
GLOBAL OMSPB.%32
GLOBAL OMSPB.enter
CALL 5
!   enter("RRA", SProc, noType, 192);
LINE 437
CONST 192
LDGW OMSPB.noType
CONST 6
CONST 4
GLOBAL OMSPB.%33
GLOBAL OMSPB.enter
CALL 5
!   enter("RRC", SProc, noType, 201); (*211 and 221 are in SYSTEM pseudo-module*)
LINE 438
CONST 201
LDGW OMSPB.noType
CONST 6
CONST 4
GLOBAL OMSPB.%34
GLOBAL OMSPB.enter
CALL 5
!   enter("SWPB", SProc, intType, 231);
LINE 439
CONST 231
LDGW OMSPB.intType
CONST 6
CONST 5
GLOBAL OMSPB.%35
GLOBAL OMSPB.enter
CALL 5
!   enter("NEG", SProc, intType, 241);
LINE 440
CONST 241
LDGW OMSPB.intType
CONST 6
CONST 4
GLOBAL OMSPB.%36
GLOBAL OMSPB.enter
CALL 5
!   enter("SET", Typ, setType, 0);   (*types*)
LINE 441
CONST 0
LDGW OMSPB.setType
CONST 5
CONST 4
GLOBAL OMSPB.%37
GLOBAL OMSPB.enter
CALL 5
!   enter("BYTESET", Typ, byteSetType, 0);
LINE 442
CONST 0
LDGW OMSPB.byteSetType
CONST 5
CONST 8
GLOBAL OMSPB.%38
GLOBAL OMSPB.enter
CALL 5
!   enter("BOOLEAN", Typ, boolType, 0);
LINE 443
CONST 0
LDGW OMSPB.boolType
CONST 5
CONST 8
GLOBAL OMSPB.%39
GLOBAL OMSPB.enter
CALL 5
!   enter("BYTE", Typ, byteType, 0);
LINE 444
CONST 0
LDGW OMSPB.byteType
CONST 5
CONST 5
GLOBAL OMSPB.%40
GLOBAL OMSPB.enter
CALL 5
!   enter("CHAR", Typ, charType, 0);
LINE 445
CONST 0
LDGW OMSPB.charType
CONST 5
CONST 5
GLOBAL OMSPB.%41
GLOBAL OMSPB.enter
CALL 5
!   enter("INTEGER", Typ, intType, 0);
LINE 446
CONST 0
LDGW OMSPB.intType
CONST 5
CONST 8
GLOBAL OMSPB.%42
GLOBAL OMSPB.enter
CALL 5
!   enter("PBYTE", Typ, ptrByteType, 0);
LINE 447
CONST 0
LDGW OMSPB.ptrByteType
CONST 5
CONST 6
GLOBAL OMSPB.%43
GLOBAL OMSPB.enter
CALL 5
!   enter("PINTEGER", Typ, ptrIntType, 0);
LINE 448
CONST 0
LDGW OMSPB.ptrIntType
CONST 5
CONST 9
GLOBAL OMSPB.%44
GLOBAL OMSPB.enter
CALL 5
!   enter("PBYTESET", Typ, ptrByteSetType, 0);
LINE 449
CONST 0
LDGW OMSPB.ptrByteSetType
CONST 5
CONST 9
GLOBAL OMSPB.%45
GLOBAL OMSPB.enter
CALL 5
!   enter("PSET", Typ, ptrSetType, 0);
LINE 450
CONST 0
LDGW OMSPB.ptrSetType
CONST 5
CONST 5
GLOBAL OMSPB.%46
GLOBAL OMSPB.enter
CALL 5
!   topScope := NIL; OpenScope; topScope.next := system; universe := topScope;
LINE 452
CONST 0
STGW OMSPB.topScope
GLOBAL OMSPB.OpenScope
CALL 0
LDGW OMSPB.system
LDGW OMSPB.topScope
NCHECK 452
STNW 12
LDGW OMSPB.topScope
STGW OMSPB.universe
!   system := NIL;  (* initialize "unsafe" pseudo-module SYSTEM*)
LINE 454
CONST 0
STGW OMSPB.system
!   enter("COND", SFunc, boolType, 191);
LINE 455
CONST 191
LDGW OMSPB.boolType
CONST 7
CONST 5
GLOBAL OMSPB.%47
GLOBAL OMSPB.enter
CALL 5
!   enter("CMP", SFunc, boolType, 223);
LINE 456
CONST 223
LDGW OMSPB.boolType
CONST 7
CONST 4
GLOBAL OMSPB.%48
GLOBAL OMSPB.enter
CALL 5
!   enter("SIZE", SFunc, intType, 181);
LINE 457
CONST 181
LDGW OMSPB.intType
CONST 7
CONST 5
GLOBAL OMSPB.%49
GLOBAL OMSPB.enter
CALL 5
!   enter("ADR", SFunc, intType, 171);
LINE 458
CONST 171
LDGW OMSPB.intType
CONST 7
CONST 4
GLOBAL OMSPB.%50
GLOBAL OMSPB.enter
CALL 5
!   enter("VAL", SFunc, noType, 162);
LINE 459
CONST 162
LDGW OMSPB.noType
CONST 7
CONST 4
GLOBAL OMSPB.%51
GLOBAL OMSPB.enter
CALL 5
!   enter("BIC_SR", SProc, noType, 91); (*procedures*)
LINE 460
CONST 91
LDGW OMSPB.noType
CONST 6
CONST 7
GLOBAL OMSPB.%52
GLOBAL OMSPB.enter
CALL 5
!   enter("BIS_SR", SProc, noType, 101);
LINE 461
CONST 101
LDGW OMSPB.noType
CONST 6
CONST 7
GLOBAL OMSPB.%53
GLOBAL OMSPB.enter
CALL 5
!   enter("COPY", SProc, noType, 123);
LINE 462
CONST 123
LDGW OMSPB.noType
CONST 6
CONST 5
GLOBAL OMSPB.%54
GLOBAL OMSPB.enter
CALL 5
!   enter("BIC_SR_ON_EXIT", SProc, noType, 211);
LINE 463
CONST 211
LDGW OMSPB.noType
CONST 6
CONST 15
GLOBAL OMSPB.%55
GLOBAL OMSPB.enter
CALL 5
!   enter("BIS_SR_ON_EXIT", SProc, noType, 221)
LINE 464
CONST 221
LDGW OMSPB.noType
CONST 6
CONST 15
GLOBAL OMSPB.%56
GLOBAL OMSPB.enter
CALL 5
RETURN
END

! Global variables
GLOVAR OMSPB.topScope 4
GLOVAR OMSPB.universe 4
GLOVAR OMSPB.system 4
GLOVAR OMSPB.byteType 4
GLOVAR OMSPB.boolType 4
GLOVAR OMSPB.charType 4
GLOVAR OMSPB.byteSetType 4
GLOVAR OMSPB.intType 4
GLOVAR OMSPB.setType 4
GLOVAR OMSPB.nilType 4
GLOVAR OMSPB.noType 4
GLOVAR OMSPB.strType 4
GLOVAR OMSPB.ptrByteType 4
GLOVAR OMSPB.ptrIntType 4
GLOVAR OMSPB.ptrByteSetType 4
GLOVAR OMSPB.ptrSetType 4
GLOVAR OMSPB.nofmod 4
GLOVAR OMSPB.Ref 4
GLOVAR OMSPB.typtab 256
GLOVAR OMSPB.regRTProc 4

! Global pointer map
DEFINE OMSPB.%gcmap
WORD GC_POINTER
WORD OMSPB.topScope
WORD GC_POINTER
WORD OMSPB.universe
WORD GC_POINTER
WORD OMSPB.system
WORD GC_POINTER
WORD OMSPB.byteType
WORD GC_POINTER
WORD OMSPB.boolType
WORD GC_POINTER
WORD OMSPB.charType
WORD GC_POINTER
WORD OMSPB.byteSetType
WORD GC_POINTER
WORD OMSPB.intType
WORD GC_POINTER
WORD OMSPB.setType
WORD GC_POINTER
WORD OMSPB.nilType
WORD GC_POINTER
WORD OMSPB.noType
WORD GC_POINTER
WORD OMSPB.strType
WORD GC_POINTER
WORD OMSPB.ptrByteType
WORD GC_POINTER
WORD OMSPB.ptrIntType
WORD GC_POINTER
WORD OMSPB.ptrByteSetType
WORD GC_POINTER
WORD OMSPB.ptrSetType
WORD GC_BASE
WORD OMSPB.typtab
WORD GC_BLOCK
WORD 0
WORD 64
WORD GC_END

! String "mult def"
DEFINE OMSPB.%1
STRING 6D756C742064656600

! String "invalid import order"
DEFINE OMSPB.%2
STRING 696E76616C696420696D706F7274206F7264657200

! String "conflict with alias"
DEFINE OMSPB.%3
STRING 636F6E666C696374207769746820616C69617300

! String "SYSTEM"
DEFINE OMSPB.%4
STRING 53595354454D00

! String ".sms"
DEFINE OMSPB.%5
STRING 2E736D7300

! String "wrong version"
DEFINE OMSPB.%6
STRING 77726F6E672076657273696F6E00

! String "import not available"
DEFINE OMSPB.%7
STRING 696D706F7274206E6F7420617661696C61626C6500

! String "re-export not found"
DEFINE OMSPB.%8
STRING 72652D6578706F7274206E6F7420666F756E6400

! String "new symbol file inhibited"
DEFINE OMSPB.%9
STRING 6E65772073796D626F6C2066696C6520696E6869626974656400

! String "ABS"
DEFINE OMSPB.%10
STRING 41425300

! String "ODD"
DEFINE OMSPB.%11
STRING 4F444400

! String "ORD"
DEFINE OMSPB.%12
STRING 4F524400

! String "CHR"
DEFINE OMSPB.%13
STRING 43485200

! String "LEN"
DEFINE OMSPB.%14
STRING 4C454E00

! String "TOSET"
DEFINE OMSPB.%15
STRING 544F53455400

! String "BIT"
DEFINE OMSPB.%16
STRING 42495400

! String "PTR"
DEFINE OMSPB.%17
STRING 50545200

! String "INC"
DEFINE OMSPB.%18
STRING 494E4300

! String "DEC"
DEFINE OMSPB.%19
STRING 44454300

! String "INCL"
DEFINE OMSPB.%20
STRING 494E434C00

! String "EXCL"
DEFINE OMSPB.%21
STRING 4558434C00

! String "ASSERT"
DEFINE OMSPB.%22
STRING 41535345525400

! String "BIC"
DEFINE OMSPB.%23
STRING 42494300

! String "BIS"
DEFINE OMSPB.%24
STRING 42495300

! String "XOR"
DEFINE OMSPB.%25
STRING 584F5200

! String "AND"
DEFINE OMSPB.%26
STRING 414E4400

! String "CLRC"
DEFINE OMSPB.%27
STRING 434C524300

! String "NOP"
DEFINE OMSPB.%28
STRING 4E4F5000

! String "ADC"
DEFINE OMSPB.%29
STRING 41444300

! String "SBC"
DEFINE OMSPB.%30
STRING 53424300

! String "RLA"
DEFINE OMSPB.%31
STRING 524C4100

! String "RLC"
DEFINE OMSPB.%32
STRING 524C4300

! String "RRA"
DEFINE OMSPB.%33
STRING 52524100

! String "RRC"
DEFINE OMSPB.%34
STRING 52524300

! String "SWPB"
DEFINE OMSPB.%35
STRING 5357504200

! String "NEG"
DEFINE OMSPB.%36
STRING 4E454700

! String "SET"
DEFINE OMSPB.%37
STRING 53455400

! String "BYTESET"
DEFINE OMSPB.%38
STRING 4259544553455400

! String "BOOLEAN"
DEFINE OMSPB.%39
STRING 424F4F4C45414E00

! String "BYTE"
DEFINE OMSPB.%40
STRING 4259544500

! String "CHAR"
DEFINE OMSPB.%41
STRING 4348415200

! String "INTEGER"
DEFINE OMSPB.%42
STRING 494E544547455200

! String "PBYTE"
DEFINE OMSPB.%43
STRING 504259544500

! String "PINTEGER"
DEFINE OMSPB.%44
STRING 50494E544547455200

! String "PBYTESET"
DEFINE OMSPB.%45
STRING 504259544553455400

! String "PSET"
DEFINE OMSPB.%46
STRING 5053455400

! String "COND"
DEFINE OMSPB.%47
STRING 434F4E4400

! String "CMP"
DEFINE OMSPB.%48
STRING 434D5000

! String "SIZE"
DEFINE OMSPB.%49
STRING 53495A4500

! String "ADR"
DEFINE OMSPB.%50
STRING 41445200

! String "VAL"
DEFINE OMSPB.%51
STRING 56414C00

! String "BIC_SR"
DEFINE OMSPB.%52
STRING 4249435F535200

! String "BIS_SR"
DEFINE OMSPB.%53
STRING 4249535F535200

! String "COPY"
DEFINE OMSPB.%54
STRING 434F505900

! String "BIC_SR_ON_EXIT"
DEFINE OMSPB.%55
STRING 4249435F53525F4F4E5F4558495400

! String "BIS_SR_ON_EXIT"
DEFINE OMSPB.%56
STRING 4249535F53525F4F4E5F4558495400

! Descriptor for ObjDesc
DEFINE OMSPB.ObjDesc
WORD 0x00000071
WORD 0
WORD OMSPB.ObjDesc.%anc

DEFINE OMSPB.ObjDesc.%anc
WORD OMSPB.ObjDesc

! Descriptor for ModDesc
DEFINE OMSPB.ModDesc
WORD 0x00000071
WORD 1
WORD OMSPB.ModDesc.%anc

DEFINE OMSPB.ModDesc.%anc
WORD OMSPB.ObjDesc
WORD OMSPB.ModDesc

! Descriptor for TypeDesc
DEFINE OMSPB.TypeDesc
WORD 0x000001c1
WORD 0
WORD OMSPB.TypeDesc.%anc

DEFINE OMSPB.TypeDesc.%anc
WORD OMSPB.TypeDesc

! Pointer maps
DEFINE OMSPB.Import.%map
WORD 12
WORD 16
WORD -16
WORD -20
WORD -24
WORD -92
WORD -96
WORD GC_END

DEFINE OMSPB.Export.%map
WORD 12
WORD 16
WORD 20
WORD -16
WORD -20
WORD -56
WORD -60
WORD -64
WORD -76
WORD GC_END

! End of file
