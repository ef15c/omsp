!! (SYMFILE #OMSPS 0x00030300 #OMSPS.%main 1 #OMSPS.Mod)
!! (CONST #IdLen* INTCONST 32)
!! (CONST #NKW INTCONST 34)
!! (CONST #maxExp INTCONST 38)
!! (CONST #stringBufSize* INTCONST 256)
!! (CONST #null INTCONST 0)
!! (CONST #times* INTCONST 1)
!! (CONST #rdiv* INTCONST 2)
!! (CONST #div* INTCONST 3)
!! (CONST #mod* INTCONST 4)
!! (CONST #and* INTCONST 5)
!! (CONST #plus* INTCONST 6)
!! (CONST #minus* INTCONST 7)
!! (CONST #or* INTCONST 8)
!! (CONST #eql* INTCONST 9)
!! (CONST #neq* INTCONST 10)
!! (CONST #lss* INTCONST 11)
!! (CONST #geq* INTCONST 12)
!! (CONST #gtr* INTCONST 13)
!! (CONST #leq* INTCONST 14)
!! (CONST #in* INTCONST 15)
!! (CONST #is* INTCONST 16)
!! (CONST #arrow* INTCONST 17)
!! (CONST #period* INTCONST 18)
!! (CONST #emark* INTCONST 19)
!! (CONST #char* INTCONST 20)
!! (CONST #int* INTCONST 21)
!! (CONST #false* INTCONST 23)
!! (CONST #true* INTCONST 24)
!! (CONST #nil* INTCONST 25)
!! (CONST #string* INTCONST 26)
!! (CONST #not* INTCONST 27)
!! (CONST #lparen* INTCONST 28)
!! (CONST #lbrak* INTCONST 29)
!! (CONST #lbrace* INTCONST 30)
!! (CONST #ident* INTCONST 31)
!! (CONST #if* INTCONST 32)
!! (CONST #while* INTCONST 34)
!! (CONST #repeat* INTCONST 35)
!! (CONST #case* INTCONST 36)
!! (CONST #for* INTCONST 37)
!! (CONST #comma* INTCONST 40)
!! (CONST #colon* INTCONST 41)
!! (CONST #becomes* INTCONST 42)
!! (CONST #upto* INTCONST 43)
!! (CONST #rparen* INTCONST 44)
!! (CONST #rbrak* INTCONST 45)
!! (CONST #rbrace* INTCONST 46)
!! (CONST #then* INTCONST 47)
!! (CONST #of* INTCONST 48)
!! (CONST #do* INTCONST 49)
!! (CONST #to* INTCONST 50)
!! (CONST #by* INTCONST 51)
!! (CONST #semicolon* INTCONST 52)
!! (CONST #end* INTCONST 53)
!! (CONST #bar* INTCONST 54)
!! (CONST #else* INTCONST 55)
!! (CONST #elsif* INTCONST 56)
!! (CONST #until* INTCONST 57)
!! (CONST #return* INTCONST 58)
!! (CONST #array* INTCONST 60)
!! (CONST #record* INTCONST 61)
!! (CONST #pointer* INTCONST 62)
!! (CONST #const* INTCONST 63)
!! (CONST #type* INTCONST 64)
!! (CONST #var* INTCONST 65)
!! (CONST #procedure* INTCONST 66)
!! (CONST #begin* INTCONST 67)
!! (CONST #import* INTCONST 68)
!! (CONST #module* INTCONST 69)
!! (CONST #eot INTCONST 70)
!! (TYPE #Ident* !1 (ARRAY 32 CHAR))
!! (GLOBAL #ival- #OMSPS.ival INTEGER)
!! (GLOBAL #slen- #OMSPS.slen INTEGER)
!! (GLOBAL #id- #OMSPS.id =1)
!! (GLOBAL #str- #OMSPS.str !2 (ARRAY 256 CHAR))
!! (GLOBAL #errcnt- #OMSPS.errcnt INTEGER)
!! (GLOBAL #ch #OMSPS.ch CHAR)
!! (GLOBAL #errpos #OMSPS.errpos INTEGER)
!! (GLOBAL #R #OMSPS.R ?3 #Texts 11 #Reader (RECORD #Texts.Reader 32 VOID
!!     (FIELD #eot* 0 BOOLEAN)
!!     (FIELD #col* 4 INTEGER)
!!     (FIELD #ref 8 ?4 #Texts 1 #Piece (POINTER))
!!     (FIELD #org 12 INTEGER)
!!     (FIELD #off 16 INTEGER)
!!     (FIELD #rider 20 ?5 #POFiles 6 #Rider (RECORD #POFiles.Rider 12 VOID
!!         (FIELD #eof* 0 BOOLEAN)
!!         (FIELD #res* 4 INTEGER)
!!         (FIELD #base 8 ?6 #POFiles 1 #File (POINTER))))))
!! (TARGET =6 ?7 #POFiles 2 #FileDesc (RECORD #POFiles.FileDesc 68 VOID
!!     (FIELD #file 0 ?8 #Files 1 #File (POINTER))
!!     (FIELD #tmpName 4 ?9 #POFiles 4 ANON (ARRAY 32 CHAR))
!!     (FIELD #name 36 =9)))
!! (TARGET =8 ?10 #Files 2 #FileDesc (RECORD #Files.FileDesc 8 VOID
!!     (FIELD #file- 0 SYSTEM.LONGPTR)))
!! (TARGET =4 ?11 #Texts 2 #PieceDesc (RECORD #Texts.PieceDesc 24 VOID
!!     (FIELD #f 0 =6)
!!     (FIELD #off 4 INTEGER)
!!     (FIELD #len 8 INTEGER)
!!     (FIELD #col 12 INTEGER)
!!     (FIELD #prev 16 =4)
!!     (FIELD #next 20 =4)))
!! (GLOBAL #W #OMSPS.W ?12 #Texts 17 #Writer (RECORD #Texts.Writer 20 VOID
!!     (FIELD #buf* 0 ?13 #Texts 15 #Buffer (POINTER))
!!     (FIELD #col* 4 INTEGER)
!!     (FIELD #rider 8 =5)))
!! (TARGET =13 ?14 #Texts 16 #BufDesc (RECORD #Texts.BufDesc 12 VOID
!!     (FIELD #len* 0 INTEGER)
!!     (FIELD #header 4 =4)
!!     (FIELD #last 8 =4)))
!! (GLOBAL #k #OMSPS.k INTEGER)
!! (GLOBAL #KWX #OMSPS.KWX !15 (ARRAY 10 INTEGER))
!! (GLOBAL #keyTab #OMSPS.keyTab !16 (ARRAY 34 !17 (RECORD #OMSPS.%43 16 VOID
!!       (FIELD #sym 0 INTEGER)
!!       (FIELD #id 4 !18 (ARRAY 12 CHAR)))))
!! (PROCEDURE #CopyId* 50 #OMSPS.CopyId !19 (PROC 1 VOID
!!     (VPARAM #ident 12 =1)))
!! (PROCEDURE #Pos* 54 #OMSPS.Pos !20 (PROC 0 INTEGER))
!! (DEF !21 (FLEX CHAR))
!! (PROCEDURE #Mark* 58 #OMSPS.Mark !22 (PROC 2 VOID
!!     (CPARAM #msg 12 =21))
!!   (LOCAL #p -4 INTEGER))
!! (DEF !23 (FLEX CHAR))
!! (PROCEDURE #DebugHex* 68 #OMSPS.DebugHex !24 (PROC 3 VOID
!!     (CPARAM #msg 12 =23)
!!     (PARAM #v 20 INTEGER))
!!   (LOCAL #p -4 INTEGER))
!! (DEF !25 (FLEX CHAR))
!! (PROCEDURE #DebugString* 75 #OMSPS.DebugString !26 (PROC 4 VOID
!!     (CPARAM #msg 12 =25)
!!     (CPARAM #v 20 =25))
!!   (LOCAL #p -4 INTEGER))
!! (PROCEDURE #Identifier 82 #OMSPS.Identifier !27 (PROC 1 VOID
!!     (VPARAM #sym 12 INTEGER))
!!   (LOCAL #i -4 INTEGER)
!!   (LOCAL #k -8 INTEGER))
!! (PROCEDURE #String 97 #OMSPS.String !28 (PROC 0 VOID)
!!   (LOCAL #i -4 INTEGER))
!! (PROCEDURE #HexString 109 #OMSPS.HexString !29 (PROC 0 VOID)
!!   (LOCAL #i -4 INTEGER)
!!   (LOCAL #m -8 INTEGER)
!!   (LOCAL #n -12 INTEGER))
!! (PROCEDURE #Number 129 #OMSPS.Number !30 (PROC 1 VOID
!!     (VPARAM #sym 12 INTEGER))
!!   (CONST #max INTCONST 2147483647)
!!   (LOCAL #i -4 INTEGER)
!!   (LOCAL #k -8 INTEGER)
!!   (LOCAL #n -12 INTEGER)
!!   (LOCAL #h -16 INTEGER)
!!   (LOCAL #d -80 !31 (ARRAY 16 INTEGER)))
!! (PROCEDURE #comment 160 #OMSPS.comment !32 (PROC 0 VOID))
!! (PROCEDURE #Get* 174 #OMSPS.Get !33 (PROC 1 VOID
!!     (VPARAM #sym 12 INTEGER)))
!! (DEF ?34 #Texts 8 #Text (POINTER))
!! (PROCEDURE #Init* 229 #OMSPS.Init !35 (PROC 2 VOID
!!     (PARAM #T 12 =34)
!!     (PARAM #pos 16 INTEGER)))
!! (TARGET =34 ?36 #Texts 9 #TextDesc (RECORD #Texts.TextDesc 24 VOID
!!     (FIELD #len* 0 INTEGER)
!!     (FIELD #changed* 4 BOOLEAN)
!!     (FIELD #notify* 8 ?37 #Texts 10 #Notifier (PROC 4 VOID
!!         (PARAM #T 12 =34)
!!         (PARAM #op 16 INTEGER)
!!         (PARAM #beg 20 INTEGER)
!!         (PARAM #end 24 INTEGER)))
!!     (FIELD #trailer 12 =4)
!!     (FIELD #pce 16 =4)
!!     (FIELD #org 20 INTEGER)))
!! (DEF !38 (FLEX CHAR))
!! (PROCEDURE #EnterKW 233 #OMSPS.EnterKW !39 (PROC 3 VOID
!!     (PARAM #sym 12 INTEGER)
!!     (CPARAM #name 16 =38)))
!! (CHKSUM 0x1d34079e)
!! 
MODULE OMSPS 0x1d34079e 278
IMPORT Texts 0x2d7a25ad
IMPORT Oberon 0x7fd79012
ENDHDR

PROC OMSPS.CopyId 0 3 0x00100001
!   PROCEDURE CopyId*(VAR ident: Ident);
LINE 50
!   BEGIN ident := id
LINE 51
LDLW 12
GLOBAL OMSPS.id
CONST 32
FIXCOPY
RETURN
END

PROC OMSPS.Pos 0 3 0
!   PROCEDURE Pos*(): INTEGER;
LINE 54
!   BEGIN RETURN Texts.Pos(R) - 1
LINE 55
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Pos
CALLW 2
DEC
RETURN
END

PROC OMSPS.Mark 4 5 0x00100001
!   PROCEDURE Mark*(msg: ARRAY OF CHAR);
LINE 58
!   BEGIN p := Pos();
LINE 60
GLOBAL OMSPS.Pos
CALLW 0
STLW -4
!     IF (p > errpos) & (errcnt < 25) THEN
LINE 61
LDLW -4
LDGW OMSPS.errpos
JLEQ L46
LDGW OMSPS.errcnt
CONST 25
JGEQ L46
!       Texts.WriteLn(W); Texts.WriteString(W, "  pos "); Texts.WriteInt(W, p, 1); Texts.Write(W, " ");
LINE 62
GLOBAL Texts.Writer
GLOBAL OMSPS.W
GLOBAL Texts.WriteLn
CALL 2
CONST 7
GLOBAL OMSPS.%1
GLOBAL Texts.Writer
GLOBAL OMSPS.W
GLOBAL Texts.WriteString
CALL 4
CONST 1
LDLW -4
GLOBAL Texts.Writer
GLOBAL OMSPS.W
GLOBAL Texts.WriteInt
CALL 4
CONST 32
ALIGNC
GLOBAL Texts.Writer
GLOBAL OMSPS.W
GLOBAL Texts.Write
CALL 3
!       Texts.WriteString(W, msg); Texts.Append(Oberon.Log, W.buf)
LINE 63
LDLW 16
LDLW 12
GLOBAL Texts.Writer
GLOBAL OMSPS.W
GLOBAL Texts.WriteString
CALL 4
LDGW OMSPS.W
LDGW Oberon.Log
GLOBAL Texts.Append
CALL 2
LABEL L46
!     INC(errcnt); errpos := p + 4
LINE 65
LDGW OMSPS.errcnt
INC
STGW OMSPS.errcnt
LDLW -4
CONST 4
PLUS
STGW OMSPS.errpos
RETURN
END

PROC OMSPS.DebugHex 4 5 0x00100001
!   PROCEDURE DebugHex*(msg: ARRAY OF CHAR; v: INTEGER);
LINE 68
!   BEGIN p := Pos();
LINE 70
GLOBAL OMSPS.Pos
CALLW 0
STLW -4
!     Texts.WriteLn(W); Texts.WriteString(W, msg); Texts.WriteString(W, " at pos "); Texts.WriteInt(W, p, 1); Texts.Write(W, " ");
LINE 71
GLOBAL Texts.Writer
GLOBAL OMSPS.W
GLOBAL Texts.WriteLn
CALL 2
LDLW 16
LDLW 12
GLOBAL Texts.Writer
GLOBAL OMSPS.W
GLOBAL Texts.WriteString
CALL 4
CONST 9
GLOBAL OMSPS.%2
GLOBAL Texts.Writer
GLOBAL OMSPS.W
GLOBAL Texts.WriteString
CALL 4
CONST 1
LDLW -4
GLOBAL Texts.Writer
GLOBAL OMSPS.W
GLOBAL Texts.WriteInt
CALL 4
CONST 32
ALIGNC
GLOBAL Texts.Writer
GLOBAL OMSPS.W
GLOBAL Texts.Write
CALL 3
!     Texts.WriteHex(W, v); Texts.Append(Oberon.Log, W.buf)
LINE 72
LDLW 20
GLOBAL Texts.Writer
GLOBAL OMSPS.W
GLOBAL Texts.WriteHex
CALL 3
LDGW OMSPS.W
LDGW Oberon.Log
GLOBAL Texts.Append
CALL 2
RETURN
END

PROC OMSPS.DebugString 4 5 0x00500001
!   PROCEDURE DebugString*(msg, v: ARRAY OF CHAR);
LINE 75
!   BEGIN p := Pos();
LINE 77
GLOBAL OMSPS.Pos
CALLW 0
STLW -4
!     Texts.WriteLn(W); Texts.WriteString(W, msg); Texts.WriteString(W, " at pos "); Texts.WriteInt(W, p, 1); Texts.Write(W, " ");
LINE 78
GLOBAL Texts.Writer
GLOBAL OMSPS.W
GLOBAL Texts.WriteLn
CALL 2
LDLW 16
LDLW 12
GLOBAL Texts.Writer
GLOBAL OMSPS.W
GLOBAL Texts.WriteString
CALL 4
CONST 9
GLOBAL OMSPS.%2
GLOBAL Texts.Writer
GLOBAL OMSPS.W
GLOBAL Texts.WriteString
CALL 4
CONST 1
LDLW -4
GLOBAL Texts.Writer
GLOBAL OMSPS.W
GLOBAL Texts.WriteInt
CALL 4
CONST 32
ALIGNC
GLOBAL Texts.Writer
GLOBAL OMSPS.W
GLOBAL Texts.Write
CALL 3
!     Texts.WriteString(W, v); Texts.Append(Oberon.Log, W.buf)
LINE 79
LDLW 24
LDLW 20
GLOBAL Texts.Writer
GLOBAL OMSPS.W
GLOBAL Texts.WriteString
CALL 4
LDGW OMSPS.W
LDGW Oberon.Log
GLOBAL Texts.Append
CALL 2
RETURN
END

PROC OMSPS.Identifier 8 5 0x00100001
!   PROCEDURE Identifier(VAR sym: INTEGER);
LINE 82
!   BEGIN i := 0;
LINE 84
CONST 0
STLW -4
LABEL L48
!       IF i < IdLen-1 THEN id[i] := ch; INC(i) END ;
LINE 86
LDLW -4
CONST 31
JGEQ L58
LDGC OMSPS.ch
GLOBAL OMSPS.id
LDLW -4
CONST 32
BOUND 86
STIC
INCL -4
LABEL L58
!       Texts.Read(R, ch)
LINE 87
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
!     UNTIL (ch # "_") & ((ch < "0") OR (ch > "9") & (ch < "A") OR (ch > "Z") & (ch < "a") OR (ch > "z"));
LINE 88
LDGC OMSPS.ch
CONST 95
JEQ L48
LDGC OMSPS.ch
CONST 48
JLT L49
LDGC OMSPS.ch
CONST 57
JLEQ L52
LDGC OMSPS.ch
CONST 65
JLT L49
LABEL L52
LDGC OMSPS.ch
CONST 90
JLEQ L51
LDGC OMSPS.ch
CONST 97
JLT L49
LABEL L51
LDGC OMSPS.ch
CONST 122
JLEQ L48
LABEL L49
!     id[i] := 0X; 
LINE 89
CONST 0
GLOBAL OMSPS.id
LDLW -4
CONST 32
BOUND 89
STIC
!     IF i < 10 THEN k := KWX[i-1];  (*search for keyword*)
LINE 90
LDLW -4
CONST 10
JGEQ L61
GLOBAL OMSPS.KWX
LDLW -4
DEC
CONST 10
BOUND 90
LDIW
STLW -8
LABEL L62
!       WHILE (id # keyTab[k].id) & (k < KWX[i]) DO INC(k) END ;
LINE 91
GLOBAL OMSPS.keyTab
LDLW -8
CONST 34
BOUND 91
CONST 16
TIMES
OFFSET
CONST 4
OFFSET
CONST 12
SWAP
CONST 32
GLOBAL OMSPS.id
GLOBAL COMPARE
CALLW 4
JEQZ L64
LDLW -8
GLOBAL OMSPS.KWX
LDLW -4
CONST 10
BOUND 91
LDIW
JGEQ L64
INCL -8
JUMP L62
LABEL L64
!       IF k < KWX[i] THEN sym := keyTab[k].sym ELSE sym := ident END
LINE 92
LDLW -8
GLOBAL OMSPS.KWX
LDLW -4
CONST 10
BOUND 92
LDIW
JGEQ L68
GLOBAL OMSPS.keyTab
LDLW -8
CONST 34
BOUND 92
CONST 4
TIMES
LDIW
LDLW 12
STOREW
RETURN
LABEL L68
CONST 31
LDLW 12
STOREW
RETURN
LABEL L61
!     ELSE sym := ident
LINE 93
CONST 31
LDLW 12
STOREW
RETURN
END

PROC OMSPS.String 4 4 0
!   PROCEDURE String;
LINE 97
!   BEGIN i := 0; Texts.Read(R, ch);
LINE 99
CONST 0
STLW -4
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
LABEL L69
!     WHILE ~R.eot & (ch # 22X) DO
LINE 100
LDGC OMSPS.R
JNEQZ L71
LDGC OMSPS.ch
CONST 34
JEQ L71
!       IF ch >= " " THEN
LINE 101
LDGC OMSPS.ch
CONST 32
JLT L74
!         IF i < stringBufSize-1 THEN str[i] := ch; INC(i) ELSE Mark("string too long") END ;
LINE 102
LDLW -4
CONST 255
JGEQ L77
LDGC OMSPS.ch
GLOBAL OMSPS.str
LDLW -4
CONST 256
BOUND 102
STIC
INCL -4
JUMP L74
LABEL L77
CONST 16
GLOBAL OMSPS.%3
GLOBAL OMSPS.Mark
CALL 2
LABEL L74
!       Texts.Read(R, ch)
LINE 104
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
JUMP L69
LABEL L71
!     str[i] := 0X; INC(i); Texts.Read(R, ch); slen := i
LINE 106
CONST 0
GLOBAL OMSPS.str
LDLW -4
CONST 256
BOUND 106
STIC
INCL -4
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
LDLW -4
STGW OMSPS.slen
RETURN
END

PROC OMSPS.HexString 12 4 0
!   PROCEDURE HexString;
LINE 109
!   BEGIN i := 0; Texts.Read(R, ch);
LINE 111
CONST 0
STLW -4
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
LABEL L79
!     WHILE ~R.eot & (ch # "$") DO
LINE 112
LDGC OMSPS.R
JNEQZ L81
LDGC OMSPS.ch
CONST 36
JEQ L81
LABEL L82
!       WHILE ~R.eot  & (ch <= " ") DO Texts.Read(R, ch) END ;  (*skip*)
LINE 113
LDGC OMSPS.R
JNEQZ L84
LDGC OMSPS.ch
CONST 32
JGT L84
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
JUMP L82
LABEL L84
!       IF ("0" <= ch) & (ch <= "9") THEN m := ORD(ch) - 30H
LINE 114
LDGC OMSPS.ch
CONST 48
JLT L88
LDGC OMSPS.ch
CONST 57
JGT L88
LDGC OMSPS.ch
CONST 48
MINUS
STLW -8
JUMP L86
LABEL L88
!       ELSIF ("A" <= ch) & (ch <= "F") THEN m := ORD(ch) - 37H
LINE 115
LDGC OMSPS.ch
CONST 65
JLT L91
LDGC OMSPS.ch
CONST 70
JGT L91
LDGC OMSPS.ch
CONST 55
MINUS
STLW -8
JUMP L86
LABEL L91
!       ELSE m := 0; Mark("hexdig expected")
LINE 116
CONST 0
STLW -8
CONST 16
GLOBAL OMSPS.%4
GLOBAL OMSPS.Mark
CALL 2
LABEL L86
!       Texts.Read(R, ch);
LINE 118
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
!       IF ("0" <= ch) & (ch <= "9") THEN n := ORD(ch) - 30H
LINE 119
LDGC OMSPS.ch
CONST 48
JLT L95
LDGC OMSPS.ch
CONST 57
JGT L95
LDGC OMSPS.ch
CONST 48
MINUS
STLW -12
JUMP L93
LABEL L95
!       ELSIF ("A" <= ch) & (ch <= "F") THEN n := ORD(ch) - 37H
LINE 120
LDGC OMSPS.ch
CONST 65
JLT L98
LDGC OMSPS.ch
CONST 70
JGT L98
LDGC OMSPS.ch
CONST 55
MINUS
STLW -12
JUMP L93
LABEL L98
!       ELSE n := 0; Mark("hexdig expected")
LINE 121
CONST 0
STLW -12
CONST 16
GLOBAL OMSPS.%4
GLOBAL OMSPS.Mark
CALL 2
LABEL L93
!       IF i < stringBufSize THEN str[i] := CHR(m*10H + n); INC(i) ELSE Mark("string too long") END ;
LINE 123
LDLW -4
CONST 256
JGEQ L102
LDLW -8
CONST 16
TIMES
LDLW -12
PLUS
CONVNC
GLOBAL OMSPS.str
LDLW -4
CONST 256
BOUND 123
STIC
INCL -4
JUMP L100
LABEL L102
CONST 16
GLOBAL OMSPS.%3
GLOBAL OMSPS.Mark
CALL 2
LABEL L100
!       Texts.Read(R, ch)
LINE 124
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
JUMP L79
LABEL L81
!     Texts.Read(R, ch); slen := i  (*no 0X appended!*)
LINE 126
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
LDLW -4
STGW OMSPS.slen
RETURN
END

PROC OMSPS.Number 80 5 0x00100001
!   PROCEDURE Number(VAR sym: INTEGER);
LINE 129
!   BEGIN ival := 0; i := 0; n := 0; k := 0;
LINE 133
CONST 0
STGW OMSPS.ival
CONST 0
STLW -4
CONST 0
STLW -12
CONST 0
STLW -8
LABEL L104
!       IF n < 16 THEN d[n] := ORD(ch)-30H; INC(n) ELSE Mark("too many digits"); n := 0 END ;
LINE 135
LDLW -12
CONST 16
JGEQ L111
LDGC OMSPS.ch
CONST 48
MINUS
LOCAL -80
LDLW -12
CONST 16
BOUND 135
STIW
INCL -12
JUMP L109
LABEL L111
CONST 16
GLOBAL OMSPS.%5
GLOBAL OMSPS.Mark
CALL 2
CONST 0
STLW -12
LABEL L109
!       Texts.Read(R, ch)
LINE 136
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
!     UNTIL (ch < "0") OR (ch > "9") & (ch < "A") OR (ch > "F");
LINE 137
LDGC OMSPS.ch
CONST 48
JLT L105
LDGC OMSPS.ch
CONST 57
JLEQ L106
LDGC OMSPS.ch
CONST 65
JLT L105
LABEL L106
LDGC OMSPS.ch
CONST 70
JLEQ L104
LABEL L105
!     IF (ch = "H") OR (ch = "X") THEN  (*hex*)
LINE 138
LDGC OMSPS.ch
CONST 72
JEQ L121
LDGC OMSPS.ch
CONST 88
JNEQ L122
LABEL L121
!       REPEAT h := d[i];
LINE 139
LOCAL -80
LDLW -4
CONST 16
BOUND 139
LDIW
STLW -16
!         IF h >= 10 THEN h := h-7 END ;
LINE 140
LDLW -16
CONST 10
JLT L127
LDLW -16
CONST 7
MINUS
STLW -16
LABEL L127
!         k := k*10H + h; INC(i) (*no overflow check*)
LINE 141
LDLW -8
CONST 16
TIMES
LDLW -16
PLUS
STLW -8
INCL -4
!       UNTIL i = n;
LINE 142
LDLW -4
LDLW -12
JNEQ L121
!       IF ch = "X" THEN sym := char;
LINE 143
LDGC OMSPS.ch
CONST 88
JNEQ L130
CONST 20
LDLW 12
STOREW
!         IF k < 100H THEN ival := k ELSE Mark("illegal value"); ival := 0 END
LINE 144
LDLW -8
CONST 256
JGEQ L133
LDLW -8
STGW OMSPS.ival
JUMP L128
LABEL L133
CONST 14
GLOBAL OMSPS.%6
GLOBAL OMSPS.Mark
CALL 2
CONST 0
STGW OMSPS.ival
JUMP L128
LABEL L130
!       ELSE sym := int; ival := k
LINE 145
CONST 21
LDLW 12
STOREW
LDLW -8
STGW OMSPS.ival
LABEL L128
!       Texts.Read(R, ch)
LINE 147
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
RETURN
LABEL L122
!         IF d[i] < 10 THEN
LINE 150
LOCAL -80
LDLW -4
CONST 16
BOUND 150
LDIW
CONST 10
JGEQ L117
!           IF k <= (max-d[i]) DIV 10 THEN k := k*10 + d[i] ELSE Mark("too large"); k := 0 END
LINE 151
LDLW -8
CONST 2147483647
LOCAL -80
LDLW -4
CONST 16
BOUND 151
LDIW
MINUS
CONST 10
DIV
JGT L120
LDLW -8
CONST 10
TIMES
LOCAL -80
LDLW -4
CONST 16
BOUND 151
LDIW
PLUS
STLW -8
JUMP L115
LABEL L120
CONST 10
GLOBAL OMSPS.%7
GLOBAL OMSPS.Mark
CALL 2
CONST 0
STLW -8
JUMP L115
LABEL L117
!         ELSE Mark("bad integer")
LINE 152
CONST 12
GLOBAL OMSPS.%8
GLOBAL OMSPS.Mark
CALL 2
LABEL L115
!         INC(i)
LINE 154
INCL -4
!       UNTIL i = n;
LINE 155
LDLW -4
LDLW -12
JNEQ L122
!       sym := int; ival := k
LINE 156
CONST 21
LDLW 12
STOREW
LDLW -8
STGW OMSPS.ival
RETURN
END

PROC OMSPS.comment 0 4 0
!   PROCEDURE comment;
LINE 160
!   BEGIN Texts.Read(R, ch);
LINE 161
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
LABEL L135
!       WHILE ~R.eot & (ch # "*") DO
LINE 163
LDGC OMSPS.R
JNEQZ L140
LDGC OMSPS.ch
CONST 42
JEQ L140
!         IF ch = "(" THEN Texts.Read(R, ch);
LINE 164
LDGC OMSPS.ch
CONST 40
JNEQ L143
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
!           IF ch = "*" THEN comment END
LINE 165
LDGC OMSPS.ch
CONST 42
JNEQ L135
GLOBAL OMSPS.comment
CALL 0
JUMP L135
LABEL L143
!         ELSE Texts.Read(R, ch)
LINE 166
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
JUMP L135
LABEL L140
!       WHILE ch = "*" DO Texts.Read(R, ch) END
LINE 169
LDGC OMSPS.ch
CONST 42
JNEQ L150
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
JUMP L140
LABEL L150
!     UNTIL (ch = ")") OR R.eot;
LINE 170
LDGC OMSPS.ch
CONST 41
JEQ L136
LDGC OMSPS.R
JEQZ L135
LABEL L136
!     IF ~R.eot THEN Texts.Read(R, ch) ELSE Mark("unterminated comment") END
LINE 171
LDGC OMSPS.R
JNEQZ L153
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
RETURN
LABEL L153
CONST 21
GLOBAL OMSPS.%9
GLOBAL OMSPS.Mark
CALL 2
RETURN
END

PROC OMSPS.Get 0 4 0x00100001
!   PROCEDURE Get*(VAR sym: INTEGER);
LINE 174
LABEL L154
!       WHILE ~R.eot & (ch <= " ") DO Texts.Read(R, ch) END;
LINE 177
LDGC OMSPS.R
JNEQZ L158
LDGC OMSPS.ch
CONST 32
JGT L158
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
JUMP L154
LABEL L158
!       IF R.eot THEN sym := eot
LINE 178
LDGC OMSPS.R
JEQZ L171
CONST 70
LDLW 12
STOREW
JUMP L160
LABEL L171
!       ELSIF ch < "A" THEN
LINE 179
LDGC OMSPS.ch
CONST 65
JGEQ L173
!         IF ch < "0" THEN
LINE 180
LDGC OMSPS.ch
CONST 48
JGEQ L176
!           IF ch = 22X THEN String; sym := string
LINE 181
LDGC OMSPS.ch
CONST 34
JNEQ L179
GLOBAL OMSPS.String
CALL 0
CONST 26
LDLW 12
STOREW
JUMP L160
LABEL L179
!           ELSIF ch = "#" THEN Texts.Read(R, ch); sym := neq
LINE 182
LDGC OMSPS.ch
CONST 35
JNEQ L181
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
CONST 10
LDLW 12
STOREW
JUMP L160
LABEL L181
!           ELSIF ch = "$" THEN HexString; sym := string
LINE 183
LDGC OMSPS.ch
CONST 36
JNEQ L183
GLOBAL OMSPS.HexString
CALL 0
CONST 26
LDLW 12
STOREW
JUMP L160
LABEL L183
!           ELSIF ch = "&" THEN Texts.Read(R, ch); sym := and
LINE 184
LDGC OMSPS.ch
CONST 38
JNEQ L185
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
CONST 5
LDLW 12
STOREW
JUMP L160
LABEL L185
!           ELSIF ch = "(" THEN Texts.Read(R, ch); 
LINE 185
LDGC OMSPS.ch
CONST 40
JNEQ L187
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
!             IF ch = "*" THEN sym := null; comment ELSE sym := lparen END
LINE 186
LDGC OMSPS.ch
CONST 42
JNEQ L190
CONST 0
LDLW 12
STOREW
GLOBAL OMSPS.comment
CALL 0
JUMP L160
LABEL L190
CONST 28
LDLW 12
STOREW
JUMP L160
LABEL L187
!           ELSIF ch = ")" THEN Texts.Read(R, ch); sym := rparen
LINE 187
LDGC OMSPS.ch
CONST 41
JNEQ L192
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
CONST 44
LDLW 12
STOREW
JUMP L160
LABEL L192
!           ELSIF ch = "*" THEN Texts.Read(R, ch); sym := times
LINE 188
LDGC OMSPS.ch
CONST 42
JNEQ L194
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
CONST 1
LDLW 12
STOREW
JUMP L160
LABEL L194
!           ELSIF ch = "+" THEN Texts.Read(R, ch); sym := plus
LINE 189
LDGC OMSPS.ch
CONST 43
JNEQ L196
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
CONST 6
LDLW 12
STOREW
JUMP L160
LABEL L196
!           ELSIF ch = "," THEN Texts.Read(R, ch); sym := comma
LINE 190
LDGC OMSPS.ch
CONST 44
JNEQ L198
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
CONST 40
LDLW 12
STOREW
JUMP L160
LABEL L198
!           ELSIF ch = "-" THEN Texts.Read(R, ch); sym := minus
LINE 191
LDGC OMSPS.ch
CONST 45
JNEQ L200
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
CONST 7
LDLW 12
STOREW
JUMP L160
LABEL L200
!           ELSIF ch = "." THEN Texts.Read(R, ch);
LINE 192
LDGC OMSPS.ch
CONST 46
JNEQ L202
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
!             IF ch = "." THEN Texts.Read(R, ch); sym := upto ELSE sym := period END
LINE 193
LDGC OMSPS.ch
CONST 46
JNEQ L205
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
CONST 43
LDLW 12
STOREW
JUMP L160
LABEL L205
CONST 18
LDLW 12
STOREW
JUMP L160
LABEL L202
!           ELSIF ch = "/" THEN Texts.Read(R, ch); sym := rdiv
LINE 194
LDGC OMSPS.ch
CONST 47
JNEQ L207
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
CONST 2
LDLW 12
STOREW
JUMP L160
LABEL L207
!           ELSIF ch = "!" THEN Texts.Read(R, ch); sym := emark
LINE 195
LDGC OMSPS.ch
CONST 33
JNEQ L209
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
CONST 19
LDLW 12
STOREW
JUMP L160
LABEL L209
!           ELSE Texts.Read(R, ch); (* % ' *) sym := null
LINE 196
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
CONST 0
LDLW 12
STOREW
JUMP L160
LABEL L176
!         ELSIF ch < ":" THEN Number(sym)
LINE 198
LDGC OMSPS.ch
CONST 58
JGEQ L211
LDLW 12
GLOBAL OMSPS.Number
CALL 1
JUMP L160
LABEL L211
!         ELSIF ch = ":" THEN Texts.Read(R, ch);
LINE 199
LDGC OMSPS.ch
CONST 58
JNEQ L213
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
!           IF ch = "=" THEN Texts.Read(R, ch); sym := becomes ELSE sym := colon END 
LINE 200
LDGC OMSPS.ch
CONST 61
JNEQ L216
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
CONST 42
LDLW 12
STOREW
JUMP L160
LABEL L216
CONST 41
LDLW 12
STOREW
JUMP L160
LABEL L213
!         ELSIF ch = ";" THEN Texts.Read(R, ch); sym := semicolon
LINE 201
LDGC OMSPS.ch
CONST 59
JNEQ L218
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
CONST 52
LDLW 12
STOREW
JUMP L160
LABEL L218
!         ELSIF ch = "<" THEN  Texts.Read(R, ch);
LINE 202
LDGC OMSPS.ch
CONST 60
JNEQ L220
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
!           IF ch = "=" THEN Texts.Read(R, ch); sym := leq ELSE sym := lss END
LINE 203
LDGC OMSPS.ch
CONST 61
JNEQ L223
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
CONST 14
LDLW 12
STOREW
JUMP L160
LABEL L223
CONST 11
LDLW 12
STOREW
JUMP L160
LABEL L220
!         ELSIF ch = "=" THEN Texts.Read(R, ch); sym := eql
LINE 204
LDGC OMSPS.ch
CONST 61
JNEQ L225
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
CONST 9
LDLW 12
STOREW
JUMP L160
LABEL L225
!         ELSIF ch = ">" THEN Texts.Read(R, ch);
LINE 205
LDGC OMSPS.ch
CONST 62
JNEQ L227
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
!           IF ch = "=" THEN Texts.Read(R, ch); sym := geq ELSE sym := gtr END
LINE 206
LDGC OMSPS.ch
CONST 61
JNEQ L230
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
CONST 12
LDLW 12
STOREW
JUMP L160
LABEL L230
CONST 13
LDLW 12
STOREW
JUMP L160
LABEL L227
!         ELSE (* ? @ *) Texts.Read(R, ch); sym := null
LINE 207
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
CONST 0
LDLW 12
STOREW
JUMP L160
LABEL L173
!       ELSIF ch < "[" THEN Identifier(sym)
LINE 209
LDGC OMSPS.ch
CONST 91
JGEQ L232
LDLW 12
GLOBAL OMSPS.Identifier
CALL 1
JUMP L160
LABEL L232
!       ELSIF ch < "a" THEN
LINE 210
LDGC OMSPS.ch
CONST 97
JGEQ L234
!         IF ch = "[" THEN sym := lbrak
LINE 211
LDGC OMSPS.ch
CONST 91
JNEQ L237
CONST 29
LDLW 12
STOREW
JUMP L235
LABEL L237
!         ELSIF ch = "]" THEN  sym := rbrak
LINE 212
LDGC OMSPS.ch
CONST 93
JNEQ L239
CONST 45
LDLW 12
STOREW
JUMP L235
LABEL L239
!         ELSIF ch = "^" THEN sym := arrow
LINE 213
LDGC OMSPS.ch
CONST 94
JNEQ L241
CONST 17
LDLW 12
STOREW
JUMP L235
LABEL L241
!         ELSE (* _ ` *) sym := null
LINE 214
CONST 0
LDLW 12
STOREW
LABEL L235
!         Texts.Read(R, ch)
LINE 216
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
JUMP L160
LABEL L234
!       ELSIF ch < "{" THEN Identifier(sym) ELSE
LINE 217
LDGC OMSPS.ch
CONST 123
JGEQ L243
LDLW 12
GLOBAL OMSPS.Identifier
CALL 1
JUMP L160
LABEL L243
!         IF ch = "{" THEN sym := lbrace
LINE 218
LDGC OMSPS.ch
CONST 123
JNEQ L163
CONST 30
LDLW 12
STOREW
JUMP L161
LABEL L163
!         ELSIF ch = "}" THEN sym := rbrace
LINE 219
LDGC OMSPS.ch
CONST 125
JNEQ L165
CONST 46
LDLW 12
STOREW
JUMP L161
LABEL L165
!         ELSIF ch = "|" THEN sym := bar
LINE 220
LDGC OMSPS.ch
CONST 124
JNEQ L167
CONST 54
LDLW 12
STOREW
JUMP L161
LABEL L167
!         ELSIF ch = "~" THEN  sym := not
LINE 221
LDGC OMSPS.ch
CONST 126
JNEQ L169
CONST 27
LDLW 12
STOREW
JUMP L161
LABEL L169
!         ELSE sym := null
LINE 222
CONST 0
LDLW 12
STOREW
LABEL L161
!         Texts.Read(R, ch)
LINE 224
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
LABEL L160
!     UNTIL sym # null
LINE 226
LDLW 12
LOADW
JEQZ L154
RETURN
END

PROC OMSPS.Init 0 5 0x00100001
!   PROCEDURE Init*(T: Texts.Text; pos: INTEGER);
LINE 229
!   BEGIN errpos := pos; errcnt := 0; Texts.OpenReader(R, T, pos); Texts.Read(R, ch)
LINE 230
LDLW 16
STGW OMSPS.errpos
CONST 0
STGW OMSPS.errcnt
LDLW 16
LDLW 12
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.OpenReader
CALL 4
GLOBAL OMSPS.ch
GLOBAL Texts.Reader
GLOBAL OMSPS.R
GLOBAL Texts.Read
CALL 3
RETURN
END

PROC OMSPS.EnterKW 0 7 0x00200001
!   PROCEDURE EnterKW(sym: INTEGER; name: ARRAY OF CHAR);
LINE 233
!   BEGIN keyTab[k].id := name; keyTab[k].sym := sym; INC(k)
LINE 234
GLOBAL OMSPS.keyTab
LDGW OMSPS.k
CONST 34
BOUND 234
CONST 16
TIMES
OFFSET
CONST 4
OFFSET
CONST 12
SWAP
LDLW 20
LDLW 16
CONST 1
CONST 1
GLOBAL FLEXASSIGN
CALL 6
LDLW 12
GLOBAL OMSPS.keyTab
LDGW OMSPS.k
CONST 34
BOUND 234
CONST 4
TIMES
STIW
LDGW OMSPS.k
INC
STGW OMSPS.k
RETURN
END

PROC OMSPS.%main 0 4 0
! BEGIN Texts.OpenWriter(W); k := 0; KWX[0] := 0; KWX[1] := 0;
LINE 237
GLOBAL Texts.Writer
GLOBAL OMSPS.W
GLOBAL Texts.OpenWriter
CALL 2
CONST 0
STGW OMSPS.k
CONST 0
STGW OMSPS.KWX
CONST 0
GLOBAL OMSPS.KWX
STNW 4
!   EnterKW(if, "IF");
LINE 238
CONST 3
GLOBAL OMSPS.%10
CONST 32
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(do, "DO");
LINE 239
CONST 3
GLOBAL OMSPS.%11
CONST 49
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(of, "OF");
LINE 240
CONST 3
GLOBAL OMSPS.%12
CONST 48
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(or, "OR");
LINE 241
CONST 3
GLOBAL OMSPS.%13
CONST 8
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(to, "TO");
LINE 242
CONST 3
GLOBAL OMSPS.%14
CONST 50
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(in, "IN");
LINE 243
CONST 3
GLOBAL OMSPS.%15
CONST 15
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(is, "IS");
LINE 244
CONST 3
GLOBAL OMSPS.%16
CONST 16
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(by, "BY");
LINE 245
CONST 3
GLOBAL OMSPS.%17
CONST 51
GLOBAL OMSPS.EnterKW
CALL 3
!   KWX[2] := k;
LINE 246
LDGW OMSPS.k
GLOBAL OMSPS.KWX
STNW 8
!   EnterKW(end, "END");
LINE 247
CONST 4
GLOBAL OMSPS.%18
CONST 53
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(nil, "NIL");
LINE 248
CONST 4
GLOBAL OMSPS.%19
CONST 25
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(var, "VAR");
LINE 249
CONST 4
GLOBAL OMSPS.%20
CONST 65
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(div, "DIV");
LINE 250
CONST 4
GLOBAL OMSPS.%21
CONST 3
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(mod, "MOD");
LINE 251
CONST 4
GLOBAL OMSPS.%22
CONST 4
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(for, "FOR");
LINE 252
CONST 4
GLOBAL OMSPS.%23
CONST 37
GLOBAL OMSPS.EnterKW
CALL 3
!   KWX[3] := k;
LINE 253
LDGW OMSPS.k
GLOBAL OMSPS.KWX
STNW 12
!   EnterKW(else, "ELSE");
LINE 254
CONST 5
GLOBAL OMSPS.%24
CONST 55
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(then, "THEN");
LINE 255
CONST 5
GLOBAL OMSPS.%25
CONST 47
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(true, "TRUE");
LINE 256
CONST 5
GLOBAL OMSPS.%26
CONST 24
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(type, "TYPE");
LINE 257
CONST 5
GLOBAL OMSPS.%27
CONST 64
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(case, "CASE");
LINE 258
CONST 5
GLOBAL OMSPS.%28
CONST 36
GLOBAL OMSPS.EnterKW
CALL 3
!   KWX[4] := k;
LINE 259
LDGW OMSPS.k
GLOBAL OMSPS.KWX
STNW 16
!   EnterKW(elsif, "ELSIF");
LINE 260
CONST 6
GLOBAL OMSPS.%29
CONST 56
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(false, "FALSE");
LINE 261
CONST 6
GLOBAL OMSPS.%30
CONST 23
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(array, "ARRAY");
LINE 262
CONST 6
GLOBAL OMSPS.%31
CONST 60
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(begin, "BEGIN");
LINE 263
CONST 6
GLOBAL OMSPS.%32
CONST 67
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(const, "CONST");
LINE 264
CONST 6
GLOBAL OMSPS.%33
CONST 63
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(until, "UNTIL");
LINE 265
CONST 6
GLOBAL OMSPS.%34
CONST 57
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(while, "WHILE");
LINE 266
CONST 6
GLOBAL OMSPS.%35
CONST 34
GLOBAL OMSPS.EnterKW
CALL 3
!   KWX[5] := k;
LINE 267
LDGW OMSPS.k
GLOBAL OMSPS.KWX
STNW 20
!   EnterKW(record, "RECORD");
LINE 268
CONST 7
GLOBAL OMSPS.%36
CONST 61
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(repeat, "REPEAT");
LINE 269
CONST 7
GLOBAL OMSPS.%37
CONST 35
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(return, "RETURN");
LINE 270
CONST 7
GLOBAL OMSPS.%38
CONST 58
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(import, "IMPORT");
LINE 271
CONST 7
GLOBAL OMSPS.%39
CONST 68
GLOBAL OMSPS.EnterKW
CALL 3
!   EnterKW(module, "MODULE");
LINE 272
CONST 7
GLOBAL OMSPS.%40
CONST 69
GLOBAL OMSPS.EnterKW
CALL 3
!   KWX[6] := k;
LINE 273
LDGW OMSPS.k
GLOBAL OMSPS.KWX
STNW 24
!   EnterKW(pointer, "POINTER");
LINE 274
CONST 8
GLOBAL OMSPS.%41
CONST 62
GLOBAL OMSPS.EnterKW
CALL 3
!   KWX[7] := k; KWX[8] := k;
LINE 275
LDGW OMSPS.k
GLOBAL OMSPS.KWX
STNW 28
LDGW OMSPS.k
GLOBAL OMSPS.KWX
STNW 32
!   EnterKW(procedure, "PROCEDURE");
LINE 276
CONST 10
GLOBAL OMSPS.%42
CONST 66
GLOBAL OMSPS.EnterKW
CALL 3
!   KWX[9] := k
LINE 277
LDGW OMSPS.k
GLOBAL OMSPS.KWX
STNW 36
RETURN
END

! Global variables
GLOVAR OMSPS.ival 4
GLOVAR OMSPS.slen 4
GLOVAR OMSPS.id 32
GLOVAR OMSPS.str 256
GLOVAR OMSPS.errcnt 4
GLOVAR OMSPS.ch 1
GLOVAR OMSPS.errpos 4
GLOVAR OMSPS.R 32
GLOVAR OMSPS.W 20
GLOVAR OMSPS.k 4
GLOVAR OMSPS.KWX 40
GLOVAR OMSPS.keyTab 544

! Global pointer map
DEFINE OMSPS.%gcmap
WORD GC_BASE
WORD OMSPS.R
WORD 0x00000109
WORD GC_BASE
WORD OMSPS.W
WORD 0x00000023
WORD GC_END

! String "  pos "
DEFINE OMSPS.%1
STRING 2020706F732000

! String " at pos "
DEFINE OMSPS.%2
STRING 20617420706F732000

! String "string too long"
DEFINE OMSPS.%3
STRING 737472696E6720746F6F206C6F6E6700

! String "hexdig expected"
DEFINE OMSPS.%4
STRING 68657864696720657870656374656400

! String "too many digits"
DEFINE OMSPS.%5
STRING 746F6F206D616E792064696769747300

! String "illegal value"
DEFINE OMSPS.%6
STRING 696C6C6567616C2076616C756500

! String "too large"
DEFINE OMSPS.%7
STRING 746F6F206C6172676500

! String "bad integer"
DEFINE OMSPS.%8
STRING 62616420696E746567657200

! String "unterminated comment"
DEFINE OMSPS.%9
STRING 756E7465726D696E6174656420636F6D6D656E7400

! String "IF"
DEFINE OMSPS.%10
STRING 494600

! String "DO"
DEFINE OMSPS.%11
STRING 444F00

! String "OF"
DEFINE OMSPS.%12
STRING 4F4600

! String "OR"
DEFINE OMSPS.%13
STRING 4F5200

! String "TO"
DEFINE OMSPS.%14
STRING 544F00

! String "IN"
DEFINE OMSPS.%15
STRING 494E00

! String "IS"
DEFINE OMSPS.%16
STRING 495300

! String "BY"
DEFINE OMSPS.%17
STRING 425900

! String "END"
DEFINE OMSPS.%18
STRING 454E4400

! String "NIL"
DEFINE OMSPS.%19
STRING 4E494C00

! String "VAR"
DEFINE OMSPS.%20
STRING 56415200

! String "DIV"
DEFINE OMSPS.%21
STRING 44495600

! String "MOD"
DEFINE OMSPS.%22
STRING 4D4F4400

! String "FOR"
DEFINE OMSPS.%23
STRING 464F5200

! String "ELSE"
DEFINE OMSPS.%24
STRING 454C534500

! String "THEN"
DEFINE OMSPS.%25
STRING 5448454E00

! String "TRUE"
DEFINE OMSPS.%26
STRING 5452554500

! String "TYPE"
DEFINE OMSPS.%27
STRING 5459504500

! String "CASE"
DEFINE OMSPS.%28
STRING 4341534500

! String "ELSIF"
DEFINE OMSPS.%29
STRING 454C53494600

! String "FALSE"
DEFINE OMSPS.%30
STRING 46414C534500

! String "ARRAY"
DEFINE OMSPS.%31
STRING 415252415900

! String "BEGIN"
DEFINE OMSPS.%32
STRING 424547494E00

! String "CONST"
DEFINE OMSPS.%33
STRING 434F4E535400

! String "UNTIL"
DEFINE OMSPS.%34
STRING 554E54494C00

! String "WHILE"
DEFINE OMSPS.%35
STRING 5748494C4500

! String "RECORD"
DEFINE OMSPS.%36
STRING 5245434F524400

! String "REPEAT"
DEFINE OMSPS.%37
STRING 52455045415400

! String "RETURN"
DEFINE OMSPS.%38
STRING 52455455524E00

! String "IMPORT"
DEFINE OMSPS.%39
STRING 494D504F525400

! String "MODULE"
DEFINE OMSPS.%40
STRING 4D4F44554C4500

! String "POINTER"
DEFINE OMSPS.%41
STRING 504F494E54455200

! String "PROCEDURE"
DEFINE OMSPS.%42
STRING 50524F43454455524500

! Descriptor for *anon*
DEFINE OMSPS.%43
WORD 0
WORD 0
WORD OMSPS.%43.%anc

DEFINE OMSPS.%43.%anc
WORD OMSPS.%43

! End of file
