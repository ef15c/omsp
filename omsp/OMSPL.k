!! (SYMFILE #OMSPL 0x00030300 #OMSPL.%main 1 #OMSPL.Mod)
!! (CONST #version INTCONST 1)
!! (CONST #noerr INTCONST 0)
!! (CONST #nofile INTCONST 1)
!! (CONST #duphandler INTCONST 2)
!! (CONST #badkey INTCONST 3)
!! (CONST #badfile INTCONST 4)
!! (CONST #nospace INTCONST 5)
!! (CONST #nopar INTCONST 6)
!! (CONST #noinit INTCONST 7)
!! (CONST #notsupported INTCONST 8)
!! (CONST #RAMOrigin INTCONST 512)
!! (CONST #FlashEnd INTCONST 65536)
!! (CONST #MaxSec INTCONST 512)
!! (TYPE #Module !1 (POINTER))
!! (TARGET =1 !2 (RECORD #OMSPL.ModDesc 320 VOID
!!     (FIELD #name 0 !3 (ARRAY 32 CHAR))
!!     (FIELD #next 32 =1)
!!     (FIELD #key 36 INTEGER)
!!     (FIELD #num 40 INTEGER)
!!     (FIELD #varsto 44 INTEGER)
!!     (FIELD #flashsto 48 INTEGER)
!!     (FIELD #codeexe 52 INTEGER)
!!     (FIELD #flashsize 56 INTEGER)
!!     (FIELD #ent 60 !4 (ARRAY 64 INTEGER))
!!     (FIELD #codeseg 316 BYTE)))
!! (TYPE #Name =3)
!! (TYPE #ModDesc =2)
!! (TYPE #Segment !5 (POINTER))
!! (TARGET =5 !6 (RECORD #OMSPL.SegmentDesc 65544 VOID
!!     (FIELD #origin 0 INTEGER)
!!     (FIELD #allocPtr 4 INTEGER)
!!     (FIELD #m 8 !7 (ARRAY 65536 BYTE))))
!! (TYPE #SegmentDesc =6)
!! (TYPE #Section !8 (RECORD #OMSPL.Section 44 VOID
!!     (FIELD #segment 0 CHAR)
!!     (FIELD #name 1 =3)
!!     (FIELD #eadr 36 INTEGER)
!!     (FIELD #size 40 INTEGER)))
!! (TYPE #Depend !9 (POINTER))
!! (TARGET =9 !10 (RECORD #OMSPL.DependDesc 12 VOID
!!     (FIELD #mno 0 BYTE)
!!     (FIELD #sno 4 INTEGER)
!!     (FIELD #next 8 =9)))
!! (TYPE #DependDesc =10)
!! (TYPE #SecDep !11 (POINTER))
!! (TARGET =11 !12 (RECORD #OMSPL.SecDepDesc 12 VOID
!!     (FIELD #no 0 INTEGER)
!!     (FIELD #dep 4 =9)
!!     (FIELD #next 8 =11)))
!! (TYPE #SecDepDesc =12)
!! (TYPE #ModMaps !13 (POINTER))
!! (TARGET =13 !14 (RECORD #OMSPL.ModMapsDesc 492 VOID
!!     (FIELD #name 0 =3)
!!     (FIELD #next 32 =13)
!!     (FIELD #sections 36 =11)
!!     (FIELD #import 40 !15 (ARRAY 16 =13))
!!     (FIELD #nofimps 104 INTEGER)
!!     (FIELD #ent 108 !16 (ARRAY 64 INTEGER))
!!     (FIELD #refm 364 !17 (ARRAY 16 SET))
!!     (FIELD #tdm 428 =17)))
!! (TYPE #ModMapsDesc =14)
!! (GLOBAL #first #OMSPL.first =1)
!! (GLOBAL #last #OMSPL.last =1)
!! (GLOBAL #maps #OMSPL.maps =13)
!! (GLOBAL #RAMAllocPtr #OMSPL.RAMAllocPtr INTEGER)
!! (GLOBAL #RAMLimit #OMSPL.RAMLimit INTEGER)
!! (GLOBAL #limit #OMSPL.limit INTEGER)
!! (GLOBAL #res #OMSPL.res INTEGER)
!! (GLOBAL #Flash #OMSPL.Flash =5)
!! (GLOBAL #vector #OMSPL.vector !18 (ARRAY 32 INTEGER))
!! (GLOBAL #importing #OMSPL.importing =3)
!! (GLOBAL #imported #OMSPL.imported =3)
!! (GLOBAL #W #OMSPL.W ?19 #Texts 17 #Writer (RECORD #Texts.Writer 20 VOID
!!     (FIELD #buf* 0 ?20 #Texts 15 #Buffer (POINTER))
!!     (FIELD #col* 4 INTEGER)
!!     (FIELD #rider 8 ?21 #POFiles 6 #Rider (RECORD #POFiles.Rider 12 VOID
!!         (FIELD #eof* 0 BOOLEAN)
!!         (FIELD #res* 4 INTEGER)
!!         (FIELD #base 8 ?22 #POFiles 1 #File (POINTER))))))
!! (TARGET =22 ?23 #POFiles 2 #FileDesc (RECORD #POFiles.FileDesc 68 VOID
!!     (FIELD #file 0 ?24 #Files 1 #File (POINTER))
!!     (FIELD #tmpName 4 ?25 #POFiles 4 ANON (ARRAY 32 CHAR))
!!     (FIELD #name 36 =25)))
!! (TARGET =24 ?26 #Files 2 #FileDesc (RECORD #Files.FileDesc 8 VOID
!!     (FIELD #file- 0 SYSTEM.LONGPTR)))
!! (TARGET =20 ?27 #Texts 16 #BufDesc (RECORD #Texts.BufDesc 12 VOID
!!     (FIELD #len* 0 INTEGER)
!!     (FIELD #header 4 ?28 #Texts 1 #Piece (POINTER))
!!     (FIELD #last 8 =28)))
!! (TARGET =28 ?29 #Texts 2 #PieceDesc (RECORD #Texts.PieceDesc 24 VOID
!!     (FIELD #f 0 =22)
!!     (FIELD #off 4 INTEGER)
!!     (FIELD #len 8 INTEGER)
!!     (FIELD #col 12 INTEGER)
!!     (FIELD #prev 16 =28)
!!     (FIELD #next 20 =28)))
!! (PROCEDURE #align 118 #OMSPL.align !30 (PROC 1 VOID
!!     (VPARAM #a 12 INTEGER)))
!! (PROCEDURE #GetWordAt 123 #OMSPL.GetWordAt !31 (PROC 1 INTEGER
!!     (PARAM #adr 12 INTEGER)))
!! (PROCEDURE #PutWordAt 128 #OMSPL.PutWordAt !32 (PROC 2 VOID
!!     (PARAM #adr 12 INTEGER)
!!     (PARAM #val 16 INTEGER)))
!! (PROCEDURE #EmitByte 133 #OMSPL.EmitByte !33 (PROC 1 VOID
!!     (PARAM #val 12 BYTE)))
!! (PROCEDURE #EmitWord 140 #OMSPL.EmitWord !34 (PROC 1 VOID
!!     (PARAM #val 12 INTEGER)))
!! (PROCEDURE #padFlash 147 #OMSPL.padFlash !35 (PROC 0 VOID))
!! (DEF !36 (FLEX CHAR))
!! (DEF !37 (FLEX CHAR))
!! (PROCEDURE #MakeFileName 151 #OMSPL.MakeFileName !38 (PROC 6 VOID
!!     (VPARAM #FName 12 =36)
!!     (CPARAM #name 20 =37)
!!     (CPARAM #ext 28 =37))
!!   (LOCAL #i -4 INTEGER)
!!   (LOCAL #j -8 INTEGER))
!! (DEF !39 (FLEX CHAR))
!! (PROCEDURE #ThisFile 159 #OMSPL.ThisFile !40 (PROC 2 =22
!!     (CPARAM #name 12 =39))
!!   (LOCAL #F -4 =22)
!!   (LOCAL #filename -36 =3))
!! (DEF !41 (FLEX CHAR))
!! (PROCEDURE #error 166 #OMSPL.error !42 (PROC 3 VOID
!!     (PARAM #n 12 INTEGER)
!!     (CPARAM #name 16 =41)))
!! (DEF !43 (FLEX CHAR))
!! (PROCEDURE #Check 170 #OMSPL.Check !44 (PROC 2 VOID
!!     (CPARAM #s 12 =43))
!!   (LOCAL #i -4 INTEGER)
!!   (LOCAL #ch -5 CHAR))
!! (DEF !45 (FLEX CHAR))
!! (PROCEDURE #FindModMap 181 #OMSPL.FindModMap !46 (PROC 3 VOID
!!     (CPARAM #name 12 =45)
!!     (VPARAM #mm 20 =13)))
!! (DEF !47 (FLEX CHAR))
!! (DEF !48 (FLEX =8))
!! (PROCEDURE #LinkOne 187 #OMSPL.LinkOne !49 (PROC 7 VOID
!!     (CPARAM #name 12 =47)
!!     (VPARAM #newmod 20 =1)
!!     (VPARAM #sec 24 =48)
!!     (VPARAM #MW 32 =19))
!!   (LOCAL #mod -4 =1)
!!   (LOCAL #impmod -8 =1)
!!   (LOCAL #i -12 INTEGER)
!!   (LOCAL #k -16 INTEGER)
!!   (LOCAL #l -20 INTEGER)
!!   (LOCAL #nofimps -24 INTEGER)
!!   (LOCAL #ch -25 CHAR)
!!   (LOCAL #adr -32 INTEGER)
!!   (LOCAL #ofs -36 INTEGER)
!!   (LOCAL #sno -40 INTEGER)
!!   (LOCAL #no -44 INTEGER)
!!   (LOCAL #snor -48 INTEGER)
!!   (LOCAL #dest -52 INTEGER)
!!   (LOCAL #name1 -84 =3)
!!   (LOCAL #F -88 =22)
!!   (LOCAL #R -100 =21)
!!   (LOCAL #import -164 !50 (ARRAY 16 =1))
!!   (LOCAL #mno -165 BYTE)
!!   (LOCAL #mnor -166 BYTE)
!!   (LOCAL #vec -296 !51 (ARRAY 32 INTEGER))
!!   (LOCAL #secfpos -300 INTEGER)
!!   (LOCAL #nofsecs -304 INTEGER)
!!   (LOCAL #mm -308 =13)
!!   (LOCAL #keep -309 BOOLEAN))
!! (DEF !52 (FLEX CHAR))
!! (PROCEDURE #Mark 356 #OMSPL.Mark !53 (PROC 3 VOID
!!     (CPARAM #name 12 =52)
!!     (VPARAM #mm 20 =13))
!!   (LOCAL #im -4 =13)
!!   (LOCAL #F -8 =22)
!!   (LOCAL #R -20 =21)
!!   (LOCAL #name1 -52 =3)
!!   (LOCAL #ch -53 CHAR)
!!   (LOCAL #b -54 BYTE)
!!   (LOCAL #i -60 INTEGER)
!!   (LOCAL #w -64 INTEGER)
!!   (LOCAL #no -68 INTEGER)
!!   (LOCAL #s -72 =11)
!!   (LOCAL #d -76 =9)
!!   (LOCAL #done -77 BOOLEAN))
!! (PROCEDURE #Link* 433 #OMSPL.Link !54 (PROC 0 VOID)
!!   (LOCAL #i -4 INTEGER)
!!   (LOCAL #x -8 INTEGER)
!!   (LOCAL #vecsize -12 INTEGER)
!!   (LOCAL #isrtrap -16 INTEGER)
!!   (LOCAL #count -20 INTEGER)
!!   (LOCAL #oldcol -24 INTEGER)
!!   (LOCAL #F -28 =22)
!!   (LOCAL #R -40 =21)
!!   (LOCAL #MT -44 ?55 #Texts 8 #Text (POINTER))
!!   (LOCAL #MW -64 =19)
!!   (DEF ?56 #Texts 11 #Reader (RECORD #Texts.Reader 32 VOID
!!       (FIELD #eot* 0 BOOLEAN)
!!       (FIELD #col* 4 INTEGER)
!!       (FIELD #ref 8 =28)
!!       (FIELD #org 12 INTEGER)
!!       (FIELD #off 16 INTEGER)
!!       (FIELD #rider 20 =21)))
!!   (LOCAL #S -160 ?57 #Texts 13 #Scanner (RECORD #Texts.Scanner 96 =56
!!       (FIELD #eot* 0 BOOLEAN)
!!       (FIELD #col* 4 INTEGER)
!!       (FIELD #ref 8 =28)
!!       (FIELD #org 12 INTEGER)
!!       (FIELD #off 16 INTEGER)
!!       (FIELD #rider 20 =21)
!!       (FIELD #nextCh* 32 CHAR)
!!       (FIELD #line* 36 INTEGER)
!!       (FIELD #class* 40 INTEGER)
!!       (FIELD #i* 44 LONGINT)
!!       (FIELD #x* 52 REAL)
!!       (FIELD #c* 56 CHAR)
!!       (FIELD #len* 60 INTEGER)
!!       (FIELD #s* 64 ?58 #Texts 14 ANON (ARRAY 32 CHAR))))
!!   (LOCAL #M -164 =1)
!!   (LOCAL #p -168 =1)
!!   (LOCAL #MM -172 =13)
!!   (LOCAL #name -204 =3)
!!   (LOCAL #modlist -2252 !59 (ARRAY 64 =3))
!!   (LOCAL #nbmod -2256 INTEGER)
!!   (LOCAL #mi -2260 INTEGER)
!!   (LOCAL #sec -24788 !60 (ARRAY 512 =8)))
!! (TARGET =55 ?61 #Texts 9 #TextDesc (RECORD #Texts.TextDesc 24 VOID
!!     (FIELD #len* 0 INTEGER)
!!     (FIELD #changed* 4 BOOLEAN)
!!     (FIELD #notify* 8 ?62 #Texts 10 #Notifier (PROC 4 VOID
!!         (PARAM #T 12 =55)
!!         (PARAM #op 16 INTEGER)
!!         (PARAM #beg 20 INTEGER)
!!         (PARAM #end 24 INTEGER)))
!!     (FIELD #trailer 12 =28)
!!     (FIELD #pce 16 =28)
!!     (FIELD #org 20 INTEGER)))
!! (CHKSUM 0x700e6994)
!! 
MODULE OMSPL 0x700e6994 524
IMPORT Modules 0x2949f19d
IMPORT Display 0x6ac5a6ac
IMPORT OMSPG 0x1f97ef6a
IMPORT POFiles 0x1834a231
IMPORT FilesEx 0x20df259e
IMPORT Texts 0x04379426
IMPORT Oberon 0x7fd79012
IMPORT SystemLog 0x7825850f
ENDHDR

PROC OMSPL.align 0 2 0x00100001
!   PROCEDURE align(VAR a: INTEGER);
LINE 118
!   BEGIN a := (a + (G.WordSize - 1) ) DIV G.WordSize*G.WordSize
LINE 119
LDLW 12
LOADW
INC
CONST 2
DIV
CONST 2
TIMES
LDLW 12
STOREW
RETURN
END

PROC OMSPL.GetWordAt 0 4 0
!   PROCEDURE GetWordAt(adr: INTEGER): INTEGER;
LINE 123
!     RETURN 0 + Flash.m[adr] + 100H*Flash.m[adr + 1]
LINE 124
LDGW OMSPL.Flash
NCHECK 124
CONST 8
OFFSET
LDLW 12
CONST 65536
BOUND 124
OFFSET
LOADC
LDGW OMSPL.Flash
NCHECK 124
CONST 8
OFFSET
LDLW 12
INC
CONST 65536
BOUND 124
OFFSET
LOADC
CONST 256
TIMES
PLUS
RETURN
END

PROC OMSPL.PutWordAt 0 4 0
!   PROCEDURE PutWordAt(adr, val: INTEGER);
LINE 128
!   BEGIN Flash.m[adr] := val MOD 100H; val := val DIV 100H;
LINE 129
LDLW 16
CONST 256
MOD
CONVNC
LDGW OMSPL.Flash
NCHECK 129
CONST 8
OFFSET
LDLW 12
CONST 65536
BOUND 129
OFFSET
STOREC
LDLW 16
CONST 256
DIV
STLW 16
!     Flash.m[adr + 1] := val MOD 100H;
LINE 130
LDLW 16
CONST 256
MOD
CONVNC
LDGW OMSPL.Flash
NCHECK 130
CONST 8
OFFSET
LDLW 12
INC
CONST 65536
BOUND 130
OFFSET
STOREC
RETURN
END

PROC OMSPL.EmitByte 0 4 0
!   PROCEDURE EmitByte(val: BYTE);
LINE 133
!     IF Flash.allocPtr <= limit THEN Flash.m[Flash.allocPtr] := val; INC(Flash.allocPtr)
LINE 135
LDGW OMSPL.Flash
NCHECK 135
LDNW 4
LDGW OMSPL.limit
JGT L26
LDLC 12
LDGW OMSPL.Flash
NCHECK 135
CONST 8
OFFSET
LDGW OMSPL.Flash
NCHECK 135
LDNW 4
CONST 65536
BOUND 135
OFFSET
STOREC
LDGW OMSPL.Flash
NCHECK 135
DUP 0
LDNW 4
INC
SWAP
STNW 4
RETURN
LABEL L26
!     ELSE res := nospace
LINE 136
CONST 5
STGW OMSPL.res
RETURN
END

PROC OMSPL.EmitWord 0 3 0
!   PROCEDURE EmitWord(val: INTEGER);
LINE 140
!     IF Flash.allocPtr <= limit THEN PutWordAt(Flash.allocPtr, val); INC(Flash.allocPtr, G.WordSize);
LINE 142
LDGW OMSPL.Flash
NCHECK 142
LDNW 4
LDGW OMSPL.limit
JGT L29
LDLW 12
LDGW OMSPL.Flash
NCHECK 142
LDNW 4
GLOBAL OMSPL.PutWordAt
CALL 2
LDGW OMSPL.Flash
NCHECK 142
DUP 0
LDNW 4
CONST 2
PLUS
SWAP
STNW 4
RETURN
LABEL L29
!     ELSE res := nospace
LINE 143
CONST 5
STGW OMSPL.res
RETURN
END

PROC OMSPL.padFlash 0 2 0
!   PROCEDURE padFlash; (*align flash allocatopn address a on word size boundary*)
LINE 147
LABEL L30
!   BEGIN WHILE (res = noerr) & (Flash.allocPtr MOD G.WordSize # 0) DO EmitByte(0) END
LINE 148
LDGW OMSPL.res
JNEQZ L32
LDGW OMSPL.Flash
NCHECK 148
LDNW 4
CONST 2
MOD
JEQZ L32
CONST 0
GLOBAL OMSPL.EmitByte
CALL 1
JUMP L30
LABEL L32
RETURN
END

PROC OMSPL.MakeFileName 8 4 0x01500001
!   PROCEDURE MakeFileName(VAR FName: ARRAY OF CHAR; name, ext: ARRAY OF CHAR);
LINE 151
!   BEGIN i := 0; j := 0;  (*assume name suffix less than 4 characters*)
LINE 153
CONST 0
STLW -4
CONST 0
STLW -8
LABEL L34
!     WHILE (i < 32-5) & (name[i] > 0X) DO FName[i] := name[i]; INC(i) END ;
LINE 154
LDLW -4
CONST 27
JGEQ L36
LDLW 20
LDLW -4
LDLW 24
BOUND 154
LDIC
JLEQZ L36
LDLW 20
LDLW -4
LDLW 24
BOUND 154
LDIC
LDLW 12
LDLW -4
LDLW 16
BOUND 154
STIC
INCL -4
JUMP L34
LABEL L36
!     REPEAT FName[i]:= ext[j]; INC(i); INC(j) UNTIL ext[j] = 0X;
LINE 155
LDLW 28
LDLW -8
LDLW 32
BOUND 155
LDIC
LDLW 12
LDLW -4
LDLW 16
BOUND 155
STIC
INCL -4
INCL -8
LDLW 28
LDLW -8
LDLW 32
BOUND 155
LDIC
JNEQZ L36
!     FName[i] := 0X
LINE 156
CONST 0
LDLW 12
LDLW -4
LDLW 16
BOUND 156
STIC
RETURN
END

PROC OMSPL.ThisFile 36 7 0x00110001
!   PROCEDURE ThisFile(name: ARRAY OF CHAR): Files.File;
LINE 159
!   BEGIN MakeFileName(filename, name, ".mpc"); F := Files.Old(filename)
LINE 162
CONST 5
GLOBAL OMSPL.%1
LDLW 16
LDLW 12
CONST 32
LOCAL -36
GLOBAL OMSPL.MakeFileName
CALL 6
CONST 32
LOCAL -36
GLOBAL POFiles.Old
CALLW 2
STLW -4
!     RETURN F
LINE 163
LDLW -4
RETURN
END

PROC OMSPL.error 0 7 0x00200001
!   PROCEDURE error(n: INTEGER; name: ARRAY OF CHAR);
LINE 166
!   BEGIN res := n; importing := name
LINE 167
LDLW 12
STGW OMSPL.res
CONST 32
GLOBAL OMSPL.importing
LDLW 20
LDLW 16
CONST 1
CONST 1
GLOBAL FLEXASSIGN
CALL 6
RETURN
END

PROC OMSPL.Check 8 3 0x00100001
!   PROCEDURE Check(s: ARRAY OF CHAR);
LINE 170
!   BEGIN ch := s[0]; res := 1; i := 1;
LINE 172
LDLW 12
CONST 0
LDLW 16
BOUND 172
LDIC
STLC -5
CONST 1
STGW OMSPL.res
CONST 1
STLW -4
!     IF (ch >= "A") & (ch <= "Z") OR (ch >= "a") & (ch <= "z") THEN
LINE 173
LDLC -5
CONST 65
JLT L56
LDLC -5
CONST 90
JLEQ L41
LABEL L56
LDLC -5
CONST 97
JLT L42
LDLC -5
CONST 122
JGT L42
LABEL L41
!       REPEAT ch := s[i]; INC(i)
LINE 174
LDLW 12
LDLW -4
LDLW 16
BOUND 174
LDIC
STLC -5
INCL -4
!       UNTIL ~((ch >= "0") & (ch <= "9") OR (ch >= "A") & (ch <= "Z")
LINE 175
LDLC -5
CONST 48
JLT L49
LDLC -5
CONST 57
JLEQ L45
LABEL L49
LDLC -5
CONST 65
JLT L47
LDLC -5
CONST 90
JLEQ L45
LABEL L47
LDLC -5
CONST 97
JLT L46
LDLC -5
CONST 122
JLEQ L45
LABEL L46
LDLC -5
CONST 46
JNEQ L44
LABEL L45
LDLW -4
CONST 32
JNEQ L41
LABEL L44
!       IF (i < 32) & (ch = 0X) THEN res := 0 END
LINE 177
LDLW -4
CONST 32
JGEQ L42
LDLC -5
JNEQZ L42
CONST 0
STGW OMSPL.res
LABEL L42
RETURN
END

PROC OMSPL.FindModMap 0 7 0x00500001
!   PROCEDURE FindModMap(name: ARRAY OF CHAR; VAR mm: ModMaps);
LINE 181
!   BEGIN mm := maps;
LINE 182
LDGW OMSPL.maps
LDLW 20
STOREW
LABEL L59
!     WHILE (mm # NIL) & (name # mm.name) DO mm := mm.next END;
LINE 183
LDLW 20
LOADW
JEQZ L61
LDLW 20
LOADW
CONST 32
SWAP
NCHECK 183
LDLW 16
LDLW 12
GLOBAL COMPARE
CALLW 4
JEQZ L61
LDLW 20
LOADW
NCHECK 183
LDNW 32
LDLW 20
STOREW
JUMP L59
LABEL L61
!     IF mm = NIL THEN NEW(mm); mm.name := name; mm.next := maps; maps := mm END
LINE 184
LDLW 20
LOADW
JNEQZ L65
CONST 492
GLOBAL OMSPL.ModMapsDesc
GLOBAL NEW
CALLW 2
LDLW 20
STOREW
LDLW 20
LOADW
CONST 32
SWAP
NCHECK 184
LDLW 16
LDLW 12
CONST 1
CONST 1
GLOBAL FLEXASSIGN
CALL 6
LDGW OMSPL.maps
LDLW 20
LOADW
NCHECK 184
STNW 32
LDLW 20
LOADW
STGW OMSPL.maps
LABEL L65
RETURN
END

PROC OMSPL.LinkOne 336 8 OMSPL.LinkOne.%map
!   PROCEDURE LinkOne(name: ARRAY OF CHAR; VAR newmod: Module;
LINE 187
!   BEGIN mod := first; error(noerr, name);
LINE 205
LDGW OMSPL.first
STLW -4
LDLW 16
LDLW 12
CONST 0
GLOBAL OMSPL.error
CALL 3
LABEL L66
!     WHILE (mod # NIL) & (name # mod.name) DO mod := mod.next END ;
LINE 206
LDLW -4
JEQZ L68
CONST 32
LDLW -4
NCHECK 206
LDLW 16
LDLW 12
GLOBAL COMPARE
CALLW 4
JEQZ L68
LDLW -4
NCHECK 206
LDNW 32
STLW -4
JUMP L66
LABEL L68
!     IF mod = NIL THEN (*link*)
LINE 207
LDLW -4
JNEQZ L72
!       Check(name); k := 0; mno := 0;
LINE 208
LDLW 16
LDLW 12
GLOBAL OMSPL.Check
CALL 2
CONST 0
STLW -16
CONST 0
STLC -165
!       IF res = noerr THEN F := ThisFile(name) ELSE F := NIL END ;
LINE 209
LDGW OMSPL.res
JNEQZ L75
LDLW 16
LDLW 12
GLOBAL OMSPL.ThisFile
CALLW 2
STLW -88
JUMP L73
LABEL L75
CONST 0
STLW -88
LABEL L73
!       IF F # NIL THEN
LINE 210
LDLW -88
JEQZ L78
!         Files.Set(R, F, 0); Files.ReadString(R, name1); Files.ReadInt(R, k); Files.ReadByte(R, mno);
LINE 211
CONST 0
LDLW -88
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.Set
CALL 4
CONST 32
LOCAL -84
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadString
CALL 4
LOCAL -16
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadInt
CALL 3
LOCAL -165
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadByte
CALL 3
!         IF mno IN {version*2, version*2+1} THEN mno := mno MOD 2;
LINE 212
CONST 1
LDLC -165
CONST 32
BOUND 212
LSL
CONST 12
BITAND
JEQZ L81
LDLC -165
CONST 2
MOD
STLC -165
!           IF name = name1 THEN nofimps := 0;
LINE 213
CONST 32
LOCAL -84
LDLW 16
LDLW 12
GLOBAL COMPARE
CALLW 4
JNEQZ L84
CONST 0
STLW -24
!             Files.ReadString(R, name1);   (*imports*)
LINE 214
CONST 32
LOCAL -84
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadString
CALL 4
LABEL L85
!             WHILE (name1[0] # 0X) & (res = noerr) DO
LINE 215
LDLC -84
JEQZ L76
LDGW OMSPL.res
JNEQZ L76
!               Files.ReadInt(R, l);
LINE 216
LOCAL -20
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadInt
CALL 3
!               LinkOne(name1, impmod, sec, MW); import[nofimps] := impmod; INC(nofimps);
LINE 217
LDLW 36
LDLW 32
LDLW 28
LDLW 24
LOCAL -8
CONST 32
LOCAL -84
GLOBAL OMSPL.LinkOne
CALL 7
LDLW -8
LOCAL -164
LDLW -24
CONST 16
BOUND 217
STIW
INCL -24
!               IF res = noerr THEN
LINE 218
LDGW OMSPL.res
JNEQZ L85
!                 IF impmod.key # l THEN error(badkey, name); imported := name1 END;
LINE 219
LDLW -8
NCHECK 219
LDNW 36
LDLW -20
JEQ L93
LDLW 16
LDLW 12
CONST 3
GLOBAL OMSPL.error
CALL 3
GLOBAL OMSPL.imported
LOCAL -84
CONST 32
FIXCOPY
LABEL L93
!                 Files.ReadString(R, name1)
LINE 220
CONST 32
LOCAL -84
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadString
CALL 4
JUMP L85
LABEL L84
!           ELSE error(badfile, name)
LINE 223
LDLW 16
LDLW 12
CONST 4
GLOBAL OMSPL.error
CALL 3
JUMP L76
LABEL L81
!         ELSE error(notsupported, name)
LINE 225
LDLW 16
LDLW 12
CONST 8
GLOBAL OMSPL.error
CALL 3
JUMP L76
LABEL L78
!       ELSE error(nofile, name)
LINE 227
LDLW 16
LDLW 12
CONST 1
GLOBAL OMSPL.error
CALL 3
LABEL L76
!       IF res = noerr THEN MW.col := Display.yellow;
LINE 229
LDGW OMSPL.res
JNEQZ L97
CONST 252
LDLW 32
STNW 4
!         Texts.WriteString(MW, "Module "); Texts.WriteString(MW, name); Texts.WriteLn(MW);
LINE 230
CONST 8
GLOBAL OMSPL.%2
LDLW 36
LDLW 32
GLOBAL Texts.WriteString
CALL 4
LDLW 16
LDLW 12
LDLW 36
LDLW 32
GLOBAL Texts.WriteString
CALL 4
LDLW 36
LDLW 32
GLOBAL Texts.WriteLn
CALL 2
!         MW.col := Display.white; FindModMap(name, mm);
LINE 231
CONST 255
LDLW 32
STNW 4
LOCAL -308
LDLW 16
LDLW 12
GLOBAL OMSPL.FindModMap
CALL 3
!         NEW(mod);
LINE 232
CONST 320
GLOBAL OMSPL.ModDesc
GLOBAL NEW
CALLW 2
STLW -4
!         IF first = NIL THEN mod.num := 1; first := mod ELSE mod.num := last.num + 1; last.next := mod END;
LINE 233
LDGW OMSPL.first
JNEQZ L100
CONST 1
LDLW -4
NCHECK 233
STNW 40
LDLW -4
STGW OMSPL.first
JUMP L98
LABEL L100
LDGW OMSPL.last
NCHECK 233
LDNW 40
INC
LDLW -4
NCHECK 233
STNW 40
LDLW -4
LDGW OMSPL.last
NCHECK 233
STNW 32
LABEL L98
!         last := mod; mod.next := NIL;
LINE 234
LDLW -4
STGW OMSPL.last
CONST 0
LDLW -4
NCHECK 234
STNW 32
!         mod.name := name;
LINE 235
CONST 32
LDLW -4
NCHECK 235
LDLW 16
LDLW 12
CONST 1
CONST 1
GLOBAL FLEXASSIGN
CALL 6
!         i := 0; REPEAT INC(i) UNTIL mod.name[i] = 0X; REPEAT mod.name[i] := 0X; INC(i) UNTIL i=32;
LINE 236
CONST 0
STLW -12
LABEL L101
INCL -12
LDLW -4
NCHECK 236
LDLW -12
CONST 32
BOUND 236
LDIC
JNEQZ L101
LABEL L103
CONST 0
LDLW -4
NCHECK 236
LDLW -12
CONST 32
BOUND 236
STIC
INCL -12
LDLW -12
CONST 32
JNEQ L103
!         mod.key := k; mod.codeseg := mno;
LINE 237
LDLW -16
LDLW -4
NCHECK 237
STNW 36
LDLC -165
LDLW -4
NCHECK 237
CONST 316
STIC
!         mod.varsto := RAMAllocPtr; (*storage address in RAM*)
LINE 238
LDGW OMSPL.RAMAllocPtr
LDLW -4
NCHECK 238
STNW 44
!         mod.flashsto := Flash.allocPtr; (*storage address in flash memory*)
LINE 239
LDGW OMSPL.Flash
NCHECK 239
LDNW 4
LDLW -4
NCHECK 239
STNW 48
!         secfpos := Files.Pos(R); nofsecs := 0;
LINE 246
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.Pos
CALLW 2
STLW -300
CONST 0
STLW -304
!         Files.Read(R, ch);
LINE 247
LOCAL -25
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.Read
CALL 3
LABEL L105
!         WHILE ch # 0X DO
LINE 248
LDLC -25
JEQZ L107
!           sec[nofsecs].segment := ch; sec[nofsecs].eadr := -1;
LINE 249
LDLC -25
LDLW 24
LDLW -304
LDLW 28
BOUND 249
CONST 44
TIMES
STIC
CONST -1
LDLW 24
LDLW -304
LDLW 28
BOUND 249
CONST 44
TIMES
OFFSET
STNW 36
!           keep := nofsecs MOD 32 IN mm.refm[nofsecs DIV 32]; (*keep the section if referenced*)
LINE 250
LDLW -308
NCHECK 250
CONST 364
OFFSET
LDLW -304
CONST 32
DIV
CONST 16
BOUND 250
LDIW
CONST 1
LDLW -304
CONST 32
MOD
CONST 32
BOUND 250
LSL
BITAND
CONST 0
NEQ
STLC -309
!           Files.ReadString(R, sec[nofsecs].name); Files.ReadHalfWord(R, sec[nofsecs].size);
LINE 251
LDLW 24
LDLW -304
LDLW 28
BOUND 251
CONST 44
TIMES
OFFSET
CONST 1
OFFSET
CONST 32
SWAP
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadString
CALL 4
LDLW 24
LDLW -304
LDLW 28
BOUND 251
CONST 44
TIMES
OFFSET
CONST 40
OFFSET
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
!           IF (ch = "c") OR (ch = "d") OR (ch = "s") THEN (*in flash memory*)
LINE 252
LDLC -25
CONST 99
JEQ L109
LDLC -25
CONST 100
JEQ L109
LDLC -25
CONST 115
JNEQ L110
LABEL L109
!             IF keep THEN
LINE 253
LDLC -309
JEQZ L115
!               IF sec[nofsecs].size >= G.WordSize THEN padFlash END; sec[nofsecs].eadr := Flash.allocPtr;
LINE 254
LDLW 24
LDLW -304
LDLW 28
BOUND 254
CONST 44
TIMES
OFFSET
LDNW 40
CONST 2
JLT L118
GLOBAL OMSPL.padFlash
CALL 0
LABEL L118
LDGW OMSPL.Flash
NCHECK 254
LDNW 4
LDLW 24
LDLW -304
LDLW 28
BOUND 254
CONST 44
TIMES
OFFSET
STNW 36
!               FOR i := 0 TO sec[nofsecs].size - 1 DO Files.ReadByte(R, mno); EmitByte(mno) END
LINE 255
LDLW 24
LDLW -304
LDLW 28
BOUND 255
CONST 44
TIMES
OFFSET
LDNW 40
DEC
STLW -316
CONST 0
STLW -12
LABEL L119
LDLW -12
LDLW -316
JGT L108
LOCAL -165
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadByte
CALL 3
LDLC -165
GLOBAL OMSPL.EmitByte
CALL 1
INCL -12
JUMP L119
LABEL L115
!             ELSE FOR i := 0 TO sec[nofsecs].size - 1 DO Files.ReadByte(R, mno) END (*skip data*)
LINE 256
LDLW 24
LDLW -304
LDLW 28
BOUND 256
CONST 44
TIMES
OFFSET
LDNW 40
DEC
STLW -320
CONST 0
STLW -12
LABEL L112
LDLW -12
LDLW -320
JGT L108
LOCAL -165
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadByte
CALL 3
INCL -12
JUMP L112
LABEL L110
!           ELSIF ch = "v" THEN (*vector table*)
LINE 258
LDLC -25
CONST 118
JNEQ L124
!             FOR i := 0 TO sec[nofsecs].size DIV 2 - 1 DO Files.ReadHalfWord(R, adr); vec[i] := adr END; (*module vector table*)
LINE 259
LDLW 24
LDLW -304
LDLW 28
BOUND 259
CONST 44
TIMES
OFFSET
LDNW 40
CONST 2
DIV
DEC
STLW -324
CONST 0
STLW -12
LABEL L125
LDLW -12
LDLW -324
JGT L108
LOCAL -32
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
LDLW -32
LOCAL -296
LDLW -12
CONST 32
BOUND 259
STIW
INCL -12
JUMP L125
LABEL L124
!           ELSIF ch = "r" THEN
LINE 260
LDLC -25
CONST 114
JNEQ L128
!             IF keep THEN
LINE 261
LDLC -309
JEQZ L108
!               IF sec[nofsecs].size >= G.WordSize THEN align(RAMAllocPtr) END; sec[nofsecs].eadr := RAMAllocPtr;
LINE 262
LDLW 24
LDLW -304
LDLW 28
BOUND 262
CONST 44
TIMES
OFFSET
LDNW 40
CONST 2
JLT L134
GLOBAL OMSPL.RAMAllocPtr
GLOBAL OMSPL.align
CALL 1
LABEL L134
LDGW OMSPL.RAMAllocPtr
LDLW 24
LDLW -304
LDLW 28
BOUND 262
CONST 44
TIMES
OFFSET
STNW 36
!               INC(RAMAllocPtr, sec[nofsecs].size)
LINE 263
GLOBAL OMSPL.RAMAllocPtr
DUP 0
LOADW
LDLW 24
LDLW -304
LDLW 28
BOUND 263
CONST 44
TIMES
OFFSET
LDNW 40
PLUS
SWAP
STOREW
JUMP L108
LABEL L128
!           ELSE error(badfile, name)
LINE 265
LDLW 16
LDLW 12
CONST 4
GLOBAL OMSPL.error
CALL 3
LABEL L108
!           Files.ReadHalfWord(R, adr); (*skip fixup data*)
LINE 267
LOCAL -32
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
LABEL L135
!           WHILE adr # 0 DO
LINE 268
LDLW -32
JEQZ L137
!             Files.ReadByte(R, mno); Files.ReadHalfWord(R, sno); Files.ReadHalfWord(R, ofs);
LINE 269
LOCAL -165
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadByte
CALL 3
LOCAL -40
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
LOCAL -36
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
!             Files.ReadByte(R, mnor); Files.ReadHalfWord(R, snor);
LINE 270
LOCAL -166
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadByte
CALL 3
LOCAL -48
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
!             Files.ReadHalfWord(R, adr)
LINE 271
LOCAL -32
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
JUMP L135
LABEL L137
!           INC(nofsecs);
LINE 273
INCL -304
!           Files.Read(R, ch)
LINE 274
LOCAL -25
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.Read
CALL 3
JUMP L105
LABEL L107
!         padFlash; mod.flashsize := Flash.allocPtr - mod.flashsto;
LINE 276
GLOBAL OMSPL.padFlash
CALL 0
LDGW OMSPL.Flash
NCHECK 276
LDNW 4
LDLW -4
NCHECK 276
LDNW 48
MINUS
LDLW -4
NCHECK 276
STNW 56
!         IF mod.codeseg = 1 THEN (*execute in RAM*) mod.codeexe := RAMAllocPtr; INC(RAMAllocPtr, mod.flashsize)
LINE 277
LDLW -4
NCHECK 277
CONST 316
LDIC
CONST 1
JNEQ L140
LDGW OMSPL.RAMAllocPtr
LDLW -4
NCHECK 277
STNW 52
GLOBAL OMSPL.RAMAllocPtr
DUP 0
LOADW
LDLW -4
NCHECK 277
LDNW 56
PLUS
SWAP
STOREW
JUMP L138
LABEL L140
!         ELSE mod.codeexe := Flash.origin + mod.flashsto
LINE 278
LDGW OMSPL.Flash
NCHECK 278
LOADW
LDLW -4
NCHECK 278
LDNW 48
PLUS
LDLW -4
NCHECK 278
STNW 52
LABEL L138
!         IF res = noerr THEN
LINE 280
LDGW OMSPL.res
JNEQZ L97
!           FOR i := 0 TO nofsecs - 1 DO
LINE 282
LDLW -304
DEC
STLW -328
CONST 0
STLW -12
LABEL L144
LDLW -12
LDLW -328
JGT L145
!             IF i MOD 32 IN mm.refm[i DIV 32] THEN (*adjust address of the section if referenced*)
LINE 283
LDLW -308
NCHECK 283
CONST 364
OFFSET
LDLW -12
CONST 32
DIV
CONST 16
BOUND 283
LDIW
CONST 1
LDLW -12
CONST 32
MOD
CONST 32
BOUND 283
LSL
BITAND
JEQZ L148
!               Texts.WriteString(MW, sec[i].name); Texts.Write(MW, 09X);
LINE 284
LDLW 24
LDLW -12
LDLW 28
BOUND 284
CONST 44
TIMES
OFFSET
CONST 1
OFFSET
CONST 32
SWAP
LDLW 36
LDLW 32
GLOBAL Texts.WriteString
CALL 4
CONST 9
ALIGNC
LDLW 36
LDLW 32
GLOBAL Texts.Write
CALL 3
!               ch := sec[i].segment; Texts.Write(MW, ch);
LINE 285
LDLW 24
LDLW -12
LDLW 28
BOUND 285
CONST 44
TIMES
LDIC
STLC -25
LDLC -25
ALIGNC
LDLW 36
LDLW 32
GLOBAL Texts.Write
CALL 3
!               IF (ch = "c") OR (ch = "d") OR (ch = "s") THEN (*in flash memory*)
LINE 286
LDLC -25
CONST 99
JEQ L150
LDLC -25
CONST 100
JEQ L150
LDLC -25
CONST 115
JNEQ L151
LABEL L150
!                 DEC(sec[i].eadr, mod.flashsto - mod.codeexe)
LINE 287
LDLW 24
LDLW -12
LDLW 28
BOUND 287
CONST 44
TIMES
OFFSET
CONST 36
OFFSET
DUP 0
LOADW
LDLW -4
NCHECK 287
LDNW 48
LDLW -4
NCHECK 287
LDNW 52
MINUS
MINUS
SWAP
STOREW
LABEL L151
!               IF ch # "v" THEN Texts.WriteHexVLen(MW, sec[i].eadr, 4, FALSE) END; Texts.Write(MW, 09X);
LINE 289
LDLC -25
CONST 118
JEQ L156
CONST 0
ALIGNC
CONST 4
LDLW 24
LDLW -12
LDLW 28
BOUND 289
CONST 44
TIMES
OFFSET
LDNW 36
LDLW 36
LDLW 32
GLOBAL Texts.WriteHexVLen
CALL 5
LABEL L156
CONST 9
ALIGNC
LDLW 36
LDLW 32
GLOBAL Texts.Write
CALL 3
!               Texts.WriteInt(MW, sec[i].size, 1); Texts.WriteLn(MW)
LINE 290
CONST 1
LDLW 24
LDLW -12
LDLW 28
BOUND 290
CONST 44
TIMES
OFFSET
LDNW 40
LDLW 36
LDLW 32
GLOBAL Texts.WriteInt
CALL 4
LDLW 36
LDLW 32
GLOBAL Texts.WriteLn
CALL 2
LABEL L148
!           FOR i := 0 TO nofsecs - 1 DO
LINE 282
INCL -12
JUMP L144
LABEL L145
!           Texts.WriteString(MW, "codeexe"); Texts.Write(MW, 09X); 
LINE 293
CONST 8
GLOBAL OMSPL.%3
LDLW 36
LDLW 32
GLOBAL Texts.WriteString
CALL 4
CONST 9
ALIGNC
LDLW 36
LDLW 32
GLOBAL Texts.Write
CALL 3
!           Texts.WriteHexVLen(MW, mod.codeexe, 4, FALSE); Texts.WriteLn(MW);
LINE 294
CONST 0
ALIGNC
CONST 4
LDLW -4
NCHECK 294
LDNW 52
LDLW 36
LDLW 32
GLOBAL Texts.WriteHexVLen
CALL 5
LDLW 36
LDLW 32
GLOBAL Texts.WriteLn
CALL 2
!           Files.Set(R, Files.Base(R), secfpos); (*rewind rider to beginning of sections list*)
LINE 296
LDLW -300
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.Base
CALLW 2
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.Set
CALL 4
!           no := 0; Files.Read(R, ch);
LINE 297
CONST 0
STLW -44
LOCAL -25
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.Read
CALL 3
LABEL L157
!           WHILE ch # 0X DO (*go to fixup data*)
LINE 298
LDLC -25
JEQZ L159
!             keep := no MOD 32 IN mm.refm[no DIV 32]; (*fixup the section dependencies if referenced*)
LINE 299
LDLW -308
NCHECK 299
CONST 364
OFFSET
LDLW -44
CONST 32
DIV
CONST 16
BOUND 299
LDIW
CONST 1
LDLW -44
CONST 32
MOD
CONST 32
BOUND 299
LSL
BITAND
CONST 0
NEQ
STLC -309
!             Files.ReadString(R, name1); Files.ReadHalfWord(R, k);
LINE 300
CONST 32
LOCAL -84
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadString
CALL 4
LOCAL -16
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
!             IF (ch = "c") OR (ch = "d") OR (ch = "s") OR (ch = "v") THEN
LINE 301
LDLC -25
CONST 99
JEQ L161
LDLC -25
CONST 100
JEQ L161
LDLC -25
CONST 115
JEQ L161
LDLC -25
CONST 118
JNEQ L162
LABEL L161
!               FOR i := 0 TO k - 1 DO Files.ReadByte(R, mno) END (*skip content*)
LINE 302
LDLW -16
DEC
STLW -332
CONST 0
STLW -12
LABEL L163
LDLW -12
LDLW -332
JGT L162
LOCAL -165
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadByte
CALL 3
INCL -12
JUMP L163
LABEL L162
!             Files.ReadHalfWord(R, adr); (*entering fixup data*)
LINE 304
LOCAL -32
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
LABEL L168
!             WHILE adr # 0 DO
LINE 305
LDLW -32
JEQZ L170
!               Files.ReadByte(R, mno); Files.ReadHalfWord(R, sno); Files.ReadHalfWord(R, ofs);
LINE 306
LOCAL -165
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadByte
CALL 3
LOCAL -40
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
LOCAL -36
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
!               Files.ReadByte(R, mnor); Files.ReadHalfWord(R, snor);
LINE 307
LOCAL -166
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadByte
CALL 3
LOCAL -48
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
!               IF keep THEN
LINE 308
LDLC -309
JEQZ L173
!                 IF mno = 0 THEN dest := sec[sno].eadr ELSE dest := import[mno - 1].ent[sno] END;
LINE 309
LDLC -165
JNEQZ L176
LDLW 24
LDLW -40
LDLW 28
BOUND 309
CONST 44
TIMES
OFFSET
LDNW 36
STLW -52
JUMP L174
LABEL L176
LOCAL -164
LDLC -165
DEC
CONST 16
BOUND 309
LDIW
NCHECK 309
CONST 60
OFFSET
LDLW -40
CONST 64
BOUND 309
LDIW
STLW -52
LABEL L174
!                 INC(dest, ofs); (*dest contains now the effective address*)
LINE 310
LOCAL -52
DUP 0
LOADW
LDLW -36
PLUS
SWAP
STOREW
!                 IF mnor # 0FFH THEN
LINE 311
LDLC -166
CONST 255
JEQ L179
!                   IF mnor = 0 THEN DEC(dest, sec[snor].eadr) ELSE DEC(dest, import[mnor - 1].ent[snor]) END
LINE 312
LDLC -166
JNEQZ L182
LOCAL -52
DUP 0
LOADW
LDLW 24
LDLW -48
LDLW 28
BOUND 312
CONST 44
TIMES
OFFSET
LDNW 36
MINUS
SWAP
STOREW
JUMP L179
LABEL L182
LOCAL -52
DUP 0
LOADW
LOCAL -164
LDLC -166
DEC
CONST 16
BOUND 312
LDIW
NCHECK 312
CONST 60
OFFSET
LDLW -48
CONST 64
BOUND 312
LDIW
MINUS
SWAP
STOREW
LABEL L179
!                 IF ch = "v" THEN (*vector table*)
LINE 314
LDLC -25
CONST 118
JNEQ L190
LABEL L191
!                   REPEAT i := (adr - 1) DIV 2;
LINE 315
LDLW -32
DEC
CONST 2
DIV
STLW -12
!                     IF vector[i] # 0FFFFH THEN
LINE 316
GLOBAL OMSPL.vector
LDLW -12
CONST 32
BOUND 316
LDIW
CONST 65535
JEQ L195
!                       Texts.WriteString(W, "interrupt vector number"); Texts.WriteInt(W, i, 3); error(duphandler, name1)
LINE 317
CONST 24
GLOBAL OMSPL.%4
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
CONST 3
LDLW -12
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteInt
CALL 4
CONST 32
LOCAL -84
CONST 2
GLOBAL OMSPL.error
CALL 3
LABEL L195
!                     vector[i] := dest; adr := vec[i]
LINE 319
LDLW -52
GLOBAL OMSPL.vector
LDLW -12
CONST 32
BOUND 319
STIW
LOCAL -296
LDLW -12
CONST 32
BOUND 319
LDIW
STLW -32
!                   UNTIL adr = 0;
LINE 320
LDLW -32
JNEQZ L191
JUMP L173
LABEL L190
!                 ELSE l := sec[no].eadr; IF ch # "r" THEN DEC(l, mod.codeexe - mod.flashsto) END;
LINE 321
LDLW 24
LDLW -44
LDLW 28
BOUND 321
CONST 44
TIMES
OFFSET
LDNW 36
STLW -20
LDLC -25
CONST 114
JEQ L186
LOCAL -20
DUP 0
LOADW
LDLW -4
NCHECK 321
LDNW 52
LDLW -4
NCHECK 321
LDNW 48
MINUS
MINUS
SWAP
STOREW
LABEL L186
!                   REPEAT k := GetWordAt(l + adr - 1); PutWordAt(l + adr - 1, dest); adr := k UNTIL adr = 0
LINE 322
LDLW -20
LDLW -32
PLUS
DEC
GLOBAL OMSPL.GetWordAt
CALLW 1
STLW -16
LDLW -52
LDLW -20
LDLW -32
PLUS
DEC
GLOBAL OMSPL.PutWordAt
CALL 2
LDLW -16
STLW -32
LDLW -32
JNEQZ L186
LABEL L173
!               Files.ReadHalfWord(R, adr)
LINE 325
LOCAL -32
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
JUMP L168
LABEL L170
!             INC(no); Files.Read(R, ch)
LINE 327
INCL -44
LOCAL -25
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.Read
CALL 3
JUMP L157
LABEL L159
!           Files.ReadHalfWord(R, k); (*number of entries*)
LINE 329
LOCAL -16
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
!           FOR i := 0 TO k - 1 DO Files.ReadHalfWord(R, sno);
LINE 330
LDLW -16
DEC
STLW -336
CONST 0
STLW -12
LABEL L196
LDLW -12
LDLW -336
JGT L197
LOCAL -40
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.ReadHalfWord
CALL 3
!             mod.ent[i] := sec[sno].eadr
LINE 331
LDLW 24
LDLW -40
LDLW 28
BOUND 331
CONST 44
TIMES
OFFSET
LDNW 36
LDLW -4
NCHECK 331
CONST 60
OFFSET
LDLW -12
CONST 64
BOUND 331
STIW
!           FOR i := 0 TO k - 1 DO Files.ReadHalfWord(R, sno);
LINE 330
INCL -12
JUMP L196
LABEL L197
!           IF GetWordAt(mod.ent[0] - mod.codeexe + mod.flashsto) = 4130H THEN (*module init is empty*)
LINE 333
LDLW -4
NCHECK 333
LDNW 60
LDLW -4
NCHECK 333
LDNW 52
MINUS
LDLW -4
NCHECK 333
LDNW 48
PLUS
GLOBAL OMSPL.GetWordAt
CALLW 1
CONST 16688
JNEQ L200
!             DEC(mod.flashsize, 2); mod.ent[0] := -1; (*mark init address as invalid*)
LINE 334
LDLW -4
NCHECK 334
DUP 0
LDNW 56
CONST 2
MINUS
SWAP
STNW 56
CONST -1
LDLW -4
NCHECK 334
STNW 60
!             IF mod.codeseg = 1 THEN DEC(RAMAllocPtr, 2) END;
LINE 335
LDLW -4
NCHECK 335
CONST 316
LDIC
CONST 1
JNEQ L203
LDGW OMSPL.RAMAllocPtr
CONST 2
MINUS
STGW OMSPL.RAMAllocPtr
LABEL L203
!             DEC(Flash.allocPtr, 2)
LINE 336
LDGW OMSPL.Flash
NCHECK 336
DUP 0
LDNW 4
CONST 2
MINUS
SWAP
STNW 4
LABEL L200
!           Files.Read(R, ch);
LINE 338
LOCAL -25
GLOBAL POFiles.Rider
LOCAL -100
GLOBAL POFiles.Read
CALL 3
!           IF ch # "O" THEN mod := NIL; error(badfile, name) END
LINE 339
LDLC -25
CONST 79
JEQ L97
CONST 0
STLW -4
LDLW 16
LDLW 12
CONST 4
GLOBAL OMSPL.error
CALL 3
LABEL L97
!       IF res >= badkey THEN importing := name END;
LINE 342
LDGW OMSPL.res
CONST 3
JLT L209
CONST 32
GLOBAL OMSPL.importing
LDLW 16
LDLW 12
CONST 1
CONST 1
GLOBAL FLEXASSIGN
CALL 6
LABEL L209
!       Texts.WriteLn(MW)
LINE 343
LDLW 36
LDLW 32
GLOBAL Texts.WriteLn
CALL 2
LABEL L72
!     newmod := mod
LINE 345
LDLW -4
LDLW 20
STOREW
RETURN
END

PROC OMSPL.Mark 92 6 OMSPL.Mark.%map
!   PROCEDURE Mark(name: ARRAY OF CHAR; VAR mm: ModMaps);
LINE 356
!   BEGIN error(noerr, name);
LINE 363
LDLW 16
LDLW 12
CONST 0
GLOBAL OMSPL.error
CALL 3
!     FindModMap(name, mm);
LINE 364
LDLW 20
LDLW 16
LDLW 12
GLOBAL OMSPL.FindModMap
CALL 3
!     IF mm.sections = NIL THEN (*load module data from object file*)
LINE 365
LDLW 20
LOADW
NCHECK 365
LDNW 36
JNEQZ L212
!       Check(name);
LINE 366
LDLW 16
LDLW 12
GLOBAL OMSPL.Check
CALL 2
!       IF res = noerr THEN F := ThisFile(name) ELSE F := NIL END ;
LINE 367
LDGW OMSPL.res
JNEQZ L215
LDLW 16
LDLW 12
GLOBAL OMSPL.ThisFile
CALLW 2
STLW -8
JUMP L213
LABEL L215
CONST 0
STLW -8
LABEL L213
!       IF F # NIL THEN
LINE 368
LDLW -8
JEQZ L218
!         Files.Set(R, F, 0); Files.ReadString(R, name1); Files.ReadInt(R, w); Files.ReadByte(R, b);
LINE 369
CONST 0
LDLW -8
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.Set
CALL 4
CONST 32
LOCAL -52
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadString
CALL 4
LOCAL -64
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadInt
CALL 3
LOCAL -54
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadByte
CALL 3
!         IF b IN {version*2, version*2+1} THEN
LINE 370
CONST 1
LDLC -54
CONST 32
BOUND 370
LSL
CONST 12
BITAND
JEQZ L221
!           IF name = name1 THEN mm.import[0] := mm;
LINE 371
CONST 32
LOCAL -52
LDLW 16
LDLW 12
GLOBAL COMPARE
CALLW 4
JNEQZ L224
LDLW 20
LOADW
LDLW 20
LOADW
NCHECK 371
STNW 40
!             Files.ReadString(R, name1);   (*imports*)
LINE 372
CONST 32
LOCAL -52
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadString
CALL 4
LABEL L225
!             WHILE (name1[0] # 0X) & (res = noerr) DO
LINE 373
LDLC -52
JEQZ L227
LDGW OMSPL.res
JNEQZ L227
!               Files.ReadInt(R, w); Mark(name1, im); INC(mm.nofimps); mm.import[mm.nofimps] := im;
LINE 374
LOCAL -64
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadInt
CALL 3
LOCAL -4
CONST 32
LOCAL -52
GLOBAL OMSPL.Mark
CALL 3
LDLW 20
LOADW
NCHECK 374
DUP 0
LDNW 104
INC
SWAP
STNW 104
LDLW -4
LDLW 20
LOADW
NCHECK 374
CONST 40
OFFSET
LDLW 20
LOADW
NCHECK 374
LDNW 104
CONST 16
BOUND 374
STIW
!               Files.ReadString(R, name1)
LINE 375
CONST 32
LOCAL -52
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadString
CALL 4
JUMP L225
LABEL L227
!             no := 0; Files.Read(R, ch);  (*sections*)
LINE 377
CONST 0
STLW -68
LOCAL -53
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.Read
CALL 3
LABEL L229
!             WHILE ch # 0X DO NEW(s); s.next := mm.sections; mm.sections := s; s.no := no;
LINE 378
LDLC -53
JEQZ L231
CONST 12
GLOBAL OMSPL.SecDepDesc
GLOBAL NEW
CALLW 2
STLW -72
LDLW 20
LOADW
NCHECK 378
LDNW 36
LDLW -72
NCHECK 378
STNW 8
LDLW -72
LDLW 20
LOADW
NCHECK 378
STNW 36
LDLW -68
LDLW -72
NCHECK 378
STOREW
!               IF ch = "v" THEN INCL(mm.tdm[no DIV 32], no MOD 32) END; (*add the interrupt handler to do list*)
LINE 379
LDLC -53
CONST 118
JNEQ L234
LDLW 20
LOADW
NCHECK 379
CONST 428
OFFSET
LDLW -68
CONST 32
DIV
CONST 16
BOUND 379
INDEXW
DUP 0
LOADW
CONST 1
LDLW -68
CONST 32
MOD
CONST 32
BOUND 379
LSL
BITOR
SWAP
STOREW
LABEL L234
!               Files.ReadString(R, name1); Files.ReadHalfWord(R, w);
LINE 381
CONST 32
LOCAL -52
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadString
CALL 4
LOCAL -64
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadHalfWord
CALL 3
!               IF (ch = "c") OR (ch = "d") OR (ch = "s") OR (ch = "v") THEN
LINE 382
LDLC -53
CONST 99
JEQ L236
LDLC -53
CONST 100
JEQ L236
LDLC -53
CONST 115
JEQ L236
LDLC -53
CONST 118
JNEQ L237
LABEL L236
!                 FOR i := 0 TO w - 1 DO Files.ReadByte(R, b) END (*skip content*)
LINE 383
LDLW -64
DEC
STLW -84
CONST 0
STLW -60
LABEL L238
LDLW -60
LDLW -84
JGT L237
LOCAL -54
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadByte
CALL 3
INCL -60
JUMP L238
LABEL L237
!               Files.ReadHalfWord(R, w); (*entering fixup data*)
LINE 385
LOCAL -64
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadHalfWord
CALL 3
LABEL L243
!               WHILE w # 0 DO NEW(d); d.next := s.dep; s.dep := d;
LINE 386
LDLW -64
JEQZ L245
CONST 12
GLOBAL OMSPL.DependDesc
GLOBAL NEW
CALLW 2
STLW -76
LDLW -72
NCHECK 386
LDNW 4
LDLW -76
NCHECK 386
STNW 8
LDLW -76
LDLW -72
NCHECK 386
STNW 4
!                 Files.ReadByte(R, d.mno); Files.ReadHalfWord(R, d.sno); Files.ReadHalfWord(R, i); (*skip offset*)
LINE 387
LDLW -76
NCHECK 387
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadByte
CALL 3
LDLW -76
NCHECK 387
CONST 4
OFFSET
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadHalfWord
CALL 3
LOCAL -60
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadHalfWord
CALL 3
!                 Files.ReadByte(R, b); Files.ReadHalfWord(R, w);
LINE 388
LOCAL -54
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadByte
CALL 3
LOCAL -64
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadHalfWord
CALL 3
!                 IF b # 0FFH THEN NEW(d); d.next := s.dep; s.dep := d; d.mno := b; d.sno := w END;
LINE 389
LDLC -54
CONST 255
JEQ L248
CONST 12
GLOBAL OMSPL.DependDesc
GLOBAL NEW
CALLW 2
STLW -76
LDLW -72
NCHECK 389
LDNW 4
LDLW -76
NCHECK 389
STNW 8
LDLW -76
LDLW -72
NCHECK 389
STNW 4
LDLC -54
LDLW -76
NCHECK 389
STOREC
LDLW -64
LDLW -76
NCHECK 389
STNW 4
LABEL L248
!                 Files.ReadHalfWord(R, w)
LINE 390
LOCAL -64
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadHalfWord
CALL 3
JUMP L243
LABEL L245
!               INC(no); Files.Read(R, ch)
LINE 392
INCL -68
LOCAL -53
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.Read
CALL 3
JUMP L229
LABEL L231
!             Files.ReadHalfWord(R, w); (*number of entries*)
LINE 394
LOCAL -64
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadHalfWord
CALL 3
!             FOR i := 0 TO w - 1 DO Files.ReadHalfWord(R, mm.ent[i]) END;
LINE 395
LDLW -64
DEC
STLW -88
CONST 0
STLW -60
LABEL L249
LDLW -60
LDLW -88
JGT L250
LDLW 20
LOADW
NCHECK 395
CONST 108
OFFSET
LDLW -60
CONST 64
BOUND 395
INDEXW
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.ReadHalfWord
CALL 3
INCL -60
JUMP L249
LABEL L250
!             INCL(mm.tdm[mm.ent[0] DIV 32], mm.ent[0] MOD 32); (*add the module init section to the to do list*)
LINE 396
LDLW 20
LOADW
NCHECK 396
CONST 428
OFFSET
LDLW 20
LOADW
NCHECK 396
LDNW 108
CONST 32
DIV
CONST 16
BOUND 396
INDEXW
DUP 0
LOADW
CONST 1
LDLW 20
LOADW
NCHECK 396
LDNW 108
CONST 32
MOD
CONST 32
BOUND 396
LSL
BITOR
SWAP
STOREW
!             Files.Read(R, ch);
LINE 397
LOCAL -53
GLOBAL POFiles.Rider
LOCAL -20
GLOBAL POFiles.Read
CALL 3
!             IF ch # "O" THEN mm := NIL; error(badfile, name) END
LINE 398
LDLC -53
CONST 79
JEQ L212
CONST 0
LDLW 20
STOREW
LDLW 16
LDLW 12
CONST 4
GLOBAL OMSPL.error
CALL 3
JUMP L212
LABEL L224
!           ELSE error(badfile, name)
LINE 399
LDLW 16
LDLW 12
CONST 4
GLOBAL OMSPL.error
CALL 3
JUMP L212
LABEL L221
!         ELSE error(notsupported, name)
LINE 401
LDLW 16
LDLW 12
CONST 8
GLOBAL OMSPL.error
CALL 3
JUMP L212
LABEL L218
!       ELSE error(nofile, name)
LINE 403
LDLW 16
LDLW 12
CONST 1
GLOBAL OMSPL.error
CALL 3
LABEL L212
!     IF res = noerr THEN (*process the to do list*)
LINE 406
LDGW OMSPL.res
JNEQZ L256
LABEL L257
!       REPEAT done := TRUE;
LINE 407
CONST 1
STLC -77
!         s := mm.sections;
LINE 408
LDLW 20
LOADW
NCHECK 408
LDNW 36
STLW -72
LABEL L259
!         WHILE s # NIL DO
LINE 409
LDLW -72
JEQZ L261
!           IF s.no MOD 32 IN mm.tdm[s.no DIV 32] THEN
LINE 410
LDLW 20
LOADW
NCHECK 410
CONST 428
OFFSET
LDLW -72
NCHECK 410
LOADW
CONST 32
DIV
CONST 16
BOUND 410
LDIW
CONST 1
LDLW -72
NCHECK 410
LOADW
CONST 32
MOD
CONST 32
BOUND 410
LSL
BITAND
JEQZ L264
!             IF ~(s.no MOD 32 IN mm.refm[s.no DIV 32]) THEN
LINE 411
LDLW 20
LOADW
NCHECK 411
CONST 364
OFFSET
LDLW -72
NCHECK 411
LOADW
CONST 32
DIV
CONST 16
BOUND 411
LDIW
CONST 1
LDLW -72
NCHECK 411
LOADW
CONST 32
MOD
CONST 32
BOUND 411
LSL
BITAND
JNEQZ L267
!               INCL(mm.refm[s.no DIV 32], s.no MOD 32); (*insert in referenced map*)
LINE 412
LDLW 20
LOADW
NCHECK 412
CONST 364
OFFSET
LDLW -72
NCHECK 412
LOADW
CONST 32
DIV
CONST 16
BOUND 412
INDEXW
DUP 0
LOADW
CONST 1
LDLW -72
NCHECK 412
LOADW
CONST 32
MOD
CONST 32
BOUND 412
LSL
BITOR
SWAP
STOREW
!               d := s.dep;
LINE 413
LDLW -72
NCHECK 413
LDNW 4
STLW -76
LABEL L268
!               WHILE d # NIL DO
LINE 414
LDLW -76
JEQZ L267
!                 IF d.mno = 0 THEN (*current module*) INCL(mm.tdm[d.sno DIV 32], d.sno MOD 32)
LINE 416
LDLW -76
NCHECK 416
LOADC
JNEQZ L273
LDLW 20
LOADW
NCHECK 416
CONST 428
OFFSET
LDLW -76
NCHECK 416
LDNW 4
CONST 32
DIV
CONST 16
BOUND 416
INDEXW
DUP 0
LOADW
CONST 1
LDLW -76
NCHECK 416
LDNW 4
CONST 32
MOD
CONST 32
BOUND 416
LSL
BITOR
SWAP
STOREW
JUMP L271
LABEL L273
!                 ELSE (*imported*) im := mm.import[d.mno]; i := im.ent[d.sno];
LINE 417
LDLW 20
LOADW
NCHECK 417
CONST 40
OFFSET
LDLW -76
NCHECK 417
LOADC
CONST 16
BOUND 417
LDIW
STLW -4
LDLW -4
NCHECK 417
CONST 108
OFFSET
LDLW -76
NCHECK 417
LDNW 4
CONST 64
BOUND 417
LDIW
STLW -60
!                   INCL(im.tdm[i DIV 32], i MOD 32);
LINE 418
LDLW -4
NCHECK 418
CONST 428
OFFSET
LDLW -60
CONST 32
DIV
CONST 16
BOUND 418
INDEXW
DUP 0
LOADW
CONST 1
LDLW -60
CONST 32
MOD
CONST 32
BOUND 418
LSL
BITOR
SWAP
STOREW
LABEL L271
!                 done := FALSE;
LINE 420
CONST 0
STLC -77
!                 d := d.next
LINE 421
LDLW -76
NCHECK 421
LDNW 8
STLW -76
JUMP L268
LABEL L267
!             EXCL(mm.tdm[s.no DIV 32], s.no MOD 32); (*remove from to do list*)
LINE 424
LDLW 20
LOADW
NCHECK 424
CONST 428
OFFSET
LDLW -72
NCHECK 424
LOADW
CONST 32
DIV
CONST 16
BOUND 424
INDEXW
DUP 0
LOADW
CONST 1
LDLW -72
NCHECK 424
LOADW
CONST 32
MOD
CONST 32
BOUND 424
LSL
BITNOT
BITAND
SWAP
STOREW
LABEL L264
!           s := s.next
LINE 426
LDLW -72
NCHECK 426
LDNW 8
STLW -72
JUMP L259
LABEL L261
!       UNTIL done
LINE 428
LDLC -77
JEQZ L257
LABEL L256
!     FOR i := 1 TO mm.nofimps DO Mark(mm.import[i].name, im) END
LINE 430
LDLW 20
LOADW
NCHECK 430
LDNW 104
STLW -92
CONST 1
STLW -60
LABEL L274
LDLW -60
LDLW -92
JGT L275
LOCAL -4
LDLW 20
LOADW
NCHECK 430
CONST 40
OFFSET
LDLW -60
CONST 16
BOUND 430
LDIW
CONST 32
SWAP
NCHECK 430
GLOBAL OMSPL.Mark
CALL 3
INCL -60
JUMP L274
LABEL L275
RETURN
END

PROC OMSPL.Link 24788 9 OMSPL.Link.%map
!   PROCEDURE Link*;  (*link multiple object files together and create a single MSP430 TI-TXT file M.txt from them*)
LINE 433
!   BEGIN Texts.OpenScanner(S, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S); res := noerr; count := 0;
LINE 442
GLOBAL Oberon.Par
LDNW 4
LDGW Oberon.Par
GLOBAL Texts.Scanner
LOCAL -160
GLOBAL Texts.OpenScanner
CALL 4
GLOBAL Texts.Scanner
LOCAL -160
GLOBAL Texts.Scan
CALL 2
CONST 0
STGW OMSPL.res
CONST 0
STLW -20
!     Flash := SYSTEM.VAL(Segment, Modules.AllocPtr); FOR i := 0 TO 31 DO vector[i] := 0FFFFH END;
LINE 443
LDGW Modules.AllocPtr
STGW OMSPL.Flash
CONST 0
STLW -4
LABEL L276
LDLW -4
CONST 31
JGT L277
CONST 65535
GLOBAL OMSPL.vector
LDLW -4
CONST 32
BOUND 443
STIW
INCL -4
JUMP L276
LABEL L277
!     IF S.class = Texts.Int THEN  vecsize := S.i; Texts.Scan(S) ELSE vecsize := 0; res := nopar END;
LINE 444
LDLW -120
CONST 3
JNEQ L280
LDLQ -116
CONVQN
STLW -12
GLOBAL Texts.Scanner
LOCAL -160
GLOBAL Texts.Scan
CALL 2
JUMP L278
LABEL L280
CONST 0
STLW -12
CONST 6
STGW OMSPL.res
LABEL L278
!     IF S.class = Texts.Int THEN  limit := S.i - vecsize; Flash.origin := FlashEnd - S.i; Flash.allocPtr := 0; Texts.Scan(S) ELSE res := nopar END;
LINE 445
LDLW -120
CONST 3
JNEQ L283
LDLQ -116
LDLW -12
CONVNQ
QMINUS
CONVQN
STGW OMSPL.limit
QCONST 65536
LDLQ -116
QMINUS
CONVQN
LDGW OMSPL.Flash
NCHECK 445
STOREW
CONST 0
LDGW OMSPL.Flash
NCHECK 445
STNW 4
GLOBAL Texts.Scanner
LOCAL -160
GLOBAL Texts.Scan
CALL 2
JUMP L281
LABEL L283
CONST 6
STGW OMSPL.res
LABEL L281
!     IF (res = noerr) & (S.class = Texts.Int) THEN RAMLimit := RAMOrigin + S.i; RAMAllocPtr := RAMOrigin; Texts.Scan(S) ELSE res := nopar END;
LINE 446
LDGW OMSPL.res
JNEQZ L286
LDLW -120
CONST 3
JNEQ L286
LDLQ -116
CONST 512
CONVNQ
QPLUS
CONVQN
STGW OMSPL.RAMLimit
CONST 512
STGW OMSPL.RAMAllocPtr
GLOBAL Texts.Scanner
LOCAL -160
GLOBAL Texts.Scan
CALL 2
JUMP L284
LABEL L286
CONST 6
STGW OMSPL.res
LABEL L284
!     IF (res = noerr) & (S.class = Texts.Name) THEN nbmod := 0;
LINE 447
LDGW OMSPL.res
JNEQZ L290
LDLW -120
CONST 1
JNEQ L290
CONST 0
STLW -2256
LABEL L291
!       REPEAT FOR i := 0 TO LEN(S.s)-1 DO modlist[nbmod][i] := S.s[i] END;
LINE 448
CONST 0
STLW -4
LABEL L293
LDLW -4
CONST 31
JGT L294
LOCAL -96
LDLW -4
CONST 32
BOUND 448
LDIC
LOCAL -2252
LDLW -2256
CONST 64
BOUND 448
CONST 32
TIMES
LDLW -4
CONST 32
BOUND 448
PLUS
STIC
INCL -4
JUMP L293
LABEL L294
!         INC(nbmod); Texts.Scan(S)
LINE 449
INCL -2256
GLOBAL Texts.Scanner
LOCAL -160
GLOBAL Texts.Scan
CALL 2
!       UNTIL S.class # Texts.Name;
LINE 450
LDLW -120
CONST 1
JEQ L291
!       maps := NIL; mi := 0; REPEAT Mark(modlist[mi], MM); INC(mi) UNTIL (mi >= nbmod) OR (res # noerr);
LINE 451
CONST 0
STGW OMSPL.maps
CONST 0
STLW -2260
LABEL L295
LOCAL -172
CONST 32
LOCAL -2252
LDLW -2260
CONST 64
BOUND 451
CONST 32
TIMES
OFFSET
GLOBAL OMSPL.Mark
CALL 3
INCL -2260
LDLW -2260
LDLW -2256
JGEQ L296
LDGW OMSPL.res
JEQZ L295
LABEL L296
!       NEW(MT); Texts.Open(MT, ""); Texts.OpenWriter(MW);
LINE 452
CONST 24
GLOBAL Texts.TextDesc
GLOBAL NEW
CALLW 2
STLW -44
CONST 1
GLOBAL OMSPL.%5
LDLW -44
GLOBAL Texts.Open
CALL 3
GLOBAL Texts.Writer
LOCAL -64
GLOBAL Texts.OpenWriter
CALL 2
!       first := NIL; last := NIL; mi := 0; REPEAT LinkOne(modlist[mi], M, sec, MW); INC(mi) UNTIL (mi >= nbmod) OR (res # noerr);
LINE 453
CONST 0
STGW OMSPL.first
CONST 0
STGW OMSPL.last
CONST 0
STLW -2260
LABEL L298
GLOBAL Texts.Writer
LOCAL -64
CONST 512
LOCAL -24788
LOCAL -164
CONST 32
LOCAL -2252
LDLW -2260
CONST 64
BOUND 453
CONST 32
TIMES
OFFSET
GLOBAL OMSPL.LinkOne
CALL 7
INCL -2260
LDLW -2260
LDLW -2256
JGEQ L299
LDGW OMSPL.res
JEQZ L298
LABEL L299
!       Texts.Append(MT, MW.buf);
LINE 454
LDLW -64
LDLW -44
GLOBAL Texts.Append
CALL 2
!       IF res = noerr THEN Texts.WriteString(W, "  linking");
LINE 455
LDGW OMSPL.res
JNEQZ L303
CONST 10
GLOBAL OMSPL.%6
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
!         (*prolog*) padFlash; vector[31] := Flash.origin + Flash.allocPtr; p := first;
LINE 456
GLOBAL OMSPL.padFlash
CALL 0
LDGW OMSPL.Flash
NCHECK 456
LOADW
LDGW OMSPL.Flash
NCHECK 456
LDNW 4
PLUS
GLOBAL OMSPL.vector
STNW 124
LDGW OMSPL.first
STLW -168
!         (*MOV RAMLimit, SP*) EmitWord(4031H); EmitWord(RAMLimit);
LINE 457
CONST 16433
GLOBAL OMSPL.EmitWord
CALL 1
LDGW OMSPL.RAMLimit
GLOBAL OMSPL.EmitWord
CALL 1
LABEL L304
!         WHILE p # NIL DO (*fixup*) Texts.Write(W, " "); Texts.WriteString(W, p.name);
LINE 458
LDLW -168
JEQZ L303
CONST 32
ALIGNC
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.Write
CALL 3
CONST 32
LDLW -168
NCHECK 458
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
!           IF p.codeseg = 1 THEN (*module executed from RAM*) Texts.Write(W, "*");
LINE 459
LDLW -168
NCHECK 459
CONST 316
LDIC
CONST 1
JNEQ L309
CONST 42
ALIGNC
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.Write
CALL 3
!             (*MOV p.flashsize DIV 2,R15*) EmitWord(403FH); EmitWord(p.flashsize DIV 2);
LINE 461
CONST 16447
GLOBAL OMSPL.EmitWord
CALL 1
LDLW -168
NCHECK 461
LDNW 56
CONST 2
DIV
GLOBAL OMSPL.EmitWord
CALL 1
!             (*MOV Flash.origin + p.flashsto,R14*) EmitWord(403EH);  EmitWord(Flash.origin + p.flashsto);
LINE 462
CONST 16446
GLOBAL OMSPL.EmitWord
CALL 1
LDGW OMSPL.Flash
NCHECK 462
LOADW
LDLW -168
NCHECK 462
LDNW 48
PLUS
GLOBAL OMSPL.EmitWord
CALL 1
!             (*MOV @R14+,p.codeexe - (Flash.origin + p.flashsto)(R14) - 2*) EmitWord(4EBEH); EmitWord(p.codeexe - Flash.origin - p.flashsto - 2);
LINE 463
CONST 20158
GLOBAL OMSPL.EmitWord
CALL 1
LDLW -168
NCHECK 463
LDNW 52
LDGW OMSPL.Flash
NCHECK 463
LOADW
MINUS
LDLW -168
NCHECK 463
LDNW 48
MINUS
CONST 2
MINUS
GLOBAL OMSPL.EmitWord
CALL 1
!             (*SUB #1,R15*) EmitWord(831FH);
LINE 464
CONST 33567
GLOBAL OMSPL.EmitWord
CALL 1
!             (*JNE $-8*) EmitWord(23FCH)
LINE 465
CONST 9212
GLOBAL OMSPL.EmitWord
CALL 1
LABEL L309
!           INC(count); IF count MOD 8 = 0 THEN count := 0; Texts.WriteLn(W) END;
LINE 467
INCL -20
LDLW -20
CONST 8
MOD
JNEQZ L312
CONST 0
STLW -20
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteLn
CALL 2
LABEL L312
!           IF p.ent[0] >= 0 THEN (*init code present: CALL p.ent[0]*); EmitWord(12B0H); EmitWord(p.ent[0]) END;
LINE 468
LDLW -168
NCHECK 468
LDNW 60
JLTZ L315
CONST 4784
GLOBAL OMSPL.EmitWord
CALL 1
LDLW -168
NCHECK 468
LDNW 60
GLOBAL OMSPL.EmitWord
CALL 1
LABEL L315
!           p := p.next
LINE 469
LDLW -168
NCHECK 469
LDNW 32
STLW -168
JUMP L304
LABEL L303
!       IF (res = noerr) & (M.ent[0] < 0) THEN error(noinit, M.name) END;
LINE 472
LDGW OMSPL.res
JNEQZ L318
LDLW -164
NCHECK 472
LDNW 60
JGEQZ L318
CONST 32
LDLW -164
NCHECK 472
CONST 7
GLOBAL OMSPL.error
CALL 3
LABEL L318
!       IF res = noerr THEN
LINE 473
LDGW OMSPL.res
JNEQZ L337
!         MakeFileName(name, S.s, ".txt"); F := Files.New(name); Files.Set(R, F, 0);
LINE 474
CONST 5
GLOBAL OMSPL.%7
CONST 32
LOCAL -96
CONST 32
LOCAL -204
GLOBAL OMSPL.MakeFileName
CALL 6
CONST 32
LOCAL -204
GLOBAL POFiles.New
CALLW 2
STLW -28
CONST 0
LDLW -28
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL POFiles.Set
CALL 4
!         i := 32 - vecsize DIV 2; isrtrap := -1; (*install default ISR trap if required*)
LINE 475
CONST 32
LDLW -12
CONST 2
DIV
MINUS
STLW -4
CONST -1
STLW -16
LABEL L338
!           IF vector[i] = 0FFFFH THEN (*isrtrap is needed*) isrtrap := Flash.origin + Flash.allocPtr;
LINE 477
GLOBAL OMSPL.vector
LDLW -4
CONST 32
BOUND 477
LDIW
CONST 65535
JNEQ L343
LDGW OMSPL.Flash
NCHECK 477
LOADW
LDGW OMSPL.Flash
NCHECK 477
LDNW 4
PLUS
STLW -16
!             EmitWord(0D032H); EmitWord( 0010H); EmitWord(3FFDH) END;
LINE 478
CONST 53298
GLOBAL OMSPL.EmitWord
CALL 1
CONST 16
GLOBAL OMSPL.EmitWord
CALL 1
CONST 16381
GLOBAL OMSPL.EmitWord
CALL 1
LABEL L343
!           INC(i)
LINE 479
INCL -4
!         UNTIL (i >= 31) OR (isrtrap > 0);
LINE 480
LDLW -4
CONST 31
JGEQ L339
LDLW -16
JLEQZ L338
LABEL L339
!         i := 0; Files.Write(R, "@"); FilesEx.WriteHexHalfWord(R, Flash.origin); FilesEx.WriteLn(R); (*code*)
LINE 482
CONST 0
STLW -4
CONST 64
ALIGNC
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL POFiles.Write
CALL 3
LDGW OMSPL.Flash
NCHECK 482
LOADW
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL FilesEx.WriteHexHalfWord
CALL 3
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL FilesEx.WriteLn
CALL 2
LABEL L344
!         WHILE i < Flash.allocPtr DO
LINE 483
LDLW -4
LDGW OMSPL.Flash
NCHECK 483
LDNW 4
JGEQ L346
!           FilesEx.WriteHex(R, Flash.m[i]); Files.Write(R, " "); INC(i);
LINE 484
LDGW OMSPL.Flash
NCHECK 484
CONST 8
OFFSET
LDLW -4
CONST 65536
BOUND 484
OFFSET
LOADC
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL FilesEx.WriteHex
CALL 3
CONST 32
ALIGNC
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL POFiles.Write
CALL 3
INCL -4
!           IF i MOD 16 = 0 THEN FilesEx.WriteLn(R) END
LINE 485
LDLW -4
CONST 16
MOD
JNEQZ L344
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL FilesEx.WriteLn
CALL 2
JUMP L344
LABEL L346
!         IF i MOD 16 # 0 THEN FilesEx.WriteLn(R) END;
LINE 487
LDLW -4
CONST 16
MOD
JEQZ L352
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL FilesEx.WriteLn
CALL 2
LABEL L352
!         i := 0; x := 32 - vecsize DIV 2; Files.Write(R, "@"); FilesEx.WriteHexHalfWord(R, FlashEnd - vecsize); FilesEx.WriteLn(R); (*vector table*)
LINE 488
CONST 0
STLW -4
CONST 32
LDLW -12
CONST 2
DIV
MINUS
STLW -8
CONST 64
ALIGNC
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL POFiles.Write
CALL 3
CONST 65536
LDLW -12
MINUS
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL FilesEx.WriteHexHalfWord
CALL 3
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL FilesEx.WriteLn
CALL 2
LABEL L353
!         WHILE x < 32 DO IF vector[x] = 0FFFFH THEN vector[x] := isrtrap END;
LINE 489
LDLW -8
CONST 32
JGEQ L355
GLOBAL OMSPL.vector
LDLW -8
CONST 32
BOUND 489
LDIW
CONST 65535
JNEQ L358
LDLW -16
GLOBAL OMSPL.vector
LDLW -8
CONST 32
BOUND 489
STIW
LABEL L358
!           FilesEx.WriteHex(R, vector[x] MOD 100H); Files.Write(R, " ");
LINE 490
GLOBAL OMSPL.vector
LDLW -8
CONST 32
BOUND 490
LDIW
CONST 256
MOD
CONVNC
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL FilesEx.WriteHex
CALL 3
CONST 32
ALIGNC
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL POFiles.Write
CALL 3
!           FilesEx.WriteHex(R, vector[x] DIV 100H MOD 100H); Files.Write(R, " ");
LINE 491
GLOBAL OMSPL.vector
LDLW -8
CONST 32
BOUND 491
LDIW
CONST 256
DIV
CONST 256
MOD
CONVNC
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL FilesEx.WriteHex
CALL 3
CONST 32
ALIGNC
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL POFiles.Write
CALL 3
!           INC(i,2); IF i MOD 16 = 0 THEN FilesEx.WriteLn(R) END;
LINE 492
LDLW -4
CONST 2
PLUS
STLW -4
LDLW -4
CONST 16
MOD
JNEQZ L361
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL FilesEx.WriteLn
CALL 2
LABEL L361
!           INC(x)
LINE 493
INCL -8
JUMP L353
LABEL L355
!         IF i MOD 16 # 0 THEN FilesEx.WriteLn(R) END;
LINE 495
LDLW -4
CONST 16
MOD
JEQZ L364
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL FilesEx.WriteLn
CALL 2
LABEL L364
!         Files.Write(R, "q"); FilesEx.WriteLn(R);
LINE 496
CONST 113
ALIGNC
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL POFiles.Write
CALL 3
GLOBAL POFiles.Rider
LOCAL -40
GLOBAL FilesEx.WriteLn
CALL 2
!         Files.Register(F);
LINE 497
LDLW -28
GLOBAL POFiles.Register
CALL 1
!         IF count MOD 8 # 0 THEN count := 0; Texts.WriteLn(W) END;
LINE 498
LDLW -20
CONST 8
MOD
JEQZ L367
CONST 0
STLW -20
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteLn
CALL 2
LABEL L367
!         Texts.WriteString(W, "    flash"); Texts.WriteInt(W, Flash.allocPtr, 5);
LINE 499
CONST 10
GLOBAL OMSPL.%8
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
CONST 5
LDGW OMSPL.Flash
NCHECK 499
LDNW 4
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteInt
CALL 4
!         Texts.WriteString(W, ", data"); Texts.WriteInt(W, RAMAllocPtr - RAMOrigin, 5);
LINE 500
CONST 7
GLOBAL OMSPL.%9
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
CONST 5
LDGW OMSPL.RAMAllocPtr
CONST 512
MINUS
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteInt
CALL 4
!         Texts.WriteString(W, ", stack"); Texts.WriteInt(W, RAMLimit - RAMAllocPtr, 5);
LINE 501
CONST 8
GLOBAL OMSPL.%10
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
CONST 5
LDGW OMSPL.RAMLimit
LDGW OMSPL.RAMAllocPtr
MINUS
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteInt
CALL 4
!         Texts.WriteString(W, " bytes")
LINE 502
CONST 7
GLOBAL OMSPL.%11
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
JUMP L320
LABEL L337
!       ELSE  Texts.WriteLn(W); oldcol := W.col; W.col := Display.red;
LINE 503
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteLn
CALL 2
GLOBAL OMSPL.W
LDNW 4
STLW -24
CONST 224
GLOBAL OMSPL.W
STNW 4
!         Texts.WriteString(W, "Link error:  "); Texts.WriteString(W, importing);
LINE 504
CONST 14
GLOBAL OMSPL.%12
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
CONST 32
GLOBAL OMSPL.importing
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
!         IF res = nofile THEN Texts.WriteString(W, " module not found")
LINE 505
LDGW OMSPL.res
CONST 1
JNEQ L323
CONST 18
GLOBAL OMSPL.%13
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
JUMP L335
LABEL L323
!         ELSIF res = duphandler THEN Texts.WriteString(W, " duplicate interrupt handler")
LINE 506
LDGW OMSPL.res
CONST 2
JNEQ L325
CONST 29
GLOBAL OMSPL.%14
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
JUMP L335
LABEL L325
!         ELSIF res = badkey THEN Texts.WriteString(W, " imports ");
LINE 507
LDGW OMSPL.res
CONST 3
JNEQ L327
CONST 10
GLOBAL OMSPL.%15
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
!           Texts.WriteString(W, imported); Texts.WriteString(W, " with bad key")
LINE 508
CONST 32
GLOBAL OMSPL.imported
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
CONST 14
GLOBAL OMSPL.%16
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
JUMP L335
LABEL L327
!         ELSIF res = badfile THEN Texts.WriteString(W, " corrupted obj file")
LINE 509
LDGW OMSPL.res
CONST 4
JNEQ L329
CONST 20
GLOBAL OMSPL.%17
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
JUMP L335
LABEL L329
!         ELSIF res = nospace THEN Texts.WriteString(W, " insufficient space")
LINE 510
LDGW OMSPL.res
CONST 5
JNEQ L331
CONST 20
GLOBAL OMSPL.%18
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
JUMP L335
LABEL L331
!         ELSIF res = noinit THEN Texts.WriteString(W, " top module init code missing")
LINE 511
LDGW OMSPL.res
CONST 7
JNEQ L333
CONST 30
GLOBAL OMSPL.%19
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
JUMP L335
LABEL L333
!         ELSIF res = notsupported THEN Texts.WriteString(W, " version not supported")
LINE 512
LDGW OMSPL.res
CONST 8
JNEQ L335
CONST 23
GLOBAL OMSPL.%20
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
LABEL L335
!         END; W.col := oldcol
LINE 513
LDLW -24
GLOBAL OMSPL.W
STNW 4
LABEL L320
!       MakeFileName(name, S.s, ".map"); Texts.Close(MT, name)
LINE 515
CONST 5
GLOBAL OMSPL.%21
CONST 32
LOCAL -96
CONST 32
LOCAL -204
GLOBAL OMSPL.MakeFileName
CALL 6
CONST 32
LOCAL -204
LDLW -44
GLOBAL Texts.Close
CALL 3
JUMP L288
LABEL L290
!     ELSE Texts.WriteString(W, "Usage: OMSPL.Link VectorTableSize FlashSize RAMSize [module...] topmodule")
LINE 516
CONST 74
GLOBAL OMSPL.%22
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
LABEL L288
!     Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf);
LINE 518
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteLn
CALL 2
LDGW OMSPL.W
LDGW Oberon.Log
GLOBAL Texts.Append
CALL 2
!     first := NIL; last := NIL; maps := NIL
LINE 519
CONST 0
STGW OMSPL.first
CONST 0
STGW OMSPL.last
CONST 0
STGW OMSPL.maps
RETURN
END

PROC OMSPL.%main 0 5 0
! BEGIN Texts.OpenWriter(W); Texts.WriteString(W, "OMSP linker  AP 6.8.20 / CS 26.10.25");
LINE 522
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.OpenWriter
CALL 2
CONST 37
GLOBAL OMSPL.%23
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteString
CALL 4
!   Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf);
LINE 523
GLOBAL Texts.Writer
GLOBAL OMSPL.W
GLOBAL Texts.WriteLn
CALL 2
LDGW OMSPL.W
LDGW Oberon.Log
GLOBAL Texts.Append
CALL 2
RETURN
END

! Global variables
GLOVAR OMSPL.first 4
GLOVAR OMSPL.last 4
GLOVAR OMSPL.maps 4
GLOVAR OMSPL.RAMAllocPtr 4
GLOVAR OMSPL.RAMLimit 4
GLOVAR OMSPL.limit 4
GLOVAR OMSPL.res 4
GLOVAR OMSPL.Flash 4
GLOVAR OMSPL.vector 128
GLOVAR OMSPL.importing 32
GLOVAR OMSPL.imported 32
GLOVAR OMSPL.W 20

! Global pointer map
DEFINE OMSPL.%gcmap
WORD GC_POINTER
WORD OMSPL.first
WORD GC_POINTER
WORD OMSPL.last
WORD GC_POINTER
WORD OMSPL.maps
WORD GC_POINTER
WORD OMSPL.Flash
WORD GC_BASE
WORD OMSPL.W
WORD 0x00000023
WORD GC_END

! String ".mpc"
DEFINE OMSPL.%1
STRING 2E6D706300

! String "Module "
DEFINE OMSPL.%2
STRING 4D6F64756C652000

! String "codeexe"
DEFINE OMSPL.%3
STRING 636F646565786500

! String "interrupt vector number"
DEFINE OMSPL.%4
STRING 696E7465727275707420766563746F72206E756D62657200

! String ""
DEFINE OMSPL.%5
STRING 00

! String "  linking"
DEFINE OMSPL.%6
STRING 20206C696E6B696E6700

! String ".txt"
DEFINE OMSPL.%7
STRING 2E74787400

! String "    flash"
DEFINE OMSPL.%8
STRING 20202020666C61736800

! String ", data"
DEFINE OMSPL.%9
STRING 2C206461746100

! String ", stack"
DEFINE OMSPL.%10
STRING 2C20737461636B00

! String " bytes"
DEFINE OMSPL.%11
STRING 20627974657300

! String "Link error:  "
DEFINE OMSPL.%12
STRING 4C696E6B206572726F723A202000

! String " module not found"
DEFINE OMSPL.%13
STRING 206D6F64756C65206E6F7420666F756E6400

! String " duplicate interrupt handler"
DEFINE OMSPL.%14
STRING 206475706C696361746520696E746572727570742068616E646C657200

! String " imports "
DEFINE OMSPL.%15
STRING 20696D706F7274732000

! String " with bad key"
DEFINE OMSPL.%16
STRING 207769746820626164206B657900

! String " corrupted obj file"
DEFINE OMSPL.%17
STRING 20636F72727570746564206F626A2066696C6500

! String " insufficient space"
DEFINE OMSPL.%18
STRING 20696E73756666696369656E7420737061636500

! String " top module init code missing"
DEFINE OMSPL.%19
STRING 20746F70206D6F64756C6520696E697420636F6465206D697373696E6700

! String " version not supported"
DEFINE OMSPL.%20
STRING 2076657273696F6E206E6F7420737570706F7274656400

! String ".map"
DEFINE OMSPL.%21
STRING 2E6D617000

! String "Usage: OMSPL.Link VectorTableSize FlashSize RAMSize [module...] topmodule"
DEFINE OMSPL.%22
STRING 55736167653A204F4D53504C2E4C696E6B20566563746F725461626C6553697A
STRING 6520466C61736853697A652052414D53697A65205B6D6F64756C652E2E2E5D20
STRING 746F706D6F64756C6500

! String "OMSP linker  AP 6.8.20 / CS 26.10.25"
DEFINE OMSPL.%23
STRING 4F4D5350206C696E6B65722020415020362E382E3230202F2043532032362E31
STRING 302E323500

! Descriptor for ModDesc
DEFINE OMSPL.ModDesc
WORD 0x00000201
WORD 0
WORD OMSPL.ModDesc.%anc

DEFINE OMSPL.ModDesc.%anc
WORD OMSPL.ModDesc

! Descriptor for SegmentDesc
DEFINE OMSPL.SegmentDesc
WORD 0
WORD 0
WORD OMSPL.SegmentDesc.%anc

DEFINE OMSPL.SegmentDesc.%anc
WORD OMSPL.SegmentDesc

! Descriptor for Section
DEFINE OMSPL.Section
WORD 0
WORD 0
WORD OMSPL.Section.%anc

DEFINE OMSPL.Section.%anc
WORD OMSPL.Section

! Descriptor for DependDesc
DEFINE OMSPL.DependDesc
WORD 0x00000009
WORD 0
WORD OMSPL.DependDesc.%anc

DEFINE OMSPL.DependDesc.%anc
WORD OMSPL.DependDesc

! Descriptor for SecDepDesc
DEFINE OMSPL.SecDepDesc
WORD 0x0000000d
WORD 0
WORD OMSPL.SecDepDesc.%anc

DEFINE OMSPL.SecDepDesc.%anc
WORD OMSPL.SecDepDesc

! Descriptor for ModMapsDesc
DEFINE OMSPL.ModMapsDesc
WORD 0x07fffe01
WORD 0
WORD OMSPL.ModMapsDesc.%anc

DEFINE OMSPL.ModMapsDesc.%anc
WORD OMSPL.ModMapsDesc

! Pointer maps
DEFINE OMSPL.LinkOne.%map
WORD 12
WORD 20
WORD 24
WORD 32
WORD -4
WORD -8
WORD -88
WORD -92
WORD GC_BLOCK
WORD -164
WORD 16
WORD -308
WORD GC_END

DEFINE OMSPL.Mark.%map
WORD 12
WORD 20
WORD -4
WORD -8
WORD -12
WORD -72
WORD -76
WORD GC_END

DEFINE OMSPL.Link.%map
WORD -28
WORD -32
WORD -44
WORD -64
WORD -48
WORD -152
WORD -132
WORD -164
WORD -168
WORD -172
WORD GC_END

! End of file
