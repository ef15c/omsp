!! (SYMFILE #OMSPD 0x00030300 #OMSPD.%main 1 #OMSPD.Mod)
!! (GLOBAL #mnemo1 #OMSPD.mnemo1 !1 (ARRAY 8 !2 (ARRAY 3 CHAR)))
!! (GLOBAL #mnemo2 #OMSPD.mnemo2 !3 (ARRAY 7 !4 (ARRAY 5 CHAR)))
!! (GLOBAL #mnemo3 #OMSPD.mnemo3 !5 (ARRAY 12 !6 (ARRAY 5 CHAR)))
!! (DEF ?7 #Texts 17 #Writer (RECORD #Texts.Writer 20 VOID
!!     (FIELD #buf* 0 ?8 #Texts 15 #Buffer (POINTER))
!!     (FIELD #col* 4 INTEGER)
!!     (FIELD #rider 8 ?9 #POFiles 6 #Rider (RECORD #POFiles.Rider 12 VOID
!!         (FIELD #eof* 0 BOOLEAN)
!!         (FIELD #res* 4 INTEGER)
!!         (FIELD #base 8 ?10 #POFiles 1 #File (POINTER))))))
!! (PROCEDURE #WriteReg* 10 #OMSPD.WriteReg !11 (PROC 3 VOID
!!     (VPARAM #W 12 =7)
!!     (PARAM #r 20 BYTE)))
!! (TARGET =10 ?12 #POFiles 2 #FileDesc (RECORD #POFiles.FileDesc 68 VOID
!!     (FIELD #file 0 ?13 #Files 1 #File (POINTER))
!!     (FIELD #tmpName 4 ?14 #POFiles 4 ANON (ARRAY 32 CHAR))
!!     (FIELD #name 36 =14)))
!! (TARGET =13 ?15 #Files 2 #FileDesc (RECORD #Files.FileDesc 8 VOID
!!     (FIELD #file- 0 SYSTEM.LONGPTR)))
!! (TARGET =8 ?16 #Texts 16 #BufDesc (RECORD #Texts.BufDesc 12 VOID
!!     (FIELD #len* 0 INTEGER)
!!     (FIELD #header 4 ?17 #Texts 1 #Piece (POINTER))
!!     (FIELD #last 8 =17)))
!! (TARGET =17 ?18 #Texts 2 #PieceDesc (RECORD #Texts.PieceDesc 24 VOID
!!     (FIELD #f 0 =10)
!!     (FIELD #off 4 INTEGER)
!!     (FIELD #len 8 INTEGER)
!!     (FIELD #col 12 INTEGER)
!!     (FIELD #prev 16 =17)
!!     (FIELD #next 20 =17)))
!! (PROCEDURE #WritePCOffset 20 #OMSPD.WritePCOffset !19 (PROC 4 VOID
!!     (VPARAM #W 12 =7)
!!     (PARAM #at 20 INTEGER)
!!     (PARAM #ofs 24 INTEGER))
!!   (LOCAL #ofsb -4 INTEGER))
!! (PROCEDURE #WordToInt 29 #OMSPD.WordToInt !20 (PROC 1 INTEGER
!!     (PARAM #x 12 INTEGER)))
!! (PROCEDURE #isConstant 34 #OMSPD.isConstant !21 (PROC 3 BOOLEAN
!!     (PARAM #op 12 SET)
!!     (PARAM #src 16 BYTE)
!!     (VPARAM #c 20 INTEGER))
!!   (LOCAL #res -1 BOOLEAN))
!! (DEF !22 (FLEX BYTE))
!! (PROCEDURE #WriteSD 53 #OMSPD.WriteSD !23 (PROC 7 VOID
!!     (VPARAM #W 12 =7)
!!     (VPARAM #c 20 =22)
!!     (VPARAM #i 28 INTEGER)
!!     (PARAM #op 32 SET)
!!     (PARAM #reg 36 BYTE))
!!   (LOCAL #ct -4 INTEGER))
!! (DEF !24 (FLEX BYTE))
!! (PROCEDURE #WriteD 71 #OMSPD.WriteD !25 (PROC 6 VOID
!!     (VPARAM #W 12 =7)
!!     (VPARAM #c 20 =24)
!!     (VPARAM #i 28 INTEGER)
!!     (PARAM #op 32 SET))
!!   (LOCAL #ct -4 INTEGER)
!!   (LOCAL #reg -5 BYTE))
!! (PROCEDURE #WriteSize 82 #OMSPD.WriteSize !26 (PROC 3 VOID
!!     (VPARAM #W 12 =7)
!!     (PARAM #op 20 SET)))
!! (DEF !27 (FLEX BYTE))
!! (PROCEDURE #opcode* 86 #OMSPD.opcode !28 (PROC 6 VOID
!!     (VPARAM #W 12 =7)
!!     (VPARAM #c 20 =27)
!!     (VPARAM #i 28 INTEGER)
!!     (PARAM #base 32 INTEGER))
!!   (CONST #SOMSK SET 64512)
!!   (CONST #SO SET 4096)
!!   (CONST #JMPMSK SET 57344)
!!   (CONST #JMP SET 8192)
!!   (LOCAL #b1 -1 BYTE)
!!   (LOCAL #b2 -2 BYTE)
!!   (LOCAL #t -3 BYTE)
!!   (LOCAL #op -8 SET))
!! (CHKSUM 0x66c3fc6a)
!! 
MODULE OMSPD 0x66c3fc6a 131
IMPORT Texts 0x2d7a25ad
IMPORT TextsEx 0x5b129e9d
IMPORT OMSPA 0x66d26050
ENDHDR

PROC OMSPD.WriteReg 0 5 0x00100001
!   PROCEDURE WriteReg*(VAR W: Texts.Writer; r: BYTE);
LINE 10
!     IF r = 0 THEN Texts.WriteString(W, "PC")
LINE 12
LDLC 20
JNEQZ L46
CONST 3
GLOBAL OMSPD.%1
LDLW 16
LDLW 12
GLOBAL Texts.WriteString
CALL 4
RETURN
LABEL L46
!     ELSIF r = 1 THEN Texts.WriteString(W, "SP")
LINE 13
LDLC 20
CONST 1
JNEQ L48
CONST 3
GLOBAL OMSPD.%2
LDLW 16
LDLW 12
GLOBAL Texts.WriteString
CALL 4
RETURN
LABEL L48
!     ELSIF r = 2 THEN Texts.WriteString(W, "SR")
LINE 14
LDLC 20
CONST 2
JNEQ L50
CONST 3
GLOBAL OMSPD.%3
LDLW 16
LDLW 12
GLOBAL Texts.WriteString
CALL 4
RETURN
LABEL L50
!     ELSIF r = 3 THEN Texts.WriteString(W, "CG2")
LINE 15
LDLC 20
CONST 3
JNEQ L52
CONST 4
GLOBAL OMSPD.%4
LDLW 16
LDLW 12
GLOBAL Texts.WriteString
CALL 4
RETURN
LABEL L52
!     ELSE Texts.WriteString(W, "R"); Texts.WriteInt(W, r MOD 10H, 1)
LINE 16
CONST 2
GLOBAL OMSPD.%37
LDLW 16
LDLW 12
GLOBAL Texts.WriteString
CALL 4
CONST 1
LDLC 20
CONST 16
MOD
LDLW 16
LDLW 12
GLOBAL Texts.WriteInt
CALL 4
RETURN
END

PROC OMSPD.WritePCOffset 4 6 0x00100001
!   PROCEDURE WritePCOffset(VAR W: Texts.Writer; at, ofs: INTEGER);
LINE 20
!   BEGIN IF ofs >= 200H THEN DEC(ofs, 400H) END; ofs := 2*ofs; ofsb := ofs + 2;
LINE 22
LDLW 24
CONST 512
JLT L55
LDLW 24
CONST 1024
MINUS
STLW 24
LABEL L55
LDLW 24
CONST 2
TIMES
STLW 24
LDLW 24
CONST 2
PLUS
STLW -4
!     Texts.WriteString(W, " $");
LINE 23
CONST 3
GLOBAL OMSPD.%5
LDLW 16
LDLW 12
GLOBAL Texts.WriteString
CALL 4
!     IF ofsb > 0 THEN Texts.Write(W, "+") END;
LINE 24
LDLW -4
JLEQZ L58
CONST 43
ALIGNC
LDLW 16
LDLW 12
GLOBAL Texts.Write
CALL 3
LABEL L58
!     IF ofsb # 0 THEN Texts.WriteInt(W, ofsb, 1) END;
LINE 25
LDLW -4
JEQZ L61
CONST 1
LDLW -4
LDLW 16
LDLW 12
GLOBAL Texts.WriteInt
CALL 4
LABEL L61
!     Texts.WriteString(W, ", goes to "); TextsEx.WriteHexVLen(W, at + ofs, 4, FALSE);
LINE 26
CONST 11
GLOBAL OMSPD.%6
LDLW 16
LDLW 12
GLOBAL Texts.WriteString
CALL 4
CONST 0
ALIGNC
CONST 4
LDLW 20
LDLW 24
PLUS
LDLW 16
LDLW 12
GLOBAL TextsEx.WriteHexVLen
CALL 5
RETURN
END

PROC OMSPD.WordToInt 0 3 0
!   PROCEDURE WordToInt(x : INTEGER): INTEGER;
LINE 29
!   BEGIN IF x >= 8000H THEN DEC(x, 10000H) END
LINE 30
LDLW 12
CONST 32768
JLT L64
LDLW 12
CONST 65536
MINUS
STLW 12
LABEL L64
!     RETURN x
LINE 31
LDLW 12
RETURN
END

PROC OMSPD.isConstant 4 3 0x00400001
!   PROCEDURE isConstant(op: SET; src: BYTE; VAR c: INTEGER): BOOLEAN;
LINE 34
!   BEGIN res := FALSE;
LINE 36
CONST 0
STLC -1
!     IF src = A.CG1 THEN
LINE 37
LDLC 16
CONST 2
JNEQ L67
!       IF op*A.IRAm = A.IRm THEN res := TRUE; c := 4
LINE 38
LDLW 12
CONST 48
BITAND
CONST 32
JNEQ L70
CONST 1
STLC -1
CONST 4
LDLW 20
STOREW
JUMP L85
LABEL L70
!       ELSIF op*A.IRAm = A.IRAm THEN res := TRUE; c := 8
LINE 39
LDLW 12
CONST 48
BITAND
CONST 48
JNEQ L85
CONST 1
STLC -1
CONST 8
LDLW 20
STOREW
JUMP L85
LABEL L67
!     ELSIF src = A.CG2 THEN res := TRUE;
LINE 41
LDLC 16
CONST 3
JNEQ L74
CONST 1
STLC -1
!       IF op*A.IRAm = A.Rm THEN c := 0
LINE 42
LDLW 12
CONST 48
BITAND
JNEQZ L77
CONST 0
LDLW 20
STOREW
JUMP L85
LABEL L77
!       ELSIF op*A.IRAm = A.Im THEN c := 1
LINE 43
LDLW 12
CONST 48
BITAND
CONST 16
JNEQ L79
CONST 1
LDLW 20
STOREW
JUMP L85
LABEL L79
!       ELSIF op*A.IRAm = A.IRm THEN c := 2
LINE 44
LDLW 12
CONST 48
BITAND
CONST 32
JNEQ L81
CONST 2
LDLW 20
STOREW
JUMP L85
LABEL L81
!       ELSIF op*A.IRAm = A.IRAm THEN c := -1
LINE 45
LDLW 12
CONST 48
BITAND
CONST 48
JNEQ L85
CONST -1
LDLW 20
STOREW
JUMP L85
LABEL L74
!     ELSIF c >= 8000H THEN DEC(c, 10000H)
LINE 47
LDLW 20
LOADW
CONST 32768
JLT L85
LDLW 20
DUP 0
LOADW
CONST 65536
MINUS
SWAP
STOREW
LABEL L85
!     RETURN res
LINE 50
LDLC -1
RETURN
END

PROC OMSPD.WriteSD 4 5 0x01500001
!   PROCEDURE WriteSD(VAR W: Texts.Writer; VAR c: ARRAY OF BYTE; VAR i: INTEGER; op: SET; reg: BYTE);
LINE 53
!     IF isConstant(op, reg, ct) THEN Texts.Write(W, "#"); Texts.WriteInt(W, ct, 1)
LINE 56
LOCAL -4
LDLC 36
LDLW 32
GLOBAL OMSPD.isConstant
CALLW 3
JEQZ L96
CONST 35
ALIGNC
LDLW 16
LDLW 12
GLOBAL Texts.Write
CALL 3
CONST 1
LDLW -4
LDLW 16
LDLW 12
GLOBAL Texts.WriteInt
CALL 4
RETURN
LABEL L96
!     ELSIF (op*A.IRAm = A.IRAm) & (reg = A.PC) THEN (*immediate*)
LINE 57
LDLW 32
CONST 48
BITAND
CONST 48
JNEQ L98
LDLC 36
JNEQZ L98
!       ct := c[i+1]*100H + c[i]; INC(i, 2); Texts.Write(W, "#"); Texts.WriteInt(W, WordToInt(ct), 1)
LINE 58
LDLW 20
LDLW 28
LOADW
INC
LDLW 24
BOUND 58
OFFSET
LOADC
CONST 256
TIMES
LDLW 20
LDLW 28
LOADW
LDLW 24
BOUND 58
OFFSET
LOADC
PLUS
STLW -4
LDLW 28
DUP 0
LOADW
CONST 2
PLUS
SWAP
STOREW
CONST 35
ALIGNC
LDLW 16
LDLW 12
GLOBAL Texts.Write
CALL 3
CONST 1
LDLW -4
GLOBAL OMSPD.WordToInt
CALLW 1
LDLW 16
LDLW 12
GLOBAL Texts.WriteInt
CALL 4
RETURN
LABEL L98
!     ELSIF (op*A.IRAm = A.Im) & (reg = A.SR) THEN (*absolute*)
LINE 59
LDLW 32
CONST 48
BITAND
CONST 16
JNEQ L101
LDLC 36
CONST 2
JNEQ L101
!       ct := c[i+1]*100H + c[i]; INC(i, 2); Texts.Write(W, "&"); Texts.WriteInt(W, ct, 1)
LINE 60
LDLW 20
LDLW 28
LOADW
INC
LDLW 24
BOUND 60
OFFSET
LOADC
CONST 256
TIMES
LDLW 20
LDLW 28
LOADW
LDLW 24
BOUND 60
OFFSET
LOADC
PLUS
STLW -4
LDLW 28
DUP 0
LOADW
CONST 2
PLUS
SWAP
STOREW
CONST 38
ALIGNC
LDLW 16
LDLW 12
GLOBAL Texts.Write
CALL 3
CONST 1
LDLW -4
LDLW 16
LDLW 12
GLOBAL Texts.WriteInt
CALL 4
RETURN
LABEL L101
!       IF op*A.IRm = A.IRm THEN (*indirect*) Texts.WriteString(W, "@");
LINE 62
LDLW 32
CONST 32
BITAND
CONST 32
JNEQ L89
CONST 2
GLOBAL OMSPD.%38
LDLW 16
LDLW 12
GLOBAL Texts.WriteString
CALL 4
!         WriteReg(W, reg); IF op*A.IRAm = A.IRAm THEN (*auto increment*) Texts.WriteString(W, "+") END
LINE 63
LDLC 36
LDLW 16
LDLW 12
GLOBAL OMSPD.WriteReg
CALL 3
LDLW 32
CONST 48
BITAND
CONST 48
JNEQ L87
CONST 2
GLOBAL OMSPD.%39
LDLW 16
LDLW 12
GLOBAL Texts.WriteString
CALL 4
RETURN
LABEL L89
!       ELSIF op*A.Im = A.Im THEN (*indexed*) ct := c[i+1]*100H + c[i]; INC(i, 2);
LINE 64
LDLW 32
CONST 16
BITAND
CONST 16
JNEQ L94
LDLW 20
LDLW 28
LOADW
INC
LDLW 24
BOUND 64
OFFSET
LOADC
CONST 256
TIMES
LDLW 20
LDLW 28
LOADW
LDLW 24
BOUND 64
OFFSET
LOADC
PLUS
STLW -4
LDLW 28
DUP 0
LOADW
CONST 2
PLUS
SWAP
STOREW
!         Texts.WriteInt(W, WordToInt(ct), 1); Texts.Write(W, "("); WriteReg(W, reg); Texts.Write(W, ")")
LINE 65
CONST 1
LDLW -4
GLOBAL OMSPD.WordToInt
CALLW 1
LDLW 16
LDLW 12
GLOBAL Texts.WriteInt
CALL 4
CONST 40
ALIGNC
LDLW 16
LDLW 12
GLOBAL Texts.Write
CALL 3
LDLC 36
LDLW 16
LDLW 12
GLOBAL OMSPD.WriteReg
CALL 3
CONST 41
ALIGNC
LDLW 16
LDLW 12
GLOBAL Texts.Write
CALL 3
RETURN
LABEL L94
!       ELSE WriteReg(W, reg)
LINE 66
LDLC 36
LDLW 16
LDLW 12
GLOBAL OMSPD.WriteReg
CALL 3
LABEL L87
RETURN
END

PROC OMSPD.WriteD 8 5 0x01500001
!   PROCEDURE WriteD(VAR W: Texts.Writer; VAR c: ARRAY OF BYTE; VAR i: INTEGER; op: SET);
LINE 71
!   BEGIN reg := ORD(op) MOD 10H;
LINE 73
LDLW 32
CONST 16
MOD
CONVNC
STLC -5
!     IF op*A.Idm = A.Idm THEN (*indexed*) ct := c[i+1]*100H + c[i]; INC(i, 2);
LINE 74
LDLW 32
CONST 128
BITAND
CONST 128
JNEQ L105
LDLW 20
LDLW 28
LOADW
INC
LDLW 24
BOUND 74
OFFSET
LOADC
CONST 256
TIMES
LDLW 20
LDLW 28
LOADW
LDLW 24
BOUND 74
OFFSET
LOADC
PLUS
STLW -4
LDLW 28
DUP 0
LOADW
CONST 2
PLUS
SWAP
STOREW
!       IF reg = A.SR THEN (*absolute*) Texts.Write(W, "&"); Texts.WriteInt(W, ct, 1)
LINE 75
LDLC -5
CONST 2
JNEQ L108
CONST 38
ALIGNC
LDLW 16
LDLW 12
GLOBAL Texts.Write
CALL 3
CONST 1
LDLW -4
LDLW 16
LDLW 12
GLOBAL Texts.WriteInt
CALL 4
RETURN
LABEL L108
!       ELSE Texts.WriteInt(W, WordToInt(ct), 1); Texts.Write(W, "("); WriteReg(W, reg); Texts.Write(W, ")")
LINE 76
CONST 1
LDLW -4
GLOBAL OMSPD.WordToInt
CALLW 1
LDLW 16
LDLW 12
GLOBAL Texts.WriteInt
CALL 4
CONST 40
ALIGNC
LDLW 16
LDLW 12
GLOBAL Texts.Write
CALL 3
LDLC -5
LDLW 16
LDLW 12
GLOBAL OMSPD.WriteReg
CALL 3
CONST 41
ALIGNC
LDLW 16
LDLW 12
GLOBAL Texts.Write
CALL 3
RETURN
LABEL L105
!     ELSE WriteReg(W, reg)
LINE 78
LDLC -5
LDLW 16
LDLW 12
GLOBAL OMSPD.WriteReg
CALL 3
RETURN
END

PROC OMSPD.WriteSize 0 5 0x00100001
!   PROCEDURE WriteSize(VAR W: Texts.Writer; op: SET);
LINE 82
!   BEGIN IF op*A.Byte = A.Byte THEN Texts.WriteString(W, ".B") END
LINE 83
LDLW 20
CONST 64
BITAND
CONST 64
JNEQ L111
CONST 3
GLOBAL OMSPD.%7
LDLW 16
LDLW 12
GLOBAL Texts.WriteString
CALL 4
LABEL L111
RETURN
END

PROC OMSPD.opcode 8 8 0x01500001
!   PROCEDURE opcode*(VAR W: Texts.Writer; VAR c: ARRAY OF BYTE; VAR i: INTEGER; base: INTEGER);
LINE 86
!   BEGIN b1 := c[i+1]; b2 := c[i]; INC(i, 2);
LINE 93
LDLW 20
LDLW 28
LOADW
INC
LDLW 24
BOUND 93
OFFSET
LOADC
STLC -1
LDLW 20
LDLW 28
LOADW
LDLW 24
BOUND 93
OFFSET
LOADC
STLC -2
LDLW 28
DUP 0
LOADW
CONST 2
PLUS
SWAP
STOREW
!     op := SYSTEM.VAL(SET, 0+b2+100H*b1);
LINE 94
LDLC -2
LDLC -1
CONST 256
TIMES
PLUS
STLW -8
!     Texts.WriteString(W, "    "); TextsEx.WriteHexVLen(W, ORD(op), 4, FALSE); Texts.Write(W, 9X);
LINE 95
CONST 5
GLOBAL OMSPD.%8
LDLW 16
LDLW 12
GLOBAL Texts.WriteString
CALL 4
CONST 0
ALIGNC
CONST 4
LDLW -8
LDLW 16
LDLW 12
GLOBAL TextsEx.WriteHexVLen
CALL 5
CONST 9
ALIGNC
LDLW 16
LDLW 12
GLOBAL Texts.Write
CALL 3
!     IF SYSTEM.VAL(INTEGER, op) = 4130H THEN Texts.WriteString(W, "RET")
LINE 96
LDLW -8
CONST 16688
JNEQ L122
CONST 4
GLOBAL OMSPD.%9
LDLW 16
LDLW 12
GLOBAL Texts.WriteString
CALL 4
RETURN
LABEL L122
!     ELSIF SYSTEM.VAL(INTEGER, op) = 4303H THEN Texts.WriteString(W, "NOP")
LINE 97
LDLW -8
CONST 17155
JNEQ L124
CONST 4
GLOBAL OMSPD.%10
LDLW 16
LDLW 12
GLOBAL Texts.WriteString
CALL 4
RETURN
LABEL L124
!     ELSIF op*SOMSK = SO THEN (*Single-operand (Format II) instructions*)
LINE 98
LDLW -8
CONST 64512
BITAND
CONST 4096
JNEQ L126
!       t := LSR(SYSTEM.VAL(INTEGER, op), 7) MOD 8; Texts.WriteString(W, mnemo2[t]);
LINE 99
LDLW -8
CONST 7
LSR
CONST 8
MOD
CONVNC
STLC -3
CONST 5
GLOBAL OMSPD.mnemo2
LDLC -3
CONST 7
BOUND 99
CONST 5
TIMES
OFFSET
LDLW 16
LDLW 12
GLOBAL Texts.WriteString
CALL 4
!       IF t # 6 THEN
LINE 100
LDLC -3
CONST 6
JEQ L113
!         IF t IN {0, 2, 4} THEN WriteSize(W, op) END; Texts.Write(W, " ");
LINE 101
CONST 1
LDLC -3
CONST 32
BOUND 101
LSL
CONST 21
BITAND
JEQZ L132
LDLW -8
LDLW 16
LDLW 12
GLOBAL OMSPD.WriteSize
CALL 3
LABEL L132
CONST 32
ALIGNC
LDLW 16
LDLW 12
GLOBAL Texts.Write
CALL 3
!         WriteSD(W, c, i, op, b2 MOD 10H)
LINE 102
LDLC -2
CONST 16
MOD
LDLW -8
LDLW 28
LDLW 24
LDLW 20
LDLW 16
LDLW 12
GLOBAL OMSPD.WriteSD
CALL 7
RETURN
LABEL L126
!     ELSIF op*JMPMSK = JMP THEN Texts.WriteString(W, "J"); Texts.WriteString(W, mnemo1[LSR(b1, 2) MOD 8]);
LINE 104
LDLW -8
CONST 57344
BITAND
CONST 8192
JNEQ L134
CONST 2
GLOBAL OMSPD.%40
LDLW 16
LDLW 12
GLOBAL Texts.WriteString
CALL 4
CONST 3
GLOBAL OMSPD.mnemo1
LDLC -1
CONST 2
LSR
CONST 8
MOD
CONST 8
BOUND 104
CONST 3
TIMES
OFFSET
LDLW 16
LDLW 12
GLOBAL Texts.WriteString
CALL 4
!       WritePCOffset(W, i + base, b1 MOD 4*100H + b2)
LINE 105
LDLC -1
CONST 4
MOD
CONST 256
TIMES
LDLC -2
PLUS
LDLW 28
LOADW
LDLW 32
PLUS
LDLW 16
LDLW 12
GLOBAL OMSPD.WritePCOffset
CALL 4
RETURN
LABEL L134
!     ELSE t := b1 DIV 10H;
LINE 106
LDLC -1
CONST 16
DIV
STLC -3
!       IF t  IN {4..15} THEN (*Double-operand (format I) instructions*)
LINE 107
CONST 1
LDLC -3
CONST 32
BOUND 107
LSL
CONST 65520
BITAND
JEQZ L115
!         IF (t = A.MOV) & (b1 MOD 10H = A.SP) & (op*A.IRAm = A.IRAm) THEN (*POP*)
LINE 108
LDLC -3
CONST 4
JNEQ L118
LDLC -1
CONST 16
MOD
CONST 1
JNEQ L118
LDLW -8
CONST 48
BITAND
CONST 48
JNEQ L118
!           Texts.WriteString(W, "POP"); WriteSize(W, op); Texts.Write(W, " ");
LINE 109
CONST 4
GLOBAL OMSPD.%11
LDLW 16
LDLW 12
GLOBAL Texts.WriteString
CALL 4
LDLW -8
LDLW 16
LDLW 12
GLOBAL OMSPD.WriteSize
CALL 3
CONST 32
ALIGNC
LDLW 16
LDLW 12
GLOBAL Texts.Write
CALL 3
!           WriteD(W, c, i, op)
LINE 110
LDLW -8
LDLW 28
LDLW 24
LDLW 20
LDLW 16
LDLW 12
GLOBAL OMSPD.WriteD
CALL 6
RETURN
LABEL L118
!           DEC(t, 4); Texts.WriteString(W, mnemo3[t]); WriteSize(W, op); Texts.Write(W, " ");
LINE 112
LDLC -3
CONST 4
MINUS
STLC -3
CONST 5
GLOBAL OMSPD.mnemo3
LDLC -3
CONST 12
BOUND 112
CONST 5
TIMES
OFFSET
LDLW 16
LDLW 12
GLOBAL Texts.WriteString
CALL 4
LDLW -8
LDLW 16
LDLW 12
GLOBAL OMSPD.WriteSize
CALL 3
CONST 32
ALIGNC
LDLW 16
LDLW 12
GLOBAL Texts.Write
CALL 3
!           WriteSD(W, c, i, op, b1 MOD 10H); Texts.Write(W, ",");
LINE 113
LDLC -1
CONST 16
MOD
LDLW -8
LDLW 28
LDLW 24
LDLW 20
LDLW 16
LDLW 12
GLOBAL OMSPD.WriteSD
CALL 7
CONST 44
ALIGNC
LDLW 16
LDLW 12
GLOBAL Texts.Write
CALL 3
!           WriteD(W, c, i, op)
LINE 114
LDLW -8
LDLW 28
LDLW 24
LDLW 20
LDLW 16
LDLW 12
GLOBAL OMSPD.WriteD
CALL 6
RETURN
LABEL L115
!       ELSE Texts.WriteString(W, "TODO other format")
LINE 116
CONST 18
GLOBAL OMSPD.%12
LDLW 16
LDLW 12
GLOBAL Texts.WriteString
CALL 4
LABEL L113
RETURN
END

PROC OMSPD.%main 0 5 0
!   mnemo1[A.NE] := "NE"; mnemo1[A.EQ] := "EQ"; mnemo1[A.NC] := "NC"; mnemo1[A.C] := "C";
LINE 122
CONST 3
GLOBAL OMSPD.mnemo1
CONST 3
GLOBAL OMSPD.%13
GLOBAL COPY
CALL 4
CONST 3
GLOBAL OMSPD.mnemo1
CONST 3
OFFSET
CONST 3
GLOBAL OMSPD.%14
GLOBAL COPY
CALL 4
CONST 3
GLOBAL OMSPD.mnemo1
CONST 6
OFFSET
CONST 3
GLOBAL OMSPD.%15
GLOBAL COPY
CALL 4
CONST 3
GLOBAL OMSPD.mnemo1
CONST 9
OFFSET
CONST 2
GLOBAL OMSPD.%41
GLOBAL COPY
CALL 4
!   mnemo1[A.N] := "N"; mnemo1[A.GE] := "GE"; mnemo1[A.L] := "L"; mnemo1[A.AL] := "MP";
LINE 123
CONST 3
GLOBAL OMSPD.mnemo1
CONST 12
OFFSET
CONST 2
GLOBAL OMSPD.%42
GLOBAL COPY
CALL 4
CONST 3
GLOBAL OMSPD.mnemo1
CONST 15
OFFSET
CONST 3
GLOBAL OMSPD.%16
GLOBAL COPY
CALL 4
CONST 3
GLOBAL OMSPD.mnemo1
CONST 18
OFFSET
CONST 2
GLOBAL OMSPD.%43
GLOBAL COPY
CALL 4
CONST 3
GLOBAL OMSPD.mnemo1
CONST 21
OFFSET
CONST 3
GLOBAL OMSPD.%17
GLOBAL COPY
CALL 4
!   mnemo2[0] := "RRC"; mnemo2[1] := "SWPB"; mnemo2[2] := "RRA"; mnemo2[3] := "SXT";
LINE 125
CONST 5
GLOBAL OMSPD.mnemo2
CONST 4
GLOBAL OMSPD.%18
GLOBAL COPY
CALL 4
CONST 5
GLOBAL OMSPD.mnemo2
CONST 5
OFFSET
CONST 5
GLOBAL OMSPD.%19
GLOBAL COPY
CALL 4
CONST 5
GLOBAL OMSPD.mnemo2
CONST 10
OFFSET
CONST 4
GLOBAL OMSPD.%20
GLOBAL COPY
CALL 4
CONST 5
GLOBAL OMSPD.mnemo2
CONST 15
OFFSET
CONST 4
GLOBAL OMSPD.%21
GLOBAL COPY
CALL 4
!   mnemo2[4] := "PUSH"; mnemo2[5] := "CALL"; mnemo2[6] := "RETI";
LINE 126
CONST 5
GLOBAL OMSPD.mnemo2
CONST 20
OFFSET
CONST 5
GLOBAL OMSPD.%22
GLOBAL COPY
CALL 4
CONST 5
GLOBAL OMSPD.mnemo2
CONST 25
OFFSET
CONST 5
GLOBAL OMSPD.%23
GLOBAL COPY
CALL 4
CONST 5
GLOBAL OMSPD.mnemo2
CONST 30
OFFSET
CONST 5
GLOBAL OMSPD.%24
GLOBAL COPY
CALL 4
!   mnemo3[0] := "MOV"; mnemo3[1] := "ADD"; mnemo3[2] := "ADDC"; mnemo3[3] := "SUBC";
LINE 128
CONST 5
GLOBAL OMSPD.mnemo3
CONST 4
GLOBAL OMSPD.%25
GLOBAL COPY
CALL 4
CONST 5
GLOBAL OMSPD.mnemo3
CONST 5
OFFSET
CONST 4
GLOBAL OMSPD.%26
GLOBAL COPY
CALL 4
CONST 5
GLOBAL OMSPD.mnemo3
CONST 10
OFFSET
CONST 5
GLOBAL OMSPD.%27
GLOBAL COPY
CALL 4
CONST 5
GLOBAL OMSPD.mnemo3
CONST 15
OFFSET
CONST 5
GLOBAL OMSPD.%28
GLOBAL COPY
CALL 4
!   mnemo3[4] := "SUB"; mnemo3[5] := "CMP"; mnemo3[6] := "DADD"; mnemo3[7] := "BIT";
LINE 129
CONST 5
GLOBAL OMSPD.mnemo3
CONST 20
OFFSET
CONST 4
GLOBAL OMSPD.%29
GLOBAL COPY
CALL 4
CONST 5
GLOBAL OMSPD.mnemo3
CONST 25
OFFSET
CONST 4
GLOBAL OMSPD.%30
GLOBAL COPY
CALL 4
CONST 5
GLOBAL OMSPD.mnemo3
CONST 30
OFFSET
CONST 5
GLOBAL OMSPD.%31
GLOBAL COPY
CALL 4
CONST 5
GLOBAL OMSPD.mnemo3
CONST 35
OFFSET
CONST 4
GLOBAL OMSPD.%32
GLOBAL COPY
CALL 4
!   mnemo3[8] := "BIC"; mnemo3[9] := "BIS"; mnemo3[10] := "XOR"; mnemo3[11] := "AND";
LINE 130
CONST 5
GLOBAL OMSPD.mnemo3
CONST 40
OFFSET
CONST 4
GLOBAL OMSPD.%33
GLOBAL COPY
CALL 4
CONST 5
GLOBAL OMSPD.mnemo3
CONST 45
OFFSET
CONST 4
GLOBAL OMSPD.%34
GLOBAL COPY
CALL 4
CONST 5
GLOBAL OMSPD.mnemo3
CONST 50
OFFSET
CONST 4
GLOBAL OMSPD.%35
GLOBAL COPY
CALL 4
CONST 5
GLOBAL OMSPD.mnemo3
CONST 55
OFFSET
CONST 4
GLOBAL OMSPD.%36
GLOBAL COPY
CALL 4
RETURN
END

! Global variables
GLOVAR OMSPD.mnemo1 24
GLOVAR OMSPD.mnemo2 35
GLOVAR OMSPD.mnemo3 60

! String "PC"
DEFINE OMSPD.%1
STRING 504300

! String "SP"
DEFINE OMSPD.%2
STRING 535000

! String "SR"
DEFINE OMSPD.%3
STRING 535200

! String "CG2"
DEFINE OMSPD.%4
STRING 43473200

! String " $"
DEFINE OMSPD.%5
STRING 202400

! String ", goes to "
DEFINE OMSPD.%6
STRING 2C20676F657320746F2000

! String ".B"
DEFINE OMSPD.%7
STRING 2E4200

! String "    "
DEFINE OMSPD.%8
STRING 2020202000

! String "RET"
DEFINE OMSPD.%9
STRING 52455400

! String "NOP"
DEFINE OMSPD.%10
STRING 4E4F5000

! String "POP"
DEFINE OMSPD.%11
STRING 504F5000

! String "TODO other format"
DEFINE OMSPD.%12
STRING 544F444F206F7468657220666F726D617400

! String "NE"
DEFINE OMSPD.%13
STRING 4E4500

! String "EQ"
DEFINE OMSPD.%14
STRING 455100

! String "NC"
DEFINE OMSPD.%15
STRING 4E4300

! String "GE"
DEFINE OMSPD.%16
STRING 474500

! String "MP"
DEFINE OMSPD.%17
STRING 4D5000

! String "RRC"
DEFINE OMSPD.%18
STRING 52524300

! String "SWPB"
DEFINE OMSPD.%19
STRING 5357504200

! String "RRA"
DEFINE OMSPD.%20
STRING 52524100

! String "SXT"
DEFINE OMSPD.%21
STRING 53585400

! String "PUSH"
DEFINE OMSPD.%22
STRING 5055534800

! String "CALL"
DEFINE OMSPD.%23
STRING 43414C4C00

! String "RETI"
DEFINE OMSPD.%24
STRING 5245544900

! String "MOV"
DEFINE OMSPD.%25
STRING 4D4F5600

! String "ADD"
DEFINE OMSPD.%26
STRING 41444400

! String "ADDC"
DEFINE OMSPD.%27
STRING 4144444300

! String "SUBC"
DEFINE OMSPD.%28
STRING 5355424300

! String "SUB"
DEFINE OMSPD.%29
STRING 53554200

! String "CMP"
DEFINE OMSPD.%30
STRING 434D5000

! String "DADD"
DEFINE OMSPD.%31
STRING 4441444400

! String "BIT"
DEFINE OMSPD.%32
STRING 42495400

! String "BIC"
DEFINE OMSPD.%33
STRING 42494300

! String "BIS"
DEFINE OMSPD.%34
STRING 42495300

! String "XOR"
DEFINE OMSPD.%35
STRING 584F5200

! String "AND"
DEFINE OMSPD.%36
STRING 414E4400

! String "R"
DEFINE OMSPD.%37
STRING 5200

! String "@"
DEFINE OMSPD.%38
STRING 4000

! String "+"
DEFINE OMSPD.%39
STRING 2B00

! String "J"
DEFINE OMSPD.%40
STRING 4A00

! String "C"
DEFINE OMSPD.%41
STRING 4300

! String "N"
DEFINE OMSPD.%42
STRING 4E00

! String "L"
DEFINE OMSPD.%43
STRING 4C00

! End of file
