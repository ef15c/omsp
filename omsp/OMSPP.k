!! (SYMFILE #OMSPP 0x00030300 #OMSPP.%main 1 #OMSPP.Mod)
!! (TYPE #PtrBase !1 (POINTER))
!! (TARGET =1 !2 (RECORD #OMSPP.PtrBaseDesc 40 VOID
!!     (FIELD #name 0 ?3 #OMSPS 1 #Ident (ARRAY 32 CHAR))
!!     (FIELD #type 32 ?4 #OMSPB 3 #Type (POINTER))
!!     (FIELD #next 36 =1)))
!! (TARGET =4 ?5 #OMSPB 5 #TypeDesc (RECORD #OMSPB.TypeDesc 44 VOID
!!     (FIELD #form* 0 INTEGER)
!!     (FIELD #ref* 4 INTEGER)
!!     (FIELD #mno* 8 INTEGER)
!!     (FIELD #nofpar* 12 INTEGER)
!!     (FIELD #len* 16 INTEGER)
!!     (FIELD #dsc* 20 ?6 #OMSPB 1 #Object (POINTER))
!!     (FIELD #typobj* 24 =6)
!!     (FIELD #base* 28 =4)
!!     (FIELD #size* 32 INTEGER)
!!     (FIELD #leaf* 36 BOOLEAN)
!!     (FIELD #ur* 40 SET)))
!! (TARGET =6 ?7 #OMSPB 2 #ObjDesc (RECORD #OMSPB.ObjDesc 64 VOID
!!     (FIELD #class* 0 BYTE)
!!     (FIELD #exno* 1 BYTE)
!!     (FIELD #register* 2 BYTE)
!!     (FIELD #expo* 3 BOOLEAN)
!!     (FIELD #unsafe* 4 BOOLEAN)
!!     (FIELD #rdo* 5 BOOLEAN)
!!     (FIELD #lev* 8 INTEGER)
!!     (FIELD #usedat* 12 INTEGER)
!!     (FIELD #next* 16 =6)
!!     (FIELD #dsc* 20 =6)
!!     (FIELD #type* 24 =4)
!!     (FIELD #name* 28 =3)
!!     (FIELD #val* 60 INTEGER)))
!! (TYPE #PtrBaseDesc =2)
!! (GLOBAL #sym #OMSPP.sym INTEGER)
!! (GLOBAL #dc #OMSPP.dc INTEGER)
!! (GLOBAL #level #OMSPP.level INTEGER)
!! (GLOBAL #exno #OMSPP.exno INTEGER)
!! (GLOBAL #newSF #OMSPP.newSF BOOLEAN)
!! (GLOBAL #initmode #OMSPP.initmode BOOLEAN)
!! (DEF ?8 #OMSPG 2 #Item (RECORD #OMSPG.Item 36 ?9 #OMSPA 4 #Item (RECORD #OMSPA.Item 8 VOID
!!       (FIELD #reg* 0 BYTE)
!!       (FIELD #am* 1 BYTE)
!!       (FIELD #ofs* 4 INTEGER))
!!     (FIELD #reg* 0 BYTE)
!!     (FIELD #am* 1 BYTE)
!!     (FIELD #ofs* 4 INTEGER)
!!     (FIELD #mode* 8 INTEGER)
!!     (FIELD #type* 12 =4)
!!     (FIELD #obj* 16 =6)
!!     (FIELD #a* 20 INTEGER)
!!     (FIELD #b* 24 INTEGER)
!!     (FIELD #c* 28 INTEGER)
!!     (FIELD #rdo* 32 BOOLEAN)
!!     (FIELD #tmp 33 BOOLEAN)))
!! (GLOBAL #expression #OMSPP.expression !10 (PROC 2 VOID
!!     (VPARAM #x 12 =8)))
!! (GLOBAL #Type #OMSPP.Type !11 (PROC 1 VOID
!!     (VPARAM #type 12 =4)))
!! (GLOBAL #FormalType #OMSPP.FormalType !12 (PROC 2 VOID
!!     (VPARAM #typ 12 =4)
!!     (PARAM #dim 16 INTEGER)))
!! (GLOBAL #modid #OMSPP.modid =3)
!! (GLOBAL #pbsList #OMSPP.pbsList =1)
!! (GLOBAL #dummy #OMSPP.dummy =6)
!! (GLOBAL #isLeaf #OMSPP.isLeaf BOOLEAN)
!! (GLOBAL #isInt #OMSPP.isInt BOOLEAN)
!! (GLOBAL #codeseg #OMSPP.codeseg BYTE)
!! (GLOBAL #W #OMSPP.W ?13 #Texts 17 #Writer (RECORD #Texts.Writer 20 VOID
!!     (FIELD #buf* 0 ?14 #Texts 15 #Buffer (POINTER))
!!     (FIELD #col* 4 INTEGER)
!!     (FIELD #rider 8 ?15 #POFiles 6 #Rider (RECORD #POFiles.Rider 12 VOID
!!         (FIELD #eof* 0 BOOLEAN)
!!         (FIELD #res* 4 INTEGER)
!!         (FIELD #base 8 ?16 #POFiles 1 #File (POINTER))))))
!! (TARGET =16 ?17 #POFiles 2 #FileDesc (RECORD #POFiles.FileDesc 68 VOID
!!     (FIELD #file 0 ?18 #Files 1 #File (POINTER))
!!     (FIELD #tmpName 4 ?19 #POFiles 4 ANON (ARRAY 32 CHAR))
!!     (FIELD #name 36 =19)))
!! (TARGET =18 ?20 #Files 2 #FileDesc (RECORD #Files.FileDesc 8 VOID
!!     (FIELD #file- 0 SYSTEM.LONGPTR)))
!! (TARGET =14 ?21 #Texts 16 #BufDesc (RECORD #Texts.BufDesc 12 VOID
!!     (FIELD #len* 0 INTEGER)
!!     (FIELD #header 4 ?22 #Texts 1 #Piece (POINTER))
!!     (FIELD #last 8 =22)))
!! (TARGET =22 ?23 #Texts 2 #PieceDesc (RECORD #Texts.PieceDesc 24 VOID
!!     (FIELD #f 0 =16)
!!     (FIELD #off 4 INTEGER)
!!     (FIELD #len 8 INTEGER)
!!     (FIELD #col 12 INTEGER)
!!     (FIELD #prev 16 =22)
!!     (FIELD #next 20 =22)))
!! (DEF !24 (FLEX CHAR))
!! (PROCEDURE #Check 29 #OMSPP.Check !25 (PROC 3 VOID
!!     (PARAM #s 12 INTEGER)
!!     (CPARAM #msg 16 =24)))
!! (PROCEDURE #qualident 34 #OMSPP.qualident !26 (PROC 1 VOID
!!     (VPARAM #obj 12 =6)))
!! (PROCEDURE #CheckBool 46 #OMSPP.CheckBool !27 (PROC 2 VOID
!!     (VPARAM #x 12 =8)))
!! (PROCEDURE #CheckInt 51 #OMSPP.CheckInt !28 (PROC 2 VOID
!!     (VPARAM #x 12 =8)))
!! (PROCEDURE #CheckSet 56 #OMSPP.CheckSet !29 (PROC 2 VOID
!!     (VPARAM #x 12 =8)))
!! (PROCEDURE #CheckSetVal 61 #OMSPP.CheckSetVal !30 (PROC 2 VOID
!!     (VPARAM #x 12 =8)))
!! (PROCEDURE #CheckConst 69 #OMSPP.CheckConst !31 (PROC 2 VOID
!!     (VPARAM #x 12 =8)))
!! (PROCEDURE #CheckReadOnly 74 #OMSPP.CheckReadOnly !32 (PROC 2 VOID
!!     (VPARAM #x 12 =8)))
!! (PROCEDURE #CheckExport 79 #OMSPP.CheckExport !33 (PROC 1 VOID
!!     (VPARAM #expo 12 BOOLEAN)))
!! (PROCEDURE #CheckUnsafeMarking 88 #OMSPP.CheckUnsafeMarking !34 (PROC 1 VOID
!!     (VPARAM #unsafe 12 BOOLEAN)))
!! (PROCEDURE #IsExtension 97 #OMSPP.IsExtension !35 (PROC 2 BOOLEAN
!!     (PARAM #t0 12 =4)
!!     (PARAM #t1 16 =4)))
!! (PROCEDURE #TypeTest 103 #OMSPP.TypeTest !36 (PROC 4 VOID
!!     (VPARAM #x 12 =8)
!!     (PARAM #T 20 =4)
!!     (PARAM #guard 24 BOOLEAN))
!!   (LOCAL #xt -4 =4))
!! (PROCEDURE #StandFunc 126 #OMSPP.StandFunc !37 (PROC 4 VOID
!!     (VPARAM #x 12 =8)
!!     (PARAM #fct 20 INTEGER)
!!     (PARAM #restyp 24 =4))
!!   (LOCAL #y -36 =8)
!!   (LOCAL #z -72 =8)
!!   (LOCAL #n -76 INTEGER)
!!   (LOCAL #npar -80 INTEGER))
!! (PROCEDURE #selector 173 #OMSPP.selector !38 (PROC 2 VOID
!!     (VPARAM #x 12 =8))
!!   (LOCAL #y -36 =8)
!!   (LOCAL #obj -40 =6))
!! (PROCEDURE #EqualSignatures 218 #OMSPP.EqualSignatures !39 (PROC 2 BOOLEAN
!!     (PARAM #t0 12 =4)
!!     (PARAM #t1 16 =4))
!!   (LOCAL #p0 -4 =6)
!!   (LOCAL #p1 -8 =6)
!!   (LOCAL #com -9 BOOLEAN)
!!   (LOCAL #i -16 INTEGER)
!!   (LOCAL #dr -20 SET)
!!   (LOCAL #first -21 BOOLEAN))
!! (PROCEDURE #CompTypes 246 #OMSPP.CompTypes !40 (PROC 3 BOOLEAN
!!     (PARAM #t0 12 =4)
!!     (PARAM #t1 16 =4)
!!     (PARAM #varpar 20 BOOLEAN)))
!! (PROCEDURE #Parameter 257 #OMSPP.Parameter !41 (PROC 1 VOID
!!     (PARAM #par 12 =6))
!!   (LOCAL #x -36 =8)
!!   (LOCAL #varpar -37 BOOLEAN))
!! (PROCEDURE #ParamList 287 #OMSPP.ParamList !42 (PROC 1 VOID
!!     (CPARAM #x 12 =8))
!!   (LOCAL #n -4 INTEGER)
!!   (LOCAL #par -8 =6))
!! (PROCEDURE #element 305 #OMSPP.element !43 (PROC 2 VOID
!!     (VPARAM #x 12 =8))
!!   (LOCAL #y -36 =8))
!! (PROCEDURE #set 314 #OMSPP.set !44 (PROC 2 VOID
!!     (VPARAM #x 12 =8))
!!   (LOCAL #y -36 =8))
!! (PROCEDURE #factor 330 #OMSPP.factor !45 (PROC 2 VOID
!!     (VPARAM #x 12 =8))
!!   (LOCAL #obj -4 =6)
!!   (LOCAL #rx -8 SET)
!!   (LOCAL #orx -12 SET)
!!   (LOCAL #pau -13 BOOLEAN))
!! (PROCEDURE #term 360 #OMSPP.term !46 (PROC 2 VOID
!!     (VPARAM #x 12 =8))
!!   (LOCAL #y -36 =8)
!!   (LOCAL #op -40 INTEGER)
!!   (LOCAL #f -44 INTEGER))
!! (PROCEDURE #SimpleExpression 381 #OMSPP.SimpleExpression !47 (PROC 2 VOID
!!     (VPARAM #x 12 =8))
!!   (LOCAL #y -36 =8)
!!   (LOCAL #op -40 INTEGER))
!! (PROCEDURE #expression0 400 #OMSPP.expression0 !48 (PROC 2 VOID
!!     (VPARAM #x 12 =8))
!!   (LOCAL #y -36 =8)
!!   (LOCAL #obj -40 =6)
!!   (LOCAL #rel -44 INTEGER)
!!   (LOCAL #xf -48 INTEGER)
!!   (LOCAL #yf -52 INTEGER))
!! (PROCEDURE #StandProc 445 #OMSPP.StandProc !49 (PROC 1 VOID
!!     (PARAM #pno 12 INTEGER))
!!   (LOCAL #nap -4 INTEGER)
!!   (LOCAL #npar -8 INTEGER)
!!   (LOCAL #x -44 =8)
!!   (LOCAL #y -80 =8)
!!   (LOCAL #z -116 =8))
!! (PROCEDURE #StatSequence 490 #OMSPP.StatSequence !50 (PROC 0 VOID)
!!   (LOCAL #obj -4 =6)
!!   (LOCAL #orgtype -8 =4)
!!   (LOCAL #x -44 =8)
!!   (LOCAL #y -80 =8)
!!   (LOCAL #z -116 =8)
!!   (LOCAL #w -152 =8)
!!   (LOCAL #L0 -156 INTEGER)
!!   (LOCAL #L1 -160 INTEGER)
!!   (LOCAL #rx -164 SET)
!!   (LOCAL #orx -168 SET)
!!   (LOCAL #pau -169 BOOLEAN)
!!   (PROCEDURE #TypeCase 496 #OMSPP.%119.TypeCase !51 (PROC 3 VOID
!!       (PARAM #obj 12 =6)
!!       (VPARAM #x 16 =8))
!!     (LOCAL #typobj -8 =6))
!!   (PROCEDURE #SkipCase 508 #OMSPP.%120.SkipCase !52 (PROC 0 VOID)))
!! (PROCEDURE #IdentList 632 #OMSPP.IdentList !53 (PROC 2 VOID
!!     (PARAM #class 12 INTEGER)
!!     (VPARAM #first 16 =6))
!!   (LOCAL #obj -4 =6))
!! (PROCEDURE #ArrayType 648 #OMSPP.ArrayType !54 (PROC 1 VOID
!!     (VPARAM #type 12 =4))
!!   (LOCAL #x -36 =8)
!!   (LOCAL #typ -40 =4)
!!   (LOCAL #len -44 INTEGER))
!! (PROCEDURE #RecordType 664 #OMSPP.RecordType !55 (PROC 1 VOID
!!     (VPARAM #type 12 =4))
!!   (LOCAL #obj -4 =6)
!!   (LOCAL #obj0 -8 =6)
!!   (LOCAL #new -12 =6)
!!   (LOCAL #bot -16 =6)
!!   (LOCAL #base -20 =6)
!!   (LOCAL #typ -24 =4)
!!   (LOCAL #tp -28 =4)
!!   (LOCAL #offset -32 INTEGER)
!!   (LOCAL #off -36 INTEGER)
!!   (LOCAL #n -40 INTEGER))
!! (PROCEDURE #FPSection 711 #OMSPP.FPSection !56 (PROC 3 VOID
!!     (VPARAM #adr 12 INTEGER)
!!     (VPARAM #nofpar 16 INTEGER)
!!     (VPARAM #inreg 20 BOOLEAN))
!!   (LOCAL #obj -4 =6)
!!   (LOCAL #first -8 =6)
!!   (LOCAL #tp -12 =4)
!!   (LOCAL #parsize -16 INTEGER)
!!   (LOCAL #dummy -20 INTEGER)
!!   (LOCAL #nbregs -24 INTEGER)
!!   (LOCAL #cl -28 INTEGER)
!!   (LOCAL #rdo -29 BOOLEAN))
!! (PROCEDURE #InsertResultRegister 735 #OMSPP.InsertResultRegister !57 (PROC 1 VOID
!!     (VPARAM #type 12 =4))
!!   (LOCAL #L -4 INTEGER)
!!   (LOCAL #dummy -8 INTEGER)
!!   (LOCAL #loc -12 =6)
!!   (LOCAL #x -48 =8)
!!   (LOCAL #tp -52 =4))
!! (PROCEDURE #ProcedureType 754 #OMSPP.ProcedureType !58 (PROC 2 VOID
!!     (PARAM #ptype 12 =4)
!!     (VPARAM #parblksize 16 INTEGER))
!!   (LOCAL #obj -4 =6)
!!   (LOCAL #size -8 INTEGER)
!!   (LOCAL #nofpar -12 INTEGER)
!!   (LOCAL #leaf -13 BOOLEAN)
!!   (LOCAL #inreg -14 BOOLEAN)
!!   (LOCAL #x -52 =8)
!!   (LOCAL #sr -88 =8))
!! (PROCEDURE #FormalType0 781 #OMSPP.FormalType0 !59 (PROC 2 VOID
!!     (VPARAM #typ 12 =4)
!!     (PARAM #dim 16 INTEGER))
!!   (LOCAL #obj -4 =6)
!!   (LOCAL #dmy -8 INTEGER))
!! (PROCEDURE #CheckRecLevel 800 #OMSPP.CheckRecLevel !60 (PROC 1 VOID
!!     (PARAM #lev 12 INTEGER)))
!! (PROCEDURE #Type0 805 #OMSPP.Type0 !61 (PROC 1 VOID
!!     (VPARAM #type 12 =4))
!!   (LOCAL #dmy -4 INTEGER)
!!   (LOCAL #obj -8 =6)
!!   (LOCAL #ptbase -12 =1))
!! (PROCEDURE #containsPointer 847 #OMSPP.containsPointer !62 (PROC 1 BOOLEAN
!!     (PARAM #type 12 =4))
!!   (LOCAL #obj -4 =6)
!!   (LOCAL #res -5 BOOLEAN))
!! (PROCEDURE #Declarations 863 #OMSPP.Declarations !63 (PROC 2 VOID
!!     (VPARAM #varsize 12 INTEGER)
!!     (VPARAM #haveinregs 16 BOOLEAN))
!!   (LOCAL #obj -4 =6)
!!   (LOCAL #first -8 =6)
!!   (LOCAL #x -44 =8)
!!   (LOCAL #tp -48 =4)
!!   (LOCAL #ptbase -52 =1)
!!   (LOCAL #expo -53 BOOLEAN)
!!   (LOCAL #unsafe -54 BOOLEAN)
!!   (LOCAL #umm -55 BOOLEAN)
!!   (LOCAL #umf -56 BOOLEAN)
!!   (LOCAL #inreg -57 BOOLEAN)
!!   (LOCAL #onetimeinit -58 BOOLEAN)
!!   (LOCAL #id -90 =3)
!!   (LOCAL #nbregs -96 INTEGER)
!!   (LOCAL #dummy -100 INTEGER))
!! (PROCEDURE #ProcedureDecl 957 #OMSPP.ProcedureDecl !64 (PROC 0 VOID)
!!   (LOCAL #proc -4 =6)
!!   (LOCAL #loc -8 =6)
!!   (LOCAL #type -12 =4)
!!   (LOCAL #procid -44 =3)
!!   (LOCAL #x -80 =8)
!!   (LOCAL #sr -116 =8)
!!   (LOCAL #locblksize -120 INTEGER)
!!   (LOCAL #parblksize -124 INTEGER)
!!   (LOCAL #L -128 INTEGER)
!!   (LOCAL #int -129 BOOLEAN)
!!   (LOCAL #haveinregs -130 BOOLEAN)
!!   (LOCAL #riu -136 SET)
!!   (LOCAL #savedregs -140 SET)
!!   (LOCAL #v -148 !65 (ARRAY 8 BYTE)))
!! (PROCEDURE #Import 1042 #OMSPP.Import !66 (PROC 0 VOID)
!!   (LOCAL #impid -32 =3)
!!   (LOCAL #impid1 -64 =3))
!! (PROCEDURE #Module 1059 #OMSPP.Module !67 (PROC 0 VOID)
!!   (LOCAL #key -4 INTEGER)
!!   (LOCAL #oldCol -8 INTEGER)
!!   (LOCAL #dmy -9 BOOLEAN))
!! (DEF ?68 #Texts 13 #Scanner (RECORD #Texts.Scanner 92 ?69 #Texts 11 #Reader (RECORD #Texts.Reader 32 VOID
!!       (FIELD #eot* 0 BOOLEAN)
!!       (FIELD #col* 4 INTEGER)
!!       (FIELD #ref 8 =22)
!!       (FIELD #org 12 INTEGER)
!!       (FIELD #off 16 INTEGER)
!!       (FIELD #rider 20 =15))
!!     (FIELD #eot* 0 BOOLEAN)
!!     (FIELD #col* 4 INTEGER)
!!     (FIELD #ref 8 =22)
!!     (FIELD #org 12 INTEGER)
!!     (FIELD #off 16 INTEGER)
!!     (FIELD #rider 20 =15)
!!     (FIELD #nextCh* 32 CHAR)
!!     (FIELD #line* 36 INTEGER)
!!     (FIELD #class* 40 INTEGER)
!!     (FIELD #i* 44 INTEGER)
!!     (FIELD #x* 48 REAL)
!!     (FIELD #c* 52 CHAR)
!!     (FIELD #len* 56 INTEGER)
!!     (FIELD #s* 60 ?70 #Texts 14 ANON (ARRAY 32 CHAR))))
!! (PROCEDURE #Option 1105 #OMSPP.Option !71 (PROC 2 VOID
!!     (VPARAM #S1 12 =68)))
!! (PROCEDURE #Compile* 1113 #OMSPP.Compile !72 (PROC 0 VOID)
!!   (LOCAL #beg -4 INTEGER)
!!   (LOCAL #end -8 INTEGER)
!!   (LOCAL #time -12 INTEGER)
!!   (LOCAL #T -16 ?73 #Texts 8 #Text (POINTER))
!!   (LOCAL #S1 -108 =68))
!! (TARGET =73 ?74 #Texts 9 #TextDesc (RECORD #Texts.TextDesc 24 VOID
!!     (FIELD #len* 0 INTEGER)
!!     (FIELD #changed* 4 BOOLEAN)
!!     (FIELD #notify* 8 ?75 #Texts 10 #Notifier (PROC 4 VOID
!!         (PARAM #T 12 =73)
!!         (PARAM #op 16 INTEGER)
!!         (PARAM #beg 20 INTEGER)
!!         (PARAM #end 24 INTEGER)))
!!     (FIELD #trailer 12 =22)
!!     (FIELD #pce 16 =22)
!!     (FIELD #org 20 INTEGER)))
!! (CHKSUM 0x56548206)
!! 
MODULE OMSPP 0x56548206 1152
IMPORT Display 0x6ac5a6ac
IMPORT Texts 0x2d7a25ad
IMPORT Oberon 0x7fd79012
IMPORT OMSPS 0x208dfe13
IMPORT OMSPB 0x5056bc71
IMPORT OMSPG 0x0f07326b
ENDHDR

PROC OMSPP.Check 0 3 0x00200001
!   PROCEDURE Check(s: INTEGER; msg: ARRAY OF CHAR);
LINE 29
!     IF sym = s THEN S.Get(sym) ELSE S.Mark(msg) END
LINE 31
LDGW OMSPP.sym
LDLW 12
JNEQ L123
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
RETURN
LABEL L123
LDLW 20
LDLW 16
GLOBAL OMSPS.Mark
CALL 2
RETURN
END

PROC OMSPP.qualident 0 3 0x00100001
!   PROCEDURE qualident(VAR obj: B.Object);
LINE 34
!   BEGIN obj := B.thisObj(); S.Get(sym);
LINE 35
GLOBAL OMSPB.thisObj
CALLW 0
LDLW 12
STOREW
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!     IF obj = NIL THEN S.Mark("undef"); obj := dummy END ;
LINE 36
LDLW 12
LOADW
JNEQZ L126
CONST 6
GLOBAL OMSPP.%1
GLOBAL OMSPS.Mark
CALL 2
LDGW OMSPP.dummy
LDLW 12
STOREW
LABEL L126
!     IF (sym = S.period) & (obj.class = B.Mod) THEN
LINE 37
LDGW OMSPP.sym
CONST 18
JNEQ L129
LDLW 12
LOADW
NCHECK 37
LOADC
CONST 8
JNEQ L129
!       S.Get(sym);
LINE 38
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!       IF sym = S.ident THEN obj := B.thisimport(obj); S.Get(sym);
LINE 39
LDGW OMSPP.sym
CONST 31
JNEQ L132
LDLW 12
LOADW
GLOBAL OMSPB.thisimport
CALLW 1
LDLW 12
STOREW
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!         IF obj = NIL THEN S.Mark("undef"); obj := dummy END
LINE 40
LDLW 12
LOADW
JNEQZ L129
CONST 6
GLOBAL OMSPP.%1
GLOBAL OMSPS.Mark
CALL 2
LDGW OMSPP.dummy
LDLW 12
STOREW
RETURN
LABEL L132
!       ELSE S.Mark("identifier expected"); obj := dummy
LINE 41
CONST 20
GLOBAL OMSPP.%2
GLOBAL OMSPS.Mark
CALL 2
LDGW OMSPP.dummy
LDLW 12
STOREW
LABEL L129
RETURN
END

PROC OMSPP.CheckBool 0 3 0x00100001
!   PROCEDURE CheckBool(VAR x: G.Item);
LINE 46
!     IF x.type.form # B.Bool THEN S.Mark("not Boolean"); x.type := B.boolType END
LINE 48
LDLW 12
LDNW 12
NCHECK 48
LOADW
CONST 2
JEQ L139
CONST 12
GLOBAL OMSPP.%3
GLOBAL OMSPS.Mark
CALL 2
LDGW OMSPB.boolType
LDLW 12
STNW 12
LABEL L139
RETURN
END

PROC OMSPP.CheckInt 0 3 0x00100001
!   PROCEDURE CheckInt(VAR x: G.Item);
LINE 51
!     IF x.type.form # B.Int THEN S.Mark("not Integer"); x.type := B.intType END
LINE 53
LDLW 12
LDNW 12
NCHECK 53
LOADW
CONST 4
JEQ L142
CONST 12
GLOBAL OMSPP.%4
GLOBAL OMSPS.Mark
CALL 2
LDGW OMSPB.intType
LDLW 12
STNW 12
LABEL L142
RETURN
END

PROC OMSPP.CheckSet 0 3 0x00100001
!   PROCEDURE CheckSet(VAR x: G.Item);
LINE 56
!     IF x.type.form # B.Set THEN S.Mark("not Set"); x.type := B.setType END 
LINE 58
LDLW 12
LDNW 12
NCHECK 58
LOADW
CONST 6
JEQ L145
CONST 8
GLOBAL OMSPP.%5
GLOBAL OMSPS.Mark
CALL 2
LDGW OMSPB.setType
LDLW 12
STNW 12
LABEL L145
RETURN
END

PROC OMSPP.CheckSetVal 0 3 0x00100001
!   PROCEDURE CheckSetVal(VAR x: G.Item);
LINE 61
!     IF x.type.form # B.Int THEN S.Mark("not Int"); x.type := B.setType
LINE 63
LDLW 12
LDNW 12
NCHECK 63
LOADW
CONST 4
JEQ L148
CONST 8
GLOBAL OMSPP.%6
GLOBAL OMSPS.Mark
CALL 2
LDGW OMSPB.setType
LDLW 12
STNW 12
RETURN
LABEL L148
!     ELSIF x.mode = B.Const THEN
LINE 64
LDLW 12
LDNW 8
CONST 1
JNEQ L150
!       IF (x.a < 0) OR (x.a >= 16) THEN S.Mark("invalid set") END
LINE 65
LDLW 12
LDNW 20
JLTZ L152
LDLW 12
LDNW 20
CONST 16
JLT L150
LABEL L152
CONST 12
GLOBAL OMSPP.%7
GLOBAL OMSPS.Mark
CALL 2
LABEL L150
RETURN
END

PROC OMSPP.CheckConst 0 3 0x00100001
!   PROCEDURE CheckConst(VAR x: G.Item);
LINE 69
!     IF x.mode # B.Const THEN S.Mark("not a constant"); x.mode := B.Const END
LINE 71
LDLW 12
LDNW 8
CONST 1
JEQ L157
CONST 15
GLOBAL OMSPP.%8
GLOBAL OMSPS.Mark
CALL 2
CONST 1
LDLW 12
STNW 8
LABEL L157
RETURN
END

PROC OMSPP.CheckReadOnly 0 3 0x00100001
!   PROCEDURE CheckReadOnly(VAR x: G.Item);
LINE 74
!     IF x.rdo THEN S.Mark("read-only") END
LINE 76
LDLW 12
CONST 32
LDIC
JEQZ L160
CONST 10
GLOBAL OMSPP.%9
GLOBAL OMSPS.Mark
CALL 2
LABEL L160
RETURN
END

PROC OMSPP.CheckExport 0 3 0x00100001
!   PROCEDURE CheckExport(VAR expo: BOOLEAN);
LINE 79
!     IF sym = S.times THEN
LINE 81
LDGW OMSPP.sym
CONST 1
JNEQ L163
!       expo := TRUE; S.Get(sym);
LINE 82
CONST 1
LDLW 12
STOREC
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!       IF level # 0 THEN S.Mark("remove asterisk") END
LINE 83
LDGW OMSPP.level
JEQZ L161
CONST 16
GLOBAL OMSPP.%10
GLOBAL OMSPS.Mark
CALL 2
RETURN
LABEL L163
!     ELSE expo := FALSE
LINE 84
CONST 0
LDLW 12
STOREC
LABEL L161
RETURN
END

PROC OMSPP.CheckUnsafeMarking 0 3 0x00100001
!   PROCEDURE CheckUnsafeMarking(VAR unsafe: BOOLEAN);
LINE 88
!     IF sym = S.emark THEN
LINE 90
LDGW OMSPP.sym
CONST 19
JNEQ L169
!       unsafe := TRUE; S.Get(sym);
LINE 91
CONST 1
LDLW 12
STOREC
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!       IF level = 0 THEN S.Mark("remove exclamation mark") END
LINE 92
LDGW OMSPP.level
JNEQZ L167
CONST 24
GLOBAL OMSPP.%11
GLOBAL OMSPS.Mark
CALL 2
RETURN
LABEL L169
!     ELSE unsafe := FALSE
LINE 93
CONST 0
LDLW 12
STOREC
LABEL L167
RETURN
END

PROC OMSPP.IsExtension 0 3 0x00300001
!   PROCEDURE IsExtension(t0, t1: B.Type): BOOLEAN;
LINE 97
!     RETURN (t0 = t1) OR (t1 # NIL) & IsExtension(t0, t1.base)
LINE 99
LDLW 12
LDLW 16
JEQ L173
LDLW 16
JEQZ L174
LDLW 16
NCHECK 99
LDNW 28
LDLW 12
GLOBAL OMSPP.IsExtension
CALLW 2
JEQZ L174
LABEL L173
CONST 1
RETURN
LABEL L174
CONST 0
RETURN
END

PROC OMSPP.TypeTest 4 6 0x00510001
!   PROCEDURE TypeTest(VAR x: G.Item; T: B.Type; guard: BOOLEAN);
LINE 103
!   BEGIN xt := x.type;
LINE 105
LDLW 12
LDNW 12
STLW -4
!     IF (T.form = xt.form ) & ((T.form = B.Pointer) OR (T.form = B.Record) & (x.mode = B.Par)) THEN
LINE 106
LDLW 20
NCHECK 106
LOADW
LDLW -4
NCHECK 106
LOADW
JNEQ L180
LDLW 20
NCHECK 106
LOADW
CONST 7
JEQ L179
LDLW 20
NCHECK 106
LOADW
CONST 13
JNEQ L180
LDLW 12
LDNW 8
CONST 3
JNEQ L180
LABEL L179
!       WHILE (xt # T) & (xt # NIL) DO xt := xt.base END ;
LINE 107
LDLW -4
LDLW 20
JEQ L183
LDLW -4
JEQZ L183
LDLW -4
NCHECK 107
LDNW 28
STLW -4
JUMP L179
LABEL L183
!       IF xt # T THEN xt := x.type;
LINE 108
LDLW -4
LDLW 20
JEQ L187
LDLW 12
LDNW 12
STLW -4
!         IF xt.form = B.Pointer THEN
LINE 109
LDLW -4
NCHECK 109
LOADW
CONST 7
JNEQ L190
!           IF IsExtension(xt.base, T.base) THEN G.TypeTest(x, T.base, FALSE, guard); x.type := T
LINE 110
LDLW 20
NCHECK 110
LDNW 28
LDLW -4
NCHECK 110
LDNW 28
GLOBAL OMSPP.IsExtension
CALLW 2
JEQZ L193
LDLC 24
ALIGNC
CONST 0
ALIGNC
LDLW 20
NCHECK 110
LDNW 28
LDLW 16
LDLW 12
GLOBAL OMSPG.TypeTest
CALL 5
LDLW 20
LDLW 12
STNW 12
JUMP L178
LABEL L193
!           ELSE S.Mark("not an extension")
LINE 111
CONST 17
GLOBAL OMSPP.%12
GLOBAL OMSPS.Mark
CALL 2
JUMP L178
LABEL L190
!         ELSIF (xt.form = B.Record) & (x.mode = B.Par) THEN
LINE 113
LDLW -4
NCHECK 113
LOADW
CONST 13
JNEQ L195
LDLW 12
LDNW 8
CONST 3
JNEQ L195
!           IF IsExtension(xt, T) THEN  G.TypeTest(x, T, TRUE, guard); x.type := T
LINE 114
LDLW 20
LDLW -4
GLOBAL OMSPP.IsExtension
CALLW 2
JEQZ L198
LDLC 24
ALIGNC
CONST 1
ALIGNC
LDLW 20
LDLW 16
LDLW 12
GLOBAL OMSPG.TypeTest
CALL 5
LDLW 20
LDLW 12
STNW 12
JUMP L178
LABEL L198
!           ELSE S.Mark("not an extension")
LINE 115
CONST 17
GLOBAL OMSPP.%12
GLOBAL OMSPS.Mark
CALL 2
JUMP L178
LABEL L195
!         ELSE S.Mark("incompatible types")
LINE 117
CONST 19
GLOBAL OMSPP.%13
GLOBAL OMSPS.Mark
CALL 2
JUMP L178
LABEL L187
!       ELSIF ~guard THEN G.TypeTest(x, NIL, FALSE, FALSE)
LINE 119
LDLC 24
JNEQZ L178
CONST 0
ALIGNC
CONST 0
ALIGNC
CONST 0
LDLW 16
LDLW 12
GLOBAL OMSPG.TypeTest
CALL 5
JUMP L178
LABEL L180
!     ELSE S.Mark("type mismatch")
LINE 121
CONST 14
GLOBAL OMSPP.%14
GLOBAL OMSPS.Mark
CALL 2
LABEL L178
!     IF ~guard THEN x.type := B.boolType END
LINE 123
LDLC 24
JNEQZ L207
LDGW OMSPB.boolType
LDLW 12
STNW 12
LABEL L207
RETURN
END

PROC OMSPP.StandFunc 80 7 0x0090180d
!   PROCEDURE StandFunc(VAR x: G.Item; fct: INTEGER; restyp: B.Type);
LINE 126
!   BEGIN Check(S.lparen, "no (");
LINE 128
CONST 5
GLOBAL OMSPP.%15
CONST 28
GLOBAL OMSPP.Check
CALL 3
!     npar := fct MOD 10; fct := fct DIV 10; expression(x); n := 1;
LINE 129
LDLW 20
CONST 10
MOD
STLW -80
LDLW 20
CONST 10
DIV
STLW 20
LDLW 16
LDLW 12
LDGW OMSPP.expression
NCHECK 129
CALL 2
CONST 1
STLW -76
!     IF (fct IN {4, 5, 7, 15, 16}) & (x.obj # NIL) THEN x.rdo := x.obj.rdo END;
LINE 130
CONST 1
LDLW 20
CONST 32
BOUND 130
LSL
CONST 98480
BITAND
JEQZ L210
LDLW 12
LDNW 16
JEQZ L210
LDLW 12
LDNW 16
NCHECK 130
CONST 5
LDIC
LDLW 12
CONST 32
STIC
LABEL L210
!     IF sym = S.comma THEN S.Get(sym); expression(y); n := 2;
LINE 131
LDGW OMSPP.sym
CONST 40
JNEQ L214
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -36
LDGW OMSPP.expression
NCHECK 131
CALL 2
CONST 2
STLW -76
LABEL L215
!       WHILE sym = S.comma DO S.Get(sym); expression(z); INC(n) END ;
LINE 132
LDGW OMSPP.sym
CONST 40
JNEQ L214
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -72
LDGW OMSPP.expression
NCHECK 132
CALL 2
INCL -76
JUMP L215
LABEL L214
!     Check(S.rparen, "no )");
LINE 134
CONST 5
GLOBAL OMSPP.%16
CONST 44
GLOBAL OMSPP.Check
CALL 3
!     IF n = npar THEN
LINE 135
LDLW -76
LDLW -80
JNEQ L220
!       IF fct = 0 THEN (*ABS*) CheckInt(x); G.Abs(x)
LINE 136
LDLW 20
JNEQZ L225
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckInt
CALL 2
LDLW 16
LDLW 12
GLOBAL OMSPG.Abs
CALL 2
JUMP L223
LABEL L225
!       ELSIF fct = 1 THEN (*ODD*) CheckInt(x); G.Odd(x)
LINE 137
LDLW 20
CONST 1
JNEQ L227
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckInt
CALL 2
LDLW 16
LDLW 12
GLOBAL OMSPG.Odd
CALL 2
JUMP L223
LABEL L227
!       ELSIF fct = 4 THEN (*ORD*)
LINE 138
LDLW 20
CONST 4
JNEQ L229
!         IF x.type.form <= B.Proc THEN G.Ord(x); IF x.type.size = 1 THEN restyp := B.byteType END
LINE 139
LDLW 12
LDNW 12
NCHECK 139
LOADW
CONST 10
JGT L232
LDLW 16
LDLW 12
GLOBAL OMSPG.Ord
CALL 2
LDLW 12
LDNW 12
NCHECK 139
LDNW 32
CONST 1
JNEQ L223
LDGW OMSPB.byteType
STLW 24
JUMP L223
LABEL L232
!         ELSIF (x.type.form = B.String) & (G.Length(x) = 2) THEN G.StrToChar(x); restyp := B.byteType
LINE 140
LDLW 12
LDNW 12
NCHECK 140
LOADW
CONST 11
JNEQ L237
LDLW 12
GLOBAL OMSPG.Length
CALLW 1
CONST 2
JNEQ L237
LDLW 16
LDLW 12
GLOBAL OMSPG.StrToChar
CALL 2
LDGW OMSPB.byteType
STLW 24
JUMP L223
LABEL L237
!         ELSE S.Mark("bad type")
LINE 141
CONST 9
GLOBAL OMSPP.%17
GLOBAL OMSPS.Mark
CALL 2
JUMP L223
LABEL L229
!       ELSIF fct = 5 THEN (*CHR*) CheckInt(x); G.Ord(x)
LINE 143
LDLW 20
CONST 5
JNEQ L240
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckInt
CALL 2
LDLW 16
LDLW 12
GLOBAL OMSPG.Ord
CALL 2
JUMP L223
LABEL L240
!       ELSIF fct = 6 THEN (*LEN*)
LINE 144
LDLW 20
CONST 6
JNEQ L242
!           IF x.type.form IN {B.Array, B.String} THEN G.Len(x) ELSE S.Mark("not an array") END
LINE 145
CONST 1
LDLW 12
LDNW 12
NCHECK 145
LOADW
CONST 32
BOUND 145
LSL
CONST 6144
BITAND
JEQZ L245
LDLW 16
LDLW 12
GLOBAL OMSPG.Len
CALL 2
JUMP L223
LABEL L245
CONST 13
GLOBAL OMSPP.%18
GLOBAL OMSPS.Mark
CALL 2
JUMP L223
LABEL L242
!       ELSIF fct = 7 THEN (*TOSET*) CheckInt(x)
LINE 146
LDLW 20
CONST 7
JNEQ L247
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckInt
CALL 2
JUMP L223
LABEL L247
!       ELSIF fct = 14 THEN (*BIT*)
LINE 147
LDLW 20
CONST 14
JNEQ L249
!         IF (x.type.form IN {B.Int, B.Set}) & (y.type.form IN {B.Int, B.Set}) THEN G.Bit(x, y) ELSE S.Mark("bad type") END
LINE 148
CONST 1
LDLW 12
LDNW 12
NCHECK 148
LOADW
CONST 32
BOUND 148
LSL
CONST 80
BITAND
JEQZ L252
CONST 1
LDLW -24
NCHECK 148
LOADW
CONST 32
BOUND 148
LSL
CONST 80
BITAND
JEQZ L252
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
GLOBAL OMSPG.Bit
CALL 4
JUMP L223
LABEL L252
CONST 9
GLOBAL OMSPP.%17
GLOBAL OMSPS.Mark
CALL 2
JUMP L223
LABEL L249
!       ELSIF fct = 15 THEN (*PTR: make a type checked pointer of type x pointing on y*)
LINE 149
LDLW 20
CONST 15
JNEQ L255
!         IF x.mode # B.Typ THEN S.Mark("first op is not a type")
LINE 150
LDLW 12
LDNW 8
CONST 5
JEQ L259
CONST 23
GLOBAL OMSPP.%19
GLOBAL OMSPS.Mark
CALL 2
JUMP L223
LABEL L259
!         ELSIF x.type.base # y.type THEN S.Mark("incompatible types")
LINE 151
LDLW 12
LDNW 12
NCHECK 151
LDNW 28
LDLW -24
JEQ L261
CONST 19
GLOBAL OMSPP.%13
GLOBAL OMSPS.Mark
CALL 2
JUMP L223
LABEL L261
!         ELSE restyp := x.type; G.Adr(y); x :=  y
LINE 152
LDLW 12
LDNW 12
STLW 24
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPG.Adr
CALL 2
LDLW 16
GLOBAL OMSPG.Item
JEQ L257
ERROR E_ASSIGN 152
LABEL L257
LDLW 12
LOCAL -36
CONST 36
FIXCOPY
JUMP L223
LABEL L255
!       ELSIF fct = 16 THEN (*VAL*)
LINE 154
LDLW 20
CONST 16
JNEQ L263
!         IF (x.mode= B.Typ) & (x.type.size <= y.type.size) THEN restyp := x.type; G.Val(y, restyp); x := y
LINE 155
LDLW 12
LDNW 8
CONST 5
JNEQ L266
LDLW 12
LDNW 12
NCHECK 155
LDNW 32
LDLW -24
NCHECK 155
LDNW 32
JGT L266
LDLW 12
LDNW 12
STLW 24
LDLW 24
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPG.Val
CALL 3
LDLW 16
GLOBAL OMSPG.Item
JEQ L267
ERROR E_ASSIGN 155
LABEL L267
LDLW 12
LOCAL -36
CONST 36
FIXCOPY
JUMP L223
LABEL L266
!         ELSE S.Mark("casting not allowed")
LINE 156
CONST 20
GLOBAL OMSPP.%20
GLOBAL OMSPS.Mark
CALL 2
JUMP L223
LABEL L263
!       ELSIF fct = 17 THEN (*ADR*) G.Adr(x)
LINE 158
LDLW 20
CONST 17
JNEQ L270
LDLW 16
LDLW 12
GLOBAL OMSPG.Adr
CALL 2
JUMP L223
LABEL L270
!       ELSIF fct = 18 THEN (*SIZE*)
LINE 159
LDLW 20
CONST 18
JNEQ L272
!         IF x.mode = B.Typ THEN G.MakeConstItem(x, B.intType, x.type.size)
LINE 160
LDLW 12
LDNW 8
CONST 5
JNEQ L275
LDLW 12
LDNW 12
NCHECK 160
LDNW 32
LDGW OMSPB.intType
LDLW 16
LDLW 12
GLOBAL OMSPG.MakeConstItem
CALL 4
JUMP L223
LABEL L275
!         ELSE S.Mark("must be a type")
LINE 161
CONST 15
GLOBAL OMSPP.%21
GLOBAL OMSPS.Mark
CALL 2
JUMP L223
LABEL L272
!       ELSIF fct = 19 THEN (*COND*) CheckConst(x); CheckInt(x); G.Condition(x)
LINE 163
LDLW 20
CONST 19
JNEQ L277
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckConst
CALL 2
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckInt
CALL 2
LDLW 16
LDLW 12
GLOBAL OMSPG.Condition
CALL 2
JUMP L223
LABEL L277
!       ELSIF fct = 22 THEN (*Int Compare*)
LINE 164
LDLW 20
CONST 22
JNEQ L279
!         CheckInt(x); CheckInt(y); CheckConst(z); CheckInt(z); G.IntCompare(x, y, z)
LINE 165
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -72
GLOBAL OMSPP.CheckConst
CALL 2
GLOBAL OMSPG.Item
LOCAL -72
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -72
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
GLOBAL OMSPG.IntCompare
CALL 6
JUMP L223
LABEL L279
CONST 0
CONST 166
GLOBAL EASSERT
CALL 2
LABEL L223
!       x.type := restyp
LINE 168
LDLW 24
LDLW 12
STNW 12
RETURN
LABEL L220
!     ELSE S.Mark("wrong nof params")
LINE 169
CONST 17
GLOBAL OMSPP.%22
GLOBAL OMSPS.Mark
CALL 2
RETURN
END

PROC OMSPP.selector 40 5 0x00101881
!   PROCEDURE selector(VAR x: G.Item);
LINE 173
!     IF x.obj.class = B.SFunc THEN StandFunc(x, x.obj.val, x.obj.type) END;
LINE 176
LDLW 12
LDNW 16
NCHECK 176
LOADC
CONST 7
JNEQ L282
LDLW 12
LDNW 16
NCHECK 176
LDNW 24
LDLW 12
LDNW 16
NCHECK 176
LDNW 60
LDLW 16
LDLW 12
GLOBAL OMSPP.StandFunc
CALL 4
LABEL L282
!     WHILE (sym = S.lbrak) OR (sym = S.period) OR (sym = S.arrow)
LINE 177
LDGW OMSPP.sym
CONST 29
JEQ L284
LDGW OMSPP.sym
CONST 18
JEQ L284
LDGW OMSPP.sym
CONST 17
JEQ L284
LDGW OMSPP.sym
CONST 28
JNEQ L285
CONST 1
LDLW 12
LDNW 12
NCHECK 178
LOADW
CONST 32
BOUND 178
LSL
CONST 8320
BITAND
JEQZ L285
LABEL L284
!       IF sym = S.lbrak THEN
LINE 179
LDGW OMSPP.sym
CONST 29
JNEQ L288
LABEL L289
!         REPEAT S.Get(sym); expression(y); CheckInt(y); 
LINE 180
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -36
LDGW OMSPP.expression
NCHECK 180
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.CheckInt
CALL 2
!           IF x.type.form = B.Array THEN G.Index(x, y); x.type := x.type.base
LINE 181
LDLW 12
LDNW 12
NCHECK 181
LOADW
CONST 12
JNEQ L293
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
GLOBAL OMSPG.Index
CALL 4
LDLW 12
LDNW 12
NCHECK 181
LDNW 28
LDLW 12
STNW 12
JUMP L291
LABEL L293
!           ELSIF x.type.form = B.String THEN G.Index(x, y); x.type := B.charType
LINE 182
LDLW 12
LDNW 12
NCHECK 182
LOADW
CONST 11
JNEQ L295
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
GLOBAL OMSPG.Index
CALL 4
LDGW OMSPB.charType
LDLW 12
STNW 12
JUMP L291
LABEL L295
!           ELSE S.Mark("not an array")
LINE 183
CONST 13
GLOBAL OMSPP.%18
GLOBAL OMSPS.Mark
CALL 2
LABEL L291
!         UNTIL sym # S.comma;
LINE 185
LDGW OMSPP.sym
CONST 40
JEQ L289
!         Check(S.rbrak, "no ]")
LINE 186
CONST 5
GLOBAL OMSPP.%23
CONST 45
GLOBAL OMSPP.Check
CALL 3
JUMP L282
LABEL L288
!       ELSIF sym = S.period THEN S.Get(sym);
LINE 187
LDGW OMSPP.sym
CONST 18
JNEQ L297
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!         IF sym = S.ident THEN
LINE 188
LDGW OMSPP.sym
CONST 31
JNEQ L300
!           IF x.type.form = B.Pointer THEN G.DeRef(x); x.type := x.type.base; x.rdo := FALSE END ;
LINE 189
LDLW 12
LDNW 12
NCHECK 189
LOADW
CONST 7
JNEQ L303
LDLW 16
LDLW 12
GLOBAL OMSPG.DeRef
CALL 2
LDLW 12
LDNW 12
NCHECK 189
LDNW 28
LDLW 12
STNW 12
CONST 0
LDLW 12
CONST 32
STIC
LABEL L303
!           IF x.type.form = B.Record THEN
LINE 190
LDLW 12
LDNW 12
NCHECK 190
LOADW
CONST 13
JNEQ L306
!             obj := B.thisfield(x.type); S.Get(sym);
LINE 191
LDLW 12
LDNW 12
GLOBAL OMSPB.thisfield
CALLW 1
STLW -40
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!             IF obj # NIL THEN G.Field(x, obj); x.type := obj.type; x.rdo := obj.rdo
LINE 192
LDLW -40
JEQZ L309
LDLW -40
LDLW 16
LDLW 12
GLOBAL OMSPG.Field
CALL 3
LDLW -40
NCHECK 192
LDNW 24
LDLW 12
STNW 12
LDLW -40
NCHECK 192
CONST 5
LDIC
LDLW 12
CONST 32
STIC
JUMP L282
LABEL L309
!             ELSE S.Mark("undef")
LINE 193
CONST 6
GLOBAL OMSPP.%1
GLOBAL OMSPS.Mark
CALL 2
JUMP L282
LABEL L306
!           ELSE S.Mark("not a record"); S.Get(sym)
LINE 195
CONST 13
GLOBAL OMSPP.%24
GLOBAL OMSPS.Mark
CALL 2
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
JUMP L282
LABEL L300
!         ELSE S.Mark("ident?")
LINE 197
CONST 7
GLOBAL OMSPP.%25
GLOBAL OMSPS.Mark
CALL 2
JUMP L282
LABEL L297
!       ELSIF sym = S.arrow THEN
LINE 199
LDGW OMSPP.sym
CONST 17
JNEQ L311
!         S.Get(sym);
LINE 200
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!         IF x.type.form = B.Pointer THEN G.DeRef(x); x.type := x.type.base; x.rdo := FALSE
LINE 201
LDLW 12
LDNW 12
NCHECK 201
LOADW
CONST 7
JNEQ L314
LDLW 16
LDLW 12
GLOBAL OMSPG.DeRef
CALL 2
LDLW 12
LDNW 12
NCHECK 201
LDNW 28
LDLW 12
STNW 12
CONST 0
LDLW 12
CONST 32
STIC
JUMP L282
LABEL L314
!         ELSE S.Mark("not a pointer")
LINE 202
CONST 14
GLOBAL OMSPP.%26
GLOBAL OMSPS.Mark
CALL 2
JUMP L282
LABEL L311
!       ELSIF (sym = S.lparen) & (x.type.form IN {B.Record, B.Pointer}) THEN (*type guard*)
LINE 204
LDGW OMSPP.sym
CONST 28
JNEQ L282
CONST 1
LDLW 12
LDNW 12
NCHECK 204
LOADW
CONST 32
BOUND 204
LSL
CONST 8320
BITAND
JEQZ L282
!         S.Get(sym);
LINE 205
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!         IF sym = S.ident THEN
LINE 206
LDGW OMSPP.sym
CONST 31
JNEQ L319
!           qualident(obj);
LINE 207
LOCAL -40
GLOBAL OMSPP.qualident
CALL 1
!           IF obj.class = B.Typ THEN TypeTest(x, obj.type, TRUE)
LINE 208
LDLW -40
NCHECK 208
LOADC
CONST 5
JNEQ L322
CONST 1
ALIGNC
LDLW -40
NCHECK 208
LDNW 24
LDLW 16
LDLW 12
GLOBAL OMSPP.TypeTest
CALL 4
JUMP L317
LABEL L322
!           ELSE S.Mark("guard type expected")
LINE 209
CONST 20
GLOBAL OMSPP.%27
GLOBAL OMSPS.Mark
CALL 2
JUMP L317
LABEL L319
!         ELSE S.Mark("not an identifier")
LINE 211
CONST 18
GLOBAL OMSPP.%28
GLOBAL OMSPS.Mark
CALL 2
LABEL L317
!         Check(S.rparen, " ) missing")
LINE 213
CONST 11
GLOBAL OMSPP.%29
CONST 44
GLOBAL OMSPP.Check
CALL 3
JUMP L282
LABEL L285
RETURN
END

PROC OMSPP.EqualSignatures 24 5 0x00318001
!   PROCEDURE EqualSignatures(t0, t1: B.Type): BOOLEAN;
LINE 218
!   BEGIN com := TRUE; dr := t1.ur - t0.ur;
LINE 221
CONST 1
STLC -9
LDLW 16
NCHECK 221
LDNW 40
LDLW 12
NCHECK 221
LDNW 40
BITNOT
BITAND
STLW -20
!     IF dr # {} THEN S.Mark("regs destroyed: "); first := TRUE;
LINE 222
LDLW -20
JEQZ L330
CONST 17
GLOBAL OMSPP.%30
GLOBAL OMSPS.Mark
CALL 2
CONST 1
STLC -21
!       FOR i := 0 TO 15 DO
LINE 223
CONST 0
STLW -16
LABEL L331
LDLW -16
CONST 15
JGT L332
!         IF i IN dr THEN IF ~first THEN Texts.WriteString(W, ", ") END;
LINE 224
LDLW -20
CONST 1
LDLW -16
CONST 32
BOUND 224
LSL
BITAND
JEQZ L335
LDLC -21
JNEQZ L338
CONST 3
GLOBAL OMSPP.%31
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteString
CALL 4
LABEL L338
!           Texts.Write(W, "R"); Texts.WriteInt(W, i, 1); first := FALSE
LINE 225
CONST 82
ALIGNC
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.Write
CALL 3
CONST 1
LDLW -16
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteInt
CALL 4
CONST 0
STLC -21
LABEL L335
!       FOR i := 0 TO 15 DO
LINE 223
INCL -16
JUMP L331
LABEL L332
!       END; Texts.WriteLn(W);
LINE 227
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteLn
CALL 2
!       com := FALSE END;
LINE 228
CONST 0
STLC -9
LABEL L330
!     IF (t0.base = t1.base) & (t0.nofpar = t1.nofpar) THEN
LINE 229
LDLW 12
NCHECK 229
LDNW 28
LDLW 16
NCHECK 229
LDNW 28
JNEQ L341
LDLW 12
NCHECK 229
LDNW 12
LDLW 16
NCHECK 229
LDNW 12
JNEQ L341
!       p0 := t0.dsc; p1 := t1.dsc;
LINE 230
LDLW 12
NCHECK 230
LDNW 20
STLW -4
LDLW 16
NCHECK 230
LDNW 20
STLW -8
LABEL L342
!       WHILE p0 # NIL DO
LINE 231
LDLW -4
JEQZ L339
!         IF (p0.class = p1.class) &  (p0.rdo = p1.rdo) &
LINE 232
LDLW -4
NCHECK 232
LOADC
LDLW -8
NCHECK 232
LOADC
JNEQ L347
LDLW -4
NCHECK 232
CONST 5
LDIC
LDLW -8
NCHECK 232
CONST 5
LDIC
JNEQ L347
LDLW -4
NCHECK 233
LDNW 24
LDLW -8
NCHECK 233
LDNW 24
JNEQ L352
LDLW -4
NCHECK 233
CONST 2
LDIC
LDLW -8
NCHECK 233
CONST 2
LDIC
JEQ L346
LABEL L352
LDLW -4
NCHECK 234
LDNW 24
NCHECK 234
LOADW
CONST 12
JNEQ L349
LDLW -8
NCHECK 234
LDNW 24
NCHECK 234
LOADW
CONST 12
JNEQ L349
LDLW -4
NCHECK 234
LDNW 24
NCHECK 234
LDNW 16
LDLW -8
NCHECK 234
LDNW 24
NCHECK 234
LDNW 16
JNEQ L349
LDLW -4
NCHECK 234
LDNW 24
NCHECK 234
LDNW 28
LDLW -8
NCHECK 234
LDNW 24
NCHECK 234
LDNW 28
JEQ L346
LABEL L349
LDLW -4
NCHECK 235
LDNW 24
NCHECK 235
LOADW
CONST 10
JNEQ L347
LDLW -8
NCHECK 235
LDNW 24
NCHECK 235
LOADW
CONST 10
JNEQ L347
LDLW -8
NCHECK 235
LDNW 24
LDLW -4
NCHECK 235
LDNW 24
GLOBAL OMSPP.EqualSignatures
CALLW 2
JEQZ L347
LABEL L346
!         THEN p0 := p0.next; p1 := p1.next
LINE 236
LDLW -4
NCHECK 236
LDNW 16
STLW -4
LDLW -8
NCHECK 236
LDNW 16
STLW -8
JUMP L342
LABEL L347
!         ELSE p0 := NIL; com := FALSE
LINE 237
CONST 0
STLW -4
CONST 0
STLC -9
JUMP L342
LABEL L341
!     ELSE com := FALSE
LINE 240
CONST 0
STLC -9
LABEL L339
!     IF (t0.base.form # B.NoTyp) & (t0.leaf # t1.leaf) THEN S.Mark("incompatible leafness"); com := FALSE END
LINE 242
LDLW 12
NCHECK 242
LDNW 28
NCHECK 242
LOADW
CONST 9
JEQ L361
LDLW 12
NCHECK 242
CONST 36
LDIC
LDLW 16
NCHECK 242
CONST 36
LDIC
JEQ L361
CONST 22
GLOBAL OMSPP.%32
GLOBAL OMSPS.Mark
CALL 2
CONST 0
STLC -9
LABEL L361
!     RETURN com
LINE 243
LDLC -9
RETURN
END

PROC OMSPP.CompTypes 0 3 0x00300001
!   PROCEDURE CompTypes(t0, t1: B.Type; varpar: BOOLEAN): BOOLEAN;
LINE 246
!     RETURN (t0 = t1)    (*openarray assignment disallowed in OMSPG*)
LINE 248
LDLW 12
LDLW 16
JEQ L363
LDLW 12
NCHECK 249
LOADW
CONST 12
JNEQ L375
LDLW 16
NCHECK 249
LOADW
CONST 12
JNEQ L375
LDLW 12
NCHECK 249
LDNW 28
LDLW 16
NCHECK 249
LDNW 28
JNEQ L375
LDLW 12
NCHECK 249
LDNW 16
LDLW 16
NCHECK 249
LDNW 16
JEQ L363
LABEL L375
LDLW 12
NCHECK 250
LOADW
CONST 13
JNEQ L366
LDLW 16
NCHECK 250
LOADW
CONST 13
JNEQ L366
LDLW 16
LDLW 12
GLOBAL OMSPP.IsExtension
CALLW 2
JNEQZ L363
LABEL L366
LDLC 20
JNEQZ L364
LDLW 12
NCHECK 252
LOADW
CONST 7
JNEQ L370
LDLW 16
NCHECK 252
LOADW
CONST 7
JNEQ L370
LDLW 16
NCHECK 252
LDNW 28
LDLW 12
NCHECK 252
LDNW 28
GLOBAL OMSPP.IsExtension
CALLW 2
JNEQZ L363
LABEL L370
LDLW 12
NCHECK 253
LOADW
CONST 10
JNEQ L368
LDLW 16
NCHECK 253
LOADW
CONST 10
JNEQ L368
LDLW 16
LDLW 12
GLOBAL OMSPP.EqualSignatures
CALLW 2
JNEQZ L363
LABEL L368
CONST 1
LDLW 12
NCHECK 254
LOADW
CONST 32
BOUND 254
LSL
CONST 1152
BITAND
JEQZ L364
LDLW 16
NCHECK 254
LOADW
CONST 8
JNEQ L364
LABEL L363
CONST 1
RETURN
LABEL L364
CONST 0
RETURN
END

PROC OMSPP.Parameter 40 4 0x00101801
!   PROCEDURE Parameter(par: B.Object);
LINE 257
!   BEGIN expression(x);
LINE 259
GLOBAL OMSPG.Item
LOCAL -36
LDGW OMSPP.expression
NCHECK 259
CALL 2
!     IF x.obj # NIL THEN x.rdo := x.obj.rdo END; (*allow updating of VAR parameters*)
LINE 260
LDLW -20
JEQZ L384
LDLW -20
NCHECK 260
CONST 5
LDIC
STLC -4
LABEL L384
!     IF par # NIL THEN
LINE 261
LDLW 12
JEQZ L387
!       varpar := par.class = B.Par;
LINE 262
LDLW 12
NCHECK 262
LOADC
CONST 3
EQ
STLC -37
!       IF CompTypes(par.type, x.type, varpar) THEN
LINE 263
LDLC -37
ALIGNC
LDLW -24
LDLW 12
NCHECK 263
LDNW 24
GLOBAL OMSPP.CompTypes
CALLW 3
JEQZ L390
!         IF ~varpar THEN G.ValueParam(x, par)
LINE 264
LDLC -37
JNEQZ L396
LDLW 12
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPG.ValueParam
CALL 3
RETURN
LABEL L396
!           IF ~par.rdo THEN CheckReadOnly(x) END ;
LINE 266
LDLW 12
NCHECK 266
CONST 5
LDIC
JNEQZ L394
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.CheckReadOnly
CALL 2
LABEL L394
!           G.VarParam(x, par)
LINE 267
LDLW 12
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPG.VarParam
CALL 3
RETURN
LABEL L390
!       ELSIF (x.type.form = B.Array) & (par.type.form = B.Array) &
LINE 269
LDLW -24
NCHECK 269
LOADW
CONST 12
JNEQ L398
LDLW 12
NCHECK 269
LDNW 24
NCHECK 269
LOADW
CONST 12
JNEQ L398
LDLW -24
NCHECK 270
LDNW 28
LDLW 12
NCHECK 270
LDNW 24
NCHECK 270
LDNW 28
JNEQ L398
LDLW 12
NCHECK 270
LDNW 24
NCHECK 270
LDNW 16
JGEQZ L398
!         IF ~par.rdo THEN CheckReadOnly(x) END ;
LINE 271
LDLW 12
NCHECK 271
CONST 5
LDIC
JNEQZ L401
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.CheckReadOnly
CALL 2
LABEL L401
!         G.OpenArrayParam(x, par)
LINE 272
LDLW 12
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPG.OpenArrayParam
CALL 3
RETURN
LABEL L398
!       ELSIF (x.type.form = B.String) & varpar & par.rdo & (par.type.form = B.Array) & 
LINE 273
LDLW -24
NCHECK 273
LOADW
CONST 11
JNEQ L406
LDLC -37
JEQZ L406
LDLW 12
NCHECK 273
CONST 5
LDIC
JEQZ L406
LDLW 12
NCHECK 273
LDNW 24
NCHECK 273
LOADW
CONST 12
JNEQ L406
LDLW 12
NCHECK 274
LDNW 24
NCHECK 274
LDNW 28
NCHECK 274
LOADW
CONST 3
JNEQ L406
LDLW 12
NCHECK 274
LDNW 24
NCHECK 274
LDNW 16
JGEQZ L406
!           (par.type.base.form = B.Char) & (par.type.len < 0) THEN G.StringParam(x, par)
LINE 274
LDLW 12
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPG.StringParam
CALL 3
RETURN
LABEL L406
!       ELSIF ~varpar & (par.type.form = B.Int) & (x.type.form = B.Int) THEN G.ValueParam(x, par)  (*BYTE*)
LINE 275
LDLC -37
JNEQZ L413
LDLW 12
NCHECK 275
LDNW 24
NCHECK 275
LOADW
CONST 4
JNEQ L413
LDLW -24
NCHECK 275
LOADW
CONST 4
JNEQ L413
LDLW 12
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPG.ValueParam
CALL 3
RETURN
LABEL L413
!       ELSIF ~varpar & (par.type.form = B.Set) & (x.type.form = B.Set) THEN G.ValueParam(x, par)  (*byte SET*)
LINE 276
LDLC -37
JNEQZ L417
LDLW 12
NCHECK 276
LDNW 24
NCHECK 276
LOADW
CONST 6
JNEQ L417
LDLW -24
NCHECK 276
LOADW
CONST 6
JNEQ L417
LDLW 12
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPG.ValueParam
CALL 3
RETURN
LABEL L417
!       ELSIF (x.type.form = B.String) & (G.Length(x) = 2) & (par.class = B.Var) & (par.type.form = B.Char) THEN
LINE 277
LDLW -24
NCHECK 277
LOADW
CONST 11
JNEQ L421
LOCAL -36
GLOBAL OMSPG.Length
CALLW 1
CONST 2
JNEQ L421
LDLW 12
NCHECK 277
LOADC
CONST 2
JNEQ L421
LDLW 12
NCHECK 277
LDNW 24
NCHECK 277
LOADW
CONST 3
JNEQ L421
!         G.StrToChar(x); G.ValueParam(x, par)
LINE 278
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPG.StrToChar
CALL 2
LDLW 12
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPG.ValueParam
CALL 3
RETURN
LABEL L421
!       ELSIF (par.type.form = B.Array) & (par.type.base = B.byteType) & 
LINE 279
LDLW 12
NCHECK 279
LDNW 24
NCHECK 279
LOADW
CONST 12
JNEQ L426
LDLW 12
NCHECK 279
LDNW 24
NCHECK 279
LDNW 28
LDGW OMSPB.byteType
JNEQ L426
LDLW 12
NCHECK 280
LDNW 24
NCHECK 280
LDNW 16
JLTZ L426
LDLW 12
NCHECK 280
LDNW 24
NCHECK 280
LDNW 32
LDLW -24
NCHECK 280
LDNW 32
JNEQ L426
!         G.VarParam(x, par)
LINE 281
LDLW 12
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPG.VarParam
CALL 3
RETURN
LABEL L426
!       ELSE S.Mark("incompatible parameters")
LINE 282
CONST 24
GLOBAL OMSPP.%33
GLOBAL OMSPS.Mark
CALL 2
LABEL L387
RETURN
END

PROC OMSPP.ParamList 8 4 0x00108001
!   PROCEDURE ParamList(x: G.Item);
LINE 287
!   BEGIN par := x.type.dsc; n := 0;
LINE 289
LDLW 12
LDNW 12
NCHECK 289
LDNW 20
STLW -8
CONST 0
STLW -4
!     IF sym # S.rparen THEN
LINE 290
LDGW OMSPP.sym
CONST 44
JEQ L432
!       Parameter(par); n := 1;
LINE 291
LDLW -8
GLOBAL OMSPP.Parameter
CALL 1
CONST 1
STLW -4
LABEL L433
!       WHILE sym <= S.comma DO
LINE 292
LDGW OMSPP.sym
CONST 40
JGT L435
!         Check(S.comma, "comma?");
LINE 293
CONST 7
GLOBAL OMSPP.%34
CONST 40
GLOBAL OMSPP.Check
CALL 3
!         IF par # NIL THEN par := par.next END ;
LINE 294
LDLW -8
JEQZ L438
LDLW -8
NCHECK 294
LDNW 16
STLW -8
LABEL L438
!         INC(n); Parameter(par)
LINE 295
INCL -4
LDLW -8
GLOBAL OMSPP.Parameter
CALL 1
JUMP L433
LABEL L435
!       Check(S.rparen, ") missing")
LINE 297
CONST 10
GLOBAL OMSPP.%35
CONST 44
GLOBAL OMSPP.Check
CALL 3
JUMP L430
LABEL L432
!     ELSE S.Get(sym);
LINE 298
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LABEL L430
!     IF n < x.type.nofpar THEN S.Mark("too few params")
LINE 300
LDLW -4
LDLW 12
LDNW 12
NCHECK 300
LDNW 12
JGEQ L441
CONST 15
GLOBAL OMSPP.%36
GLOBAL OMSPS.Mark
CALL 2
RETURN
LABEL L441
!     ELSIF n > x.type.nofpar THEN S.Mark("too many params")
LINE 301
LDLW -4
LDLW 12
LDNW 12
NCHECK 301
LDNW 12
JLEQ L443
CONST 16
GLOBAL OMSPP.%37
GLOBAL OMSPS.Mark
CALL 2
LABEL L443
RETURN
END

PROC OMSPP.element 36 5 0x00101801
!   PROCEDURE element(VAR x: G.Item);
LINE 305
!   BEGIN expression(x); CheckSetVal(x);
LINE 307
LDLW 16
LDLW 12
LDGW OMSPP.expression
NCHECK 307
CALL 2
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckSetVal
CALL 2
!     IF sym = S.upto THEN S.Get(sym); expression(y); CheckSetVal(y); G.Set(x, y)
LINE 308
LDGW OMSPP.sym
CONST 43
JNEQ L446
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -36
LDGW OMSPP.expression
NCHECK 308
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.CheckSetVal
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
GLOBAL OMSPG.Set
CALL 4
JUMP L444
LABEL L446
!     ELSE G.Singleton(x)
LINE 309
LDLW 16
LDLW 12
GLOBAL OMSPG.Singleton
CALL 2
LABEL L444
!     x.type := B.setType
LINE 311
LDGW OMSPB.setType
LDLW 12
STNW 12
RETURN
END

PROC OMSPP.set 36 6 0x00101801
!   PROCEDURE set(VAR x: G.Item);
LINE 314
!     IF sym >= S.if THEN
LINE 317
LDGW OMSPP.sym
CONST 32
JLT L458
!       IF sym # S.rbrace THEN S.Mark(" } missing") END ;
LINE 318
LDGW OMSPP.sym
CONST 46
JEQ L461
CONST 11
GLOBAL OMSPP.%38
GLOBAL OMSPS.Mark
CALL 2
LABEL L461
!       G.MakeConstItem(x, B.setType, 0) (*empty set*)
LINE 319
CONST 0
LDGW OMSPB.setType
LDLW 16
LDLW 12
GLOBAL OMSPG.MakeConstItem
CALL 4
RETURN
LABEL L458
!     ELSE element(x);
LINE 320
LDLW 16
LDLW 12
GLOBAL OMSPP.element
CALL 2
LABEL L448
!       WHILE (sym < S.rparen) OR (sym > S.rbrace) DO
LINE 321
LDGW OMSPP.sym
CONST 44
JLT L449
LDGW OMSPP.sym
CONST 46
JLEQ L450
LABEL L449
!         IF sym = S.comma THEN S.Get(sym)
LINE 322
LDGW OMSPP.sym
CONST 40
JNEQ L453
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
JUMP L455
LABEL L453
!         ELSIF sym # S.rbrace THEN S.Mark("missing comma")
LINE 323
LDGW OMSPP.sym
CONST 46
JEQ L455
CONST 14
GLOBAL OMSPP.%39
GLOBAL OMSPS.Mark
CALL 2
LABEL L455
!         element(y); G.SetOp(S.plus, x, y)
LINE 325
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.element
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
CONST 6
GLOBAL OMSPG.SetOp
CALL 5
JUMP L448
LABEL L450
RETURN
END

PROC OMSPP.factor 16 6 0x00110001
!   PROCEDURE factor(VAR x: G.Item);
LINE 330
!     IF (sym < S.char) OR (sym > S.ident) THEN S.Mark("expression expected");
LINE 333
LDGW OMSPP.sym
CONST 20
JLT L463
LDGW OMSPP.sym
CONST 31
JLEQ L464
LABEL L463
CONST 20
GLOBAL OMSPP.%40
GLOBAL OMSPS.Mark
CALL 2
LABEL L465
!       REPEAT S.Get(sym) UNTIL (sym >= S.char) & (sym <= S.for) OR (sym >= S.then)
LINE 334
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDGW OMSPP.sym
CONST 20
JLT L467
LDGW OMSPP.sym
CONST 37
JLEQ L464
LABEL L467
LDGW OMSPP.sym
CONST 47
JLT L465
LABEL L464
!     IF sym = S.ident THEN
LINE 336
LDGW OMSPP.sym
CONST 31
JNEQ L472
!       qualident(obj); G.MakeItem(x, obj, level); selector(x); x.rdo := TRUE;
LINE 337
LOCAL -4
GLOBAL OMSPP.qualident
CALL 1
LDGW OMSPP.level
LDLW -4
LDLW 16
LDLW 12
GLOBAL OMSPG.MakeItem
CALL 4
LDLW 16
LDLW 12
GLOBAL OMSPP.selector
CALL 2
CONST 1
LDLW 12
CONST 32
STIC
!       IF sym = S.lparen THEN
LINE 338
LDGW OMSPP.sym
CONST 28
JNEQ L470
!         S.Get(sym);
LINE 339
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!         IF (x.type.form = B.Proc) & (x.type.base.form # B.NoTyp) THEN
LINE 340
LDLW 12
LDNW 12
NCHECK 340
LOADW
CONST 10
JNEQ L478
LDLW 12
LDNW 12
NCHECK 340
LDNW 28
NCHECK 340
LOADW
CONST 9
JEQ L478
!           IF isLeaf THEN S.Mark("no call in leaf func"); ParamList(x)
LINE 341
LDGC OMSPP.isLeaf
JEQZ L481
CONST 21
GLOBAL OMSPP.%41
GLOBAL OMSPS.Mark
CALL 2
LDLW 12
GLOBAL OMSPP.ParamList
CALL 1
RETURN
LABEL L481
!           ELSE G.PrepCall(x, rx, orx, pau); ParamList(x); G.Call(x, rx, orx, pau); x.type := x.type.base
LINE 342
LOCAL -13
LOCAL -12
LOCAL -8
LDLW 16
LDLW 12
GLOBAL OMSPG.PrepCall
CALL 5
LDLW 12
GLOBAL OMSPP.ParamList
CALL 1
LDLC -13
ALIGNC
LDLW -12
LDLW -8
LDLW 16
LDLW 12
GLOBAL OMSPG.Call
CALL 5
LDLW 12
LDNW 12
NCHECK 342
LDNW 28
LDLW 12
STNW 12
RETURN
LABEL L478
!         ELSE S.Mark("not a function"); ParamList(x)
LINE 344
CONST 15
GLOBAL OMSPP.%42
GLOBAL OMSPS.Mark
CALL 2
LDLW 12
GLOBAL OMSPP.ParamList
CALL 1
RETURN
LABEL L472
!     ELSIF sym = S.int THEN G.MakeConstItem(x, B.intType, S.ival); S.Get(sym)
LINE 347
LDGW OMSPP.sym
CONST 21
JNEQ L484
LDGW OMSPS.ival
LDGW OMSPB.intType
LDLW 16
LDLW 12
GLOBAL OMSPG.MakeConstItem
CALL 4
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
RETURN
LABEL L484
!     ELSIF sym = S.char THEN G.MakeConstItem(x, B.charType, S.ival); S.Get(sym)
LINE 348
LDGW OMSPP.sym
CONST 20
JNEQ L486
LDGW OMSPS.ival
LDGW OMSPB.charType
LDLW 16
LDLW 12
GLOBAL OMSPG.MakeConstItem
CALL 4
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
RETURN
LABEL L486
!     ELSIF sym = S.nil THEN S.Get(sym); G.MakeConstItem(x, B.nilType, 0)
LINE 349
LDGW OMSPP.sym
CONST 25
JNEQ L488
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
CONST 0
LDGW OMSPB.nilType
LDLW 16
LDLW 12
GLOBAL OMSPG.MakeConstItem
CALL 4
RETURN
LABEL L488
!     ELSIF sym = S.string THEN G.MakeStringItem(x); S.Get(sym)
LINE 350
LDGW OMSPP.sym
CONST 26
JNEQ L490
LDLW 16
LDLW 12
GLOBAL OMSPG.MakeStringItem
CALL 2
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
RETURN
LABEL L490
!     ELSIF sym = S.lparen THEN S.Get(sym); expression(x); Check(S.rparen, "no )")
LINE 351
LDGW OMSPP.sym
CONST 28
JNEQ L492
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW 16
LDLW 12
LDGW OMSPP.expression
NCHECK 351
CALL 2
CONST 5
GLOBAL OMSPP.%16
CONST 44
GLOBAL OMSPP.Check
CALL 3
RETURN
LABEL L492
!     ELSIF sym = S.lbrace THEN S.Get(sym); set(x); Check(S.rbrace, "no }")
LINE 352
LDGW OMSPP.sym
CONST 30
JNEQ L494
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW 16
LDLW 12
GLOBAL OMSPP.set
CALL 2
CONST 5
GLOBAL OMSPP.%43
CONST 46
GLOBAL OMSPP.Check
CALL 3
RETURN
LABEL L494
!     ELSIF sym = S.not THEN S.Get(sym); factor(x); CheckBool(x); G.Not(x)
LINE 353
LDGW OMSPP.sym
CONST 27
JNEQ L496
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW 16
LDLW 12
GLOBAL OMSPP.factor
CALL 2
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckBool
CALL 2
LDLW 16
LDLW 12
GLOBAL OMSPG.Not
CALL 2
RETURN
LABEL L496
!     ELSIF sym = S.false THEN S.Get(sym); G.MakeConstItem(x, B.boolType, 0)
LINE 354
LDGW OMSPP.sym
CONST 23
JNEQ L498
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
CONST 0
LDGW OMSPB.boolType
LDLW 16
LDLW 12
GLOBAL OMSPG.MakeConstItem
CALL 4
RETURN
LABEL L498
!     ELSIF sym = S.true THEN S.Get(sym); G.MakeConstItem(x, B.boolType, 1)
LINE 355
LDGW OMSPP.sym
CONST 24
JNEQ L500
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
CONST 1
LDGW OMSPB.boolType
LDLW 16
LDLW 12
GLOBAL OMSPG.MakeConstItem
CALL 4
RETURN
LABEL L500
!     ELSE S.Mark("not a factor"); S.Get(sym); G.MakeConstItem(x, B.intType, 0)
LINE 356
CONST 13
GLOBAL OMSPP.%44
GLOBAL OMSPS.Mark
CALL 2
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
CONST 0
LDGW OMSPB.intType
LDLW 16
LDLW 12
GLOBAL OMSPG.MakeConstItem
CALL 4
LABEL L470
RETURN
END

PROC OMSPP.term 44 6 0x00101801
!   PROCEDURE term(VAR x: G.Item);
LINE 360
!   BEGIN factor(x); f := x.type.form;
LINE 362
LDLW 16
LDLW 12
GLOBAL OMSPP.factor
CALL 2
LDLW 12
LDNW 12
NCHECK 362
LOADW
STLW -44
LABEL L501
!     WHILE (sym >= S.times) & (sym <= S.and) DO
LINE 363
LDGW OMSPP.sym
CONST 1
JLT L503
LDGW OMSPP.sym
CONST 5
JGT L503
!       op := sym; S.Get(sym);
LINE 364
LDGW OMSPP.sym
STLW -40
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!       IF op = S.times THEN
LINE 365
LDLW -40
CONST 1
JNEQ L506
!         IF f = B.Int THEN factor(y); CheckInt(y); G.MulOp(x, y)
LINE 366
LDLW -44
CONST 4
JNEQ L509
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.factor
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
GLOBAL OMSPG.MulOp
CALL 4
JUMP L501
LABEL L509
!          ELSIF f = B.Set THEN factor(y); CheckSet(y); G.SetOp(op, x, y)
LINE 367
LDLW -44
CONST 6
JNEQ L511
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.factor
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.CheckSet
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
LDLW -40
GLOBAL OMSPG.SetOp
CALL 5
JUMP L501
LABEL L511
!         ELSE S.Mark("bad type")
LINE 368
CONST 9
GLOBAL OMSPP.%17
GLOBAL OMSPS.Mark
CALL 2
JUMP L501
LABEL L506
!       ELSIF (op = S.div) OR (op = S.mod) THEN
LINE 370
LDLW -40
CONST 3
JEQ L512
LDLW -40
CONST 4
JNEQ L513
LABEL L512
!         CheckInt(x); factor(y); CheckInt(y); G.DivOp(op, x, y)
LINE 371
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.factor
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
LDLW -40
GLOBAL OMSPG.DivOp
CALL 5
JUMP L501
LABEL L513
!       ELSIF op = S.rdiv THEN
LINE 372
LDLW -40
CONST 2
JNEQ L516
!         IF f = B.Set THEN factor(y); CheckSet(y); G.SetOp(op, x, y)
LINE 373
LDLW -44
CONST 6
JNEQ L519
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.factor
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.CheckSet
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
LDLW -40
GLOBAL OMSPG.SetOp
CALL 5
JUMP L501
LABEL L519
!         ELSE S.Mark("bad type")
LINE 374
CONST 9
GLOBAL OMSPP.%17
GLOBAL OMSPS.Mark
CALL 2
JUMP L501
LABEL L516
!       ELSE (*op = and*) CheckBool(x); G.And1(x); factor(y); CheckBool(y); G.And2(x, y)
LINE 376
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckBool
CALL 2
LDLW 16
LDLW 12
GLOBAL OMSPG.And1
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.factor
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.CheckBool
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
GLOBAL OMSPG.And2
CALL 4
JUMP L501
LABEL L503
RETURN
END

PROC OMSPP.SimpleExpression 40 6 0x00101801
!   PROCEDURE SimpleExpression(VAR x: G.Item);
LINE 381
!     IF sym = S.minus THEN S.Get(sym); term(x);
LINE 384
LDGW OMSPP.sym
CONST 7
JNEQ L523
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW 16
LDLW 12
GLOBAL OMSPP.term
CALL 2
!       IF x.type.form IN {B.Int, B.Set} THEN G.Neg(x) ELSE CheckInt(x) END
LINE 385
CONST 1
LDLW 12
LDNW 12
NCHECK 385
LOADW
CONST 32
BOUND 385
LSL
CONST 80
BITAND
JEQZ L526
LDLW 16
LDLW 12
GLOBAL OMSPG.Neg
CALL 2
JUMP L521
LABEL L526
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckInt
CALL 2
JUMP L521
LABEL L523
!     ELSIF sym = S.plus THEN S.Get(sym); term(x);
LINE 386
LDGW OMSPP.sym
CONST 6
JNEQ L528
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW 16
LDLW 12
GLOBAL OMSPP.term
CALL 2
JUMP L521
LABEL L528
!     ELSE term(x)
LINE 387
LDLW 16
LDLW 12
GLOBAL OMSPP.term
CALL 2
LABEL L521
!     WHILE (sym >= S.plus) & (sym <= S.or) DO
LINE 389
LDGW OMSPP.sym
CONST 6
JLT L531
LDGW OMSPP.sym
CONST 8
JGT L531
!       op := sym; S.Get(sym);
LINE 390
LDGW OMSPP.sym
STLW -40
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!       IF op = S.or THEN G.Or1(x); CheckBool(x); term(y); CheckBool(y); G.Or2(x, y)
LINE 391
LDLW -40
CONST 8
JNEQ L534
LDLW 16
LDLW 12
GLOBAL OMSPG.Or1
CALL 2
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckBool
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.term
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.CheckBool
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
GLOBAL OMSPG.Or2
CALL 4
JUMP L521
LABEL L534
!       ELSIF x.type.form = B.Int THEN term(y); CheckInt(y); G.AddOp(op, x, y)
LINE 392
LDLW 12
LDNW 12
NCHECK 392
LOADW
CONST 4
JNEQ L536
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.term
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
LDLW -40
GLOBAL OMSPG.AddOp
CALL 5
JUMP L521
LABEL L536
!       ELSIF x.type.form = B.String THEN term(y);
LINE 393
LDLW 12
LDNW 12
NCHECK 393
LOADW
CONST 11
JNEQ L538
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.term
CALL 2
!         IF y.type.form IN {B.String, B.Char} THEN G.StringOp(op, x, y) ELSE S.Mark("not String nor Char") END
LINE 394
CONST 1
LDLW -24
NCHECK 394
LOADW
CONST 32
BOUND 394
LSL
CONST 2056
BITAND
JEQZ L541
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
LDLW -40
GLOBAL OMSPG.StringOp
CALL 5
JUMP L521
LABEL L541
CONST 20
GLOBAL OMSPP.%45
GLOBAL OMSPS.Mark
CALL 2
JUMP L521
LABEL L538
!       ELSE CheckSet(x); term(y); CheckSet(y); G.SetOp(op, x, y)
LINE 395
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckSet
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.term
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.CheckSet
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
LDLW -40
GLOBAL OMSPG.SetOp
CALL 5
JUMP L521
LABEL L531
RETURN
END

PROC OMSPP.expression0 52 6 0x00101881
!   PROCEDURE expression0(VAR x: G.Item);
LINE 400
!   BEGIN SimpleExpression(x);
LINE 402
LDLW 16
LDLW 12
GLOBAL OMSPP.SimpleExpression
CALL 2
!     IF (sym >= S.eql) & (sym <= S.leq) THEN
LINE 403
LDGW OMSPP.sym
CONST 9
JLT L545
LDGW OMSPP.sym
CONST 14
JGT L545
!       rel := sym; S.Get(sym); SimpleExpression(y); xf := x.type.form; yf := y.type.form;
LINE 404
LDGW OMSPP.sym
STLW -44
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.SimpleExpression
CALL 2
LDLW 12
LDNW 12
NCHECK 404
LOADW
STLW -48
LDLW -24
NCHECK 404
LOADW
STLW -52
!       IF x.type = y.type THEN
LINE 405
LDLW 12
LDNW 12
LDLW -24
JNEQ L548
!         IF (xf IN {B.Char, B.Int}) THEN G.IntRelation(rel, x, y)
LINE 406
CONST 1
LDLW -48
CONST 32
BOUND 406
LSL
CONST 24
BITAND
JEQZ L551
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
LDLW -44
GLOBAL OMSPG.IntRelation
CALL 5
JUMP L546
LABEL L551
!         ELSIF (xf IN {B.Set, B.Pointer, B.Proc, B.NilTyp, B.Bool}) THEN
LINE 407
CONST 1
LDLW -48
CONST 32
BOUND 407
LSL
CONST 1476
BITAND
JEQZ L553
!           IF rel <= S.neq THEN G.IntRelation(rel, x, y) ELSE S.Mark("only = or #") END
LINE 408
LDLW -44
CONST 10
JGT L556
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
LDLW -44
GLOBAL OMSPG.IntRelation
CALL 5
JUMP L546
LABEL L556
CONST 12
GLOBAL OMSPP.%46
GLOBAL OMSPS.Mark
CALL 2
JUMP L546
LABEL L553
!         ELSIF (xf = B.Array) & (x.type.base.form = B.Char) OR (xf = B.String) THEN
LINE 409
LDLW -48
CONST 12
JNEQ L559
LDLW 12
LDNW 12
NCHECK 409
LDNW 28
NCHECK 409
LOADW
CONST 3
JEQ L557
LABEL L559
LDLW -48
CONST 11
JNEQ L558
LABEL L557
!           G.StringRelation(rel, x, y)
LINE 410
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
LDLW -44
GLOBAL OMSPG.StringRelation
CALL 5
JUMP L546
LABEL L558
!         ELSE S.Mark("illegal comparison")
LINE 411
CONST 19
GLOBAL OMSPP.%47
GLOBAL OMSPS.Mark
CALL 2
JUMP L546
LABEL L548
!       ELSIF (xf IN {B.Pointer, B.Proc}) & (yf = B.NilTyp)
LINE 413
CONST 1
LDLW -48
CONST 32
BOUND 413
LSL
CONST 1152
BITAND
JEQZ L566
LDLW -52
CONST 8
JEQ L561
LABEL L566
CONST 1
LDLW -52
CONST 32
BOUND 414
LSL
CONST 1152
BITAND
JEQZ L562
LDLW -48
CONST 8
JNEQ L562
LABEL L561
!         IF rel <= S.neq THEN G.IntRelation(rel, x,  y) ELSE S.Mark("only = or #") END
LINE 415
LDLW -44
CONST 10
JGT L565
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
LDLW -44
GLOBAL OMSPG.IntRelation
CALL 5
JUMP L546
LABEL L565
CONST 12
GLOBAL OMSPP.%46
GLOBAL OMSPS.Mark
CALL 2
JUMP L546
LABEL L562
!       ELSIF (xf = B.Pointer) & (yf = B.Pointer) &
LINE 416
LDLW -48
CONST 7
JNEQ L574
LDLW -52
CONST 7
JNEQ L574
LDLW -24
NCHECK 417
LDNW 28
LDLW 12
LDNW 12
NCHECK 417
LDNW 28
GLOBAL OMSPP.IsExtension
CALLW 2
JNEQZ L569
LDLW 12
LDNW 12
NCHECK 417
LDNW 28
LDLW -24
NCHECK 417
LDNW 28
GLOBAL OMSPP.IsExtension
CALLW 2
JNEQZ L569
LABEL L574
LDLW -48
CONST 10
JNEQ L570
LDLW -52
CONST 10
JNEQ L570
LDLW -24
LDLW 12
LDNW 12
GLOBAL OMSPP.EqualSignatures
CALLW 2
JEQZ L570
LABEL L569
!         IF rel <= S.neq THEN G.IntRelation(rel,  x, y) ELSE S.Mark("only = or #") END
LINE 419
LDLW -44
CONST 10
JGT L573
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
LDLW -44
GLOBAL OMSPG.IntRelation
CALL 5
JUMP L546
LABEL L573
CONST 12
GLOBAL OMSPP.%46
GLOBAL OMSPS.Mark
CALL 2
JUMP L546
LABEL L570
!       ELSIF (xf = B.Array) & (x.type.base.form = B.Char) &
LINE 420
LDLW -48
CONST 12
JNEQ L582
LDLW 12
LDNW 12
NCHECK 420
LDNW 28
NCHECK 420
LOADW
CONST 3
JNEQ L582
LDLW -52
CONST 11
JEQ L580
LDLW -52
CONST 12
JNEQ L582
LDLW -24
NCHECK 421
LDNW 28
NCHECK 421
LOADW
CONST 3
JEQ L580
LABEL L582
LDLW -52
CONST 12
JNEQ L581
LDLW -24
NCHECK 422
LDNW 28
NCHECK 422
LOADW
CONST 3
JNEQ L581
LDLW -48
CONST 11
JNEQ L581
LABEL L580
!         G.StringRelation(rel, x, y)
LINE 423
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
LDLW -44
GLOBAL OMSPG.StringRelation
CALL 5
JUMP L546
LABEL L581
!       ELSIF (xf = B.Char) & (yf = B.String) & (G.Length(y) = 2) THEN
LINE 424
LDLW -48
CONST 3
JNEQ L590
LDLW -52
CONST 11
JNEQ L590
LOCAL -36
GLOBAL OMSPG.Length
CALLW 1
CONST 2
JNEQ L590
!         G.StrToChar(y); G.IntRelation(rel, x, y)
LINE 425
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPG.StrToChar
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
LDLW -44
GLOBAL OMSPG.IntRelation
CALL 5
JUMP L546
LABEL L590
!       ELSIF (yf = B.Char) & (xf = B.String) & (G.Length(x) = 2) THEN
LINE 426
LDLW -52
CONST 3
JNEQ L594
LDLW -48
CONST 11
JNEQ L594
LDLW 12
GLOBAL OMSPG.Length
CALLW 1
CONST 2
JNEQ L594
!         G.StrToChar(x); G.IntRelation(rel, x, y)
LINE 427
LDLW 16
LDLW 12
GLOBAL OMSPG.StrToChar
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
LDLW -44
GLOBAL OMSPG.IntRelation
CALL 5
JUMP L546
LABEL L594
!       ELSIF (xf = B.Int) & (yf = B.Int) THEN G.IntRelation(rel,  x, y)  (*BYTE*)
LINE 428
LDLW -48
CONST 4
JNEQ L598
LDLW -52
CONST 4
JNEQ L598
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
LDLW -44
GLOBAL OMSPG.IntRelation
CALL 5
JUMP L546
LABEL L598
!       ELSIF (xf = B.Set) & (yf = B.Set) THEN
LINE 429
LDLW -48
CONST 6
JNEQ L601
LDLW -52
CONST 6
JNEQ L601
!         IF rel <= S.neq THEN G.IntRelation(rel, x, y) ELSE S.Mark("only = or #") END (*byte SET*)
LINE 430
LDLW -44
CONST 10
JGT L604
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
LDLW -44
GLOBAL OMSPG.IntRelation
CALL 5
JUMP L546
LABEL L604
CONST 12
GLOBAL OMSPP.%46
GLOBAL OMSPS.Mark
CALL 2
JUMP L546
LABEL L601
!       ELSE S.Mark("illegal comparison")
LINE 431
CONST 19
GLOBAL OMSPP.%47
GLOBAL OMSPS.Mark
CALL 2
LABEL L546
!       x.type := B.boolType
LINE 433
LDGW OMSPB.boolType
LDLW 12
STNW 12
RETURN
LABEL L545
!     ELSIF sym = S.in THEN
LINE 434
LDGW OMSPP.sym
CONST 15
JNEQ L608
!       S.Get(sym); CheckInt(x); SimpleExpression(y); CheckSet(y); G.In(x, y) ;
LINE 435
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW 16
LDLW 12
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.SimpleExpression
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
GLOBAL OMSPP.CheckSet
CALL 2
GLOBAL OMSPG.Item
LOCAL -36
LDLW 16
LDLW 12
GLOBAL OMSPG.In
CALL 4
!       x.type := B.boolType
LINE 436
LDGW OMSPB.boolType
LDLW 12
STNW 12
RETURN
LABEL L608
!     ELSIF sym = S.is THEN
LINE 437
LDGW OMSPP.sym
CONST 16
JNEQ L610
!       S.Get(sym); qualident(obj); TypeTest(x, obj.type, FALSE) ;
LINE 438
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LOCAL -40
GLOBAL OMSPP.qualident
CALL 1
CONST 0
ALIGNC
LDLW -40
NCHECK 438
LDNW 24
LDLW 16
LDLW 12
GLOBAL OMSPP.TypeTest
CALL 4
!       x.type := B.boolType
LINE 439
LDGW OMSPB.boolType
LDLW 12
STNW 12
LABEL L610
RETURN
END

PROC OMSPP.StandProc 116 7 OMSPP.StandProc.%map
!   PROCEDURE StandProc(pno: INTEGER);
LINE 445
!   BEGIN npar := pno MOD 10; pno := pno DIV 10;
LINE 448
LDLW 12
CONST 10
MOD
STLW -8
LDLW 12
CONST 10
DIV
STLW 12
!     IF npar # 0 THEN
LINE 449
LDLW -8
JEQZ L613
!       Check(S.lparen, "no (");
LINE 450
CONST 5
GLOBAL OMSPP.%15
CONST 28
GLOBAL OMSPP.Check
CALL 3
!       IF (pno = 4) (*ASSERT*) & ~G.AssertionChecked() THEN G.EnableCode(FALSE) END;
LINE 451
LDLW 12
CONST 4
JNEQ L616
GLOBAL OMSPG.AssertionChecked
CALLW 0
JNEQZ L616
CONST 0
ALIGNC
GLOBAL OMSPG.EnableCode
CALL 1
LABEL L616
!       expression(x); nap := 1; IF x.obj # NIL THEN x.rdo := x.obj.rdo END; G.CheckWritable(x);
LINE 452
GLOBAL OMSPG.Item
LOCAL -44
LDGW OMSPP.expression
NCHECK 452
CALL 2
CONST 1
STLW -4
LDLW -28
JEQZ L620
LDLW -28
NCHECK 452
CONST 5
LDIC
STLC -12
LABEL L620
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.CheckWritable
CALL 2
!       IF sym = S.comma THEN S.Get(sym);
LINE 453
LDGW OMSPP.sym
CONST 40
JNEQ L623
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!         expression(y); nap := 2; z.type := B.noType;
LINE 454
GLOBAL OMSPG.Item
LOCAL -80
LDGW OMSPP.expression
NCHECK 454
CALL 2
CONST 2
STLW -4
LDGW OMSPB.noType
STLW -104
LABEL L624
!         WHILE sym = S.comma DO S.Get(sym); expression(z); INC(nap) END
LINE 455
LDGW OMSPP.sym
CONST 40
JNEQ L621
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -116
LDGW OMSPP.expression
NCHECK 455
CALL 2
INCL -4
JUMP L624
LABEL L623
!       ELSE y.type := B.noType
LINE 456
LDGW OMSPB.noType
STLW -68
LABEL L621
!       Check(S.rparen, "no )")
LINE 458
CONST 5
GLOBAL OMSPP.%16
CONST 44
GLOBAL OMSPP.Check
CALL 3
JUMP L611
LABEL L613
!     ELSE nap := 0
LINE 459
CONST 0
STLW -4
LABEL L611
!     IF (npar = nap) OR (pno IN {0, 1}) THEN 
LINE 461
LDLW -8
LDLW -4
JEQ L628
CONST 1
LDLW 12
CONST 32
BOUND 461
LSL
CONST 3
BITAND
JEQZ L629
LABEL L628
!       IF pno IN {0, 1} THEN (*INC, DEC*)
LINE 462
CONST 1
LDLW 12
CONST 32
BOUND 462
LSL
CONST 3
BITAND
JEQZ L634
!         CheckInt(x); CheckReadOnly(x);
LINE 463
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckReadOnly
CALL 2
!         IF y.type # B.noType THEN CheckInt(y) END ;
LINE 464
LDLW -68
LDGW OMSPB.noType
JEQ L637
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPP.CheckInt
CALL 2
LABEL L637
!         G.Increment(pno, x, y)
LINE 465
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPG.Item
LOCAL -44
LDLW 12
GLOBAL OMSPG.Increment
CALL 5
JUMP L627
LABEL L634
!       ELSIF pno IN {2, 3} THEN (*INCL, EXCL*)
LINE 466
CONST 1
LDLW 12
CONST 32
BOUND 466
LSL
CONST 12
BITAND
JEQZ L639
!         CheckSet(x); CheckReadOnly(x); CheckInt(y); G.Include(pno-2, x, y)
LINE 467
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckSet
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckReadOnly
CALL 2
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPG.Item
LOCAL -44
LDLW 12
CONST 2
MINUS
GLOBAL OMSPG.Include
CALL 5
JUMP L627
LABEL L639
!       ELSIF pno = 4 THEN CheckBool(x); G.Assert(x)
LINE 468
LDLW 12
CONST 4
JNEQ L641
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckBool
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.Assert
CALL 2
JUMP L627
LABEL L641
!       ELSIF pno IN {5, 6, 7, 8} THEN CheckReadOnly(x); G.Logical(pno-5, x, y)
LINE 469
CONST 1
LDLW 12
CONST 32
BOUND 469
LSL
CONST 480
BITAND
JEQZ L643
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckReadOnly
CALL 2
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPG.Item
LOCAL -44
LDLW 12
CONST 5
MINUS
GLOBAL OMSPG.Logical
CALL 5
JUMP L627
LABEL L643
!       ELSIF pno IN {9, 10} THEN G.LogicalSR(pno-9, x)
LINE 470
CONST 1
LDLW 12
CONST 32
BOUND 470
LSL
CONST 1536
BITAND
JEQZ L645
GLOBAL OMSPG.Item
LOCAL -44
LDLW 12
CONST 9
MINUS
GLOBAL OMSPG.LogicalSR
CALL 3
JUMP L627
LABEL L645
!       ELSIF pno = 12 THEN CheckInt(x); CheckInt(y); CheckInt(z); G.Copy(x, y, z)
LINE 471
LDLW 12
CONST 12
JNEQ L647
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -116
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -116
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.Copy
CALL 6
JUMP L627
LABEL L647
!       ELSIF pno = 13 THEN G.ClrC
LINE 472
LDLW 12
CONST 13
JNEQ L649
GLOBAL OMSPG.ClrC
CALL 0
JUMP L627
LABEL L649
!       ELSIF pno = 14 THEN G.Nop
LINE 473
LDLW 12
CONST 14
JNEQ L651
GLOBAL OMSPG.Nop
CALL 0
JUMP L627
LABEL L651
!       ELSIF pno = 15 THEN CheckReadOnly(x); G.ADC(x, y)
LINE 474
LDLW 12
CONST 15
JNEQ L653
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckReadOnly
CALL 2
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.ADC
CALL 4
JUMP L627
LABEL L653
!       ELSIF pno = 16 THEN CheckReadOnly(x); G.SBC(x, y)
LINE 475
LDLW 12
CONST 16
JNEQ L655
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckReadOnly
CALL 2
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.SBC
CALL 4
JUMP L627
LABEL L655
!       ELSIF pno IN {17, 19} THEN (*RLA, RRA*) CheckReadOnly(x); CheckInt(y);
LINE 476
CONST 1
LDLW 12
CONST 32
BOUND 476
LSL
CONST 655360
BITAND
JEQZ L657
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckReadOnly
CALL 2
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPP.CheckInt
CALL 2
!         IF x.type.form IN {B.Int, B.Set} THEN G.Shift(pno-17, x, y) ELSE S.Mark("bad type") END
LINE 477
CONST 1
LDLW -32
NCHECK 477
LOADW
CONST 32
BOUND 477
LSL
CONST 80
BITAND
JEQZ L660
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPG.Item
LOCAL -44
LDLW 12
CONST 17
MINUS
GLOBAL OMSPG.Shift
CALL 5
JUMP L627
LABEL L660
CONST 9
GLOBAL OMSPP.%17
GLOBAL OMSPS.Mark
CALL 2
JUMP L627
LABEL L657
!       ELSIF pno IN {18, 20} THEN (*RLC, RRC*) CheckReadOnly(x);
LINE 478
CONST 1
LDLW 12
CONST 32
BOUND 478
LSL
CONST 1310720
BITAND
JEQZ L662
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckReadOnly
CALL 2
!         IF x.type.form IN {B.Int, B.Set} THEN G.Rotate(pno-18, x) ELSE S.Mark("bad type") END
LINE 479
CONST 1
LDLW -32
NCHECK 479
LOADW
CONST 32
BOUND 479
LSL
CONST 80
BITAND
JEQZ L665
GLOBAL OMSPG.Item
LOCAL -44
LDLW 12
CONST 18
MINUS
GLOBAL OMSPG.Rotate
CALL 3
JUMP L627
LABEL L665
CONST 9
GLOBAL OMSPP.%17
GLOBAL OMSPS.Mark
CALL 2
JUMP L627
LABEL L662
!       ELSIF pno IN {21, 22} THEN 
LINE 480
CONST 1
LDLW 12
CONST 32
BOUND 480
LSL
CONST 6291456
BITAND
JEQZ L667
!         IF isInt THEN G.LogicalSROnExit(pno-21, x) ELSE S.Mark("not allowed here") END
LINE 481
LDGC OMSPP.isInt
JEQZ L670
GLOBAL OMSPG.Item
LOCAL -44
LDLW 12
CONST 21
MINUS
GLOBAL OMSPG.LogicalSROnExit
CALL 3
JUMP L627
LABEL L670
CONST 17
GLOBAL OMSPP.%48
GLOBAL OMSPS.Mark
CALL 2
JUMP L627
LABEL L667
!       ELSIF pno = 23 THEN CheckReadOnly(x); CheckInt(x); G.Swpb(x)
LINE 482
LDLW 12
CONST 23
JNEQ L672
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckReadOnly
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.Swpb
CALL 2
JUMP L627
LABEL L672
CONST 0
CONST 483
GLOBAL EASSERT
CALL 2
JUMP L627
LABEL L629
!     ELSE S.Mark("wrong nof parameters")
LINE 485
CONST 21
GLOBAL OMSPP.%49
GLOBAL OMSPS.Mark
CALL 2
LABEL L627
!     G.EnableCode(TRUE)
LINE 487
CONST 1
ALIGNC
GLOBAL OMSPG.EnableCode
CALL 1
RETURN
END

PROC OMSPP.%119.TypeCase 8 5 0x00308001
SAVELINK
!     PROCEDURE TypeCase(obj: B.Object; VAR x: G.Item);
LINE 496
!     BEGIN G.MakeItem(x, obj, level);
LINE 498
LDGW OMSPP.level
LDLW 12
LDLW 20
LDLW 16
GLOBAL OMSPG.MakeItem
CALL 4
!       IF sym = S.ident THEN
LINE 499
LDGW OMSPP.sym
CONST 31
JNEQ L676
!         qualident(typobj);
LINE 500
LOCAL -8
GLOBAL OMSPP.qualident
CALL 1
!         IF typobj.class # B.Typ THEN S.Mark("not a type") END ;
LINE 501
LDLW -8
NCHECK 501
LOADC
CONST 5
JEQ L679
CONST 11
GLOBAL OMSPP.%50
GLOBAL OMSPS.Mark
CALL 2
LABEL L679
!         TypeTest(x, typobj.type, FALSE); obj.type := typobj.type;
LINE 502
CONST 0
ALIGNC
LDLW -8
NCHECK 502
LDNW 24
LDLW 20
LDLW 16
GLOBAL OMSPP.TypeTest
CALL 4
LDLW -8
NCHECK 502
LDNW 24
LDLW 12
NCHECK 502
STNW 24
!         G.CFJump(x); Check(S.colon, ": expected"); StatSequence
LINE 503
LDLW 20
LDLW 16
GLOBAL OMSPG.CFJump
CALL 2
CONST 11
GLOBAL OMSPP.%51
CONST 41
GLOBAL OMSPP.Check
CALL 3
GLOBAL OMSPP.StatSequence
CALL 0
RETURN
LABEL L676
!       ELSE G.CFJump(x); S.Mark("type id expected")
LINE 504
LDLW 20
LDLW 16
GLOBAL OMSPG.CFJump
CALL 2
CONST 17
GLOBAL OMSPP.%52
GLOBAL OMSPS.Mark
CALL 2
RETURN
END

PROC OMSPP.%120.SkipCase 4 2 0
SAVELINK
!     PROCEDURE SkipCase;
LINE 508
LABEL L680
!       WHILE sym # S.colon DO S.Get(sym) END ;
LINE 510
LDGW OMSPP.sym
CONST 41
JEQ L682
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
JUMP L680
LABEL L682
!       S.Get(sym); StatSequence
LINE 511
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPP.StatSequence
CALL 0
RETURN
END

PROC OMSPP.StatSequence 172 10 OMSPP.StatSequence.%map
!   PROCEDURE StatSequence;
LINE 490
LABEL L683
!     REPEAT (*sync*) obj := NIL;
LINE 515
CONST 0
STLW -4
!       IF ~((sym >= S.ident)  & (sym <= S.for) OR (sym >= S.semicolon)) THEN
LINE 516
LDGW OMSPP.sym
CONST 31
JLT L690
LDGW OMSPP.sym
CONST 37
JLEQ L687
LABEL L690
LDGW OMSPP.sym
CONST 52
JGEQ L687
!         S.Mark("statement expected");
LINE 517
CONST 19
GLOBAL OMSPP.%53
GLOBAL OMSPS.Mark
CALL 2
LABEL L688
!         REPEAT S.Get(sym) UNTIL (sym >= S.ident)
LINE 518
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDGW OMSPP.sym
CONST 31
JLT L688
LABEL L687
!       IF sym = S.ident THEN
LINE 520
LDGW OMSPP.sym
CONST 31
JNEQ L694
!         qualident(obj);  IF initmode & (obj.lev = 0) THEN obj.rdo := FALSE END;
LINE 521
LOCAL -4
GLOBAL OMSPP.qualident
CALL 1
LDGC OMSPP.initmode
JEQZ L697
LDLW -4
NCHECK 521
LDNW 8
JNEQZ L697
CONST 0
LDLW -4
NCHECK 521
CONST 5
STIC
LABEL L697
!         G.MakeItem(x, obj, level);
LINE 522
LDGW OMSPP.level
LDLW -4
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.MakeItem
CALL 4
!         IF x.mode = B.SProc THEN StandProc(obj.val)
LINE 523
LDLW -36
CONST 6
JNEQ L754
LDLW -4
NCHECK 523
LDNW 60
GLOBAL OMSPP.StandProc
CALL 1
JUMP L785
LABEL L754
!         ELSE selector(x);
LINE 524
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.selector
CALL 2
!           IF sym = S.becomes THEN (*assignment*)
LINE 525
LDGW OMSPP.sym
CONST 42
JNEQ L702
!             S.Get(sym); CheckReadOnly(x); expression(y);
LINE 526
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckReadOnly
CALL 2
GLOBAL OMSPG.Item
LOCAL -80
LDGW OMSPP.expression
NCHECK 526
CALL 2
!             IF CompTypes(x.type, y.type, FALSE) THEN
LINE 527
CONST 0
ALIGNC
LDLW -68
LDLW -32
GLOBAL OMSPP.CompTypes
CALLW 3
JEQZ L705
!               IF (x.type.form <= B.Pointer) OR (x.type.form = B.Proc) THEN G.Store(x, y)
LINE 528
LDLW -32
NCHECK 528
LOADW
CONST 7
JLEQ L707
LDLW -32
NCHECK 528
LOADW
CONST 10
JNEQ L708
LABEL L707
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.Store
CALL 4
JUMP L785
LABEL L708
!               ELSE G.StoreStruct(x, y)
LINE 529
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.StoreStruct
CALL 4
JUMP L785
LABEL L705
!             ELSIF (x.type.form = B.Array) & (y.type.form = B.Array) & (x.type.base = y.type.base) & (y.type.len < 0) THEN
LINE 531
LDLW -32
NCHECK 531
LOADW
CONST 12
JNEQ L711
LDLW -68
NCHECK 531
LOADW
CONST 12
JNEQ L711
LDLW -32
NCHECK 531
LDNW 28
LDLW -68
NCHECK 531
LDNW 28
JNEQ L711
LDLW -68
NCHECK 531
LDNW 16
JGEQZ L711
!               G.StoreStruct(x, y)
LINE 532
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.StoreStruct
CALL 4
JUMP L785
LABEL L711
!             ELSIF (x.type.form = B.Array) & (x.type.base.form = B.Char) & (y.type.form = B.String) THEN
LINE 533
LDLW -32
NCHECK 533
LOADW
CONST 12
JNEQ L716
LDLW -32
NCHECK 533
LDNW 28
NCHECK 533
LOADW
CONST 3
JNEQ L716
LDLW -68
NCHECK 533
LOADW
CONST 11
JNEQ L716
!               G.CopyString(x, y)
LINE 534
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.CopyString
CALL 4
JUMP L785
LABEL L716
!             ELSIF (x.type.form = B.Int) & (y.type.form = B.Int) THEN G.Store(x, y)  (*BYTE*)
LINE 535
LDLW -32
NCHECK 535
LOADW
CONST 4
JNEQ L720
LDLW -68
NCHECK 535
LOADW
CONST 4
JNEQ L720
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.Store
CALL 4
JUMP L785
LABEL L720
!             ELSIF (x.type.form = B.Set) & (y.type.form = B.Set) THEN G.Store(x, y)  (*byte SET*)
LINE 536
LDLW -32
NCHECK 536
LOADW
CONST 6
JNEQ L723
LDLW -68
NCHECK 536
LOADW
CONST 6
JNEQ L723
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.Store
CALL 4
JUMP L785
LABEL L723
!             ELSIF (x.type.form = B.Char) & (y.type.form = B.String) & (G.Length(y) = 2) THEN
LINE 537
LDLW -32
NCHECK 537
LOADW
CONST 3
JNEQ L726
LDLW -68
NCHECK 537
LOADW
CONST 11
JNEQ L726
LOCAL -80
GLOBAL OMSPG.Length
CALLW 1
CONST 2
JNEQ L726
!               G.StrToChar(y); G.Store(x, y)
LINE 538
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPG.StrToChar
CALL 2
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.Store
CALL 4
JUMP L785
LABEL L726
!             ELSE S.Mark("illegal assignment")
LINE 539
CONST 19
GLOBAL OMSPP.%54
GLOBAL OMSPS.Mark
CALL 2
JUMP L785
LABEL L702
!           ELSIF sym = S.eql THEN S.Mark("should be :="); S.Get(sym); expression(y)
LINE 541
LDGW OMSPP.sym
CONST 9
JNEQ L730
CONST 13
GLOBAL OMSPP.%55
GLOBAL OMSPS.Mark
CALL 2
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -80
LDGW OMSPP.expression
NCHECK 541
CALL 2
JUMP L785
LABEL L730
!           ELSIF sym = S.lparen THEN (*procedure call*)
LINE 542
LDGW OMSPP.sym
CONST 28
JNEQ L732
!             S.Get(sym);
LINE 543
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!             IF (x.type.form = B.Proc) & (x.type.base.form = B.NoTyp) THEN
LINE 544
LDLW -32
NCHECK 544
LOADW
CONST 10
JNEQ L735
LDLW -32
NCHECK 544
LDNW 28
NCHECK 544
LOADW
CONST 9
JNEQ L735
!               IF isLeaf THEN S.Mark("no call in leaf proc"); ParamList(x)
LINE 545
LDGC OMSPP.isLeaf
JEQZ L738
CONST 21
GLOBAL OMSPP.%56
GLOBAL OMSPS.Mark
CALL 2
LOCAL -44
GLOBAL OMSPP.ParamList
CALL 1
JUMP L785
LABEL L738
!               ELSE G.PrepCall(x, rx, orx, pau); ParamList(x); G.Call(x, rx, orx, pau)
LINE 546
LOCAL -169
LOCAL -168
LOCAL -164
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.PrepCall
CALL 5
LOCAL -44
GLOBAL OMSPP.ParamList
CALL 1
LDLC -169
ALIGNC
LDLW -168
LDLW -164
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.Call
CALL 5
JUMP L785
LABEL L735
!             ELSE S.Mark("not a procedure"); ParamList(x)
LINE 548
CONST 16
GLOBAL OMSPP.%57
GLOBAL OMSPS.Mark
CALL 2
LOCAL -44
GLOBAL OMSPP.ParamList
CALL 1
JUMP L785
LABEL L732
!           ELSIF x.type.form = B.Proc THEN (*procedure call without parameters*)
LINE 550
LDLW -32
NCHECK 550
LOADW
CONST 10
JNEQ L741
!             IF x.type.nofpar > 0 THEN S.Mark("missing parameters") END ;
LINE 551
LDLW -32
NCHECK 551
LDNW 12
JLEQZ L744
CONST 19
GLOBAL OMSPP.%58
GLOBAL OMSPS.Mark
CALL 2
LABEL L744
!             IF x.type.base.form = B.NoTyp THEN
LINE 552
LDLW -32
NCHECK 552
LDNW 28
NCHECK 552
LOADW
CONST 9
JNEQ L747
!               IF isLeaf THEN S.Mark("no call in leaf proc")
LINE 553
LDGC OMSPP.isLeaf
JEQZ L750
CONST 21
GLOBAL OMSPP.%56
GLOBAL OMSPS.Mark
CALL 2
JUMP L785
LABEL L750
!               ELSE G.PrepCall(x, rx, orx, pau); G.Call(x, rx, orx, pau)
LINE 554
LOCAL -169
LOCAL -168
LOCAL -164
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.PrepCall
CALL 5
LDLC -169
ALIGNC
LDLW -168
LDLW -164
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.Call
CALL 5
JUMP L785
LABEL L747
!             ELSE S.Mark("not a procedure")
LINE 556
CONST 16
GLOBAL OMSPP.%57
GLOBAL OMSPS.Mark
CALL 2
JUMP L785
LABEL L741
!           ELSIF x.mode = B.Typ THEN S.Mark("illegal assignment")
LINE 558
LDLW -36
CONST 5
JNEQ L752
CONST 19
GLOBAL OMSPP.%54
GLOBAL OMSPS.Mark
CALL 2
JUMP L785
LABEL L752
!           ELSE S.Mark("not a procedure")
LINE 559
CONST 16
GLOBAL OMSPP.%57
GLOBAL OMSPS.Mark
CALL 2
JUMP L785
LABEL L694
!       ELSIF sym = S.if THEN
LINE 562
LDGW OMSPP.sym
CONST 32
JNEQ L756
!         S.Get(sym); expression(x); CheckBool(x); G.CFJump(x);
LINE 563
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -44
LDGW OMSPP.expression
NCHECK 563
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckBool
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.CFJump
CALL 2
!         Check(S.then, "no THEN");
LINE 564
CONST 8
GLOBAL OMSPP.%59
CONST 47
GLOBAL OMSPP.Check
CALL 3
!         StatSequence; L0 := 0;
LINE 565
GLOBAL OMSPP.StatSequence
CALL 0
CONST 0
STLW -156
LABEL L757
!         WHILE sym = S.elsif DO
LINE 566
LDGW OMSPP.sym
CONST 56
JNEQ L759
!           S.Get(sym); G.FJump(L0); G.Fixup(x); expression(x); CheckBool(x);
LINE 567
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LOCAL -156
GLOBAL OMSPG.FJump
CALL 1
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.Fixup
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
LDGW OMSPP.expression
NCHECK 567
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckBool
CALL 2
!           G.CFJump(x); Check(S.then, "no THEN"); StatSequence
LINE 568
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.CFJump
CALL 2
CONST 8
GLOBAL OMSPP.%59
CONST 47
GLOBAL OMSPP.Check
CALL 3
GLOBAL OMSPP.StatSequence
CALL 0
JUMP L757
LABEL L759
!         IF sym = S.else THEN S.Get(sym); G.FJump(L0); G.Fixup(x); StatSequence
LINE 570
LDGW OMSPP.sym
CONST 55
JNEQ L762
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LOCAL -156
GLOBAL OMSPG.FJump
CALL 1
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.Fixup
CALL 2
GLOBAL OMSPP.StatSequence
CALL 0
JUMP L760
LABEL L762
!         ELSE G.Fixup(x)
LINE 571
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.Fixup
CALL 2
LABEL L760
!         G.FixLink(L0); Check(S.end, "no END")
LINE 573
LDLW -156
GLOBAL OMSPG.FixLink
CALL 1
CONST 7
GLOBAL OMSPP.%60
CONST 53
GLOBAL OMSPP.Check
CALL 3
JUMP L785
LABEL L756
!       ELSIF sym = S.while THEN
LINE 574
LDGW OMSPP.sym
CONST 34
JNEQ L764
!         S.Get(sym); L0 := G.Here(); expression(x); CheckBool(x); G.CFJump(x);
LINE 575
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Here
CALLW 0
STLW -156
GLOBAL OMSPG.Item
LOCAL -44
LDGW OMSPP.expression
NCHECK 575
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckBool
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.CFJump
CALL 2
!         Check(S.do, "no DO"); StatSequence; G.BJump(L0);
LINE 576
CONST 6
GLOBAL OMSPP.%61
CONST 49
GLOBAL OMSPP.Check
CALL 3
GLOBAL OMSPP.StatSequence
CALL 0
LDLW -156
GLOBAL OMSPG.BJump
CALL 1
LABEL L765
!         WHILE sym = S.elsif DO
LINE 577
LDGW OMSPP.sym
CONST 56
JNEQ L767
!           S.Get(sym); G.Fixup(x); expression(x); CheckBool(x); G.CFJump(x);
LINE 578
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.Fixup
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
LDGW OMSPP.expression
NCHECK 578
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckBool
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.CFJump
CALL 2
!           Check(S.do, "no DO"); StatSequence; G.BJump(L0)
LINE 579
CONST 6
GLOBAL OMSPP.%61
CONST 49
GLOBAL OMSPP.Check
CALL 3
GLOBAL OMSPP.StatSequence
CALL 0
LDLW -156
GLOBAL OMSPG.BJump
CALL 1
JUMP L765
LABEL L767
!         G.Fixup(x); Check(S.end, "no END")
LINE 581
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.Fixup
CALL 2
CONST 7
GLOBAL OMSPP.%60
CONST 53
GLOBAL OMSPP.Check
CALL 3
JUMP L785
LABEL L764
!       ELSIF sym = S.repeat THEN
LINE 582
LDGW OMSPP.sym
CONST 35
JNEQ L769
!         S.Get(sym); L0 := G.Here(); StatSequence;
LINE 583
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Here
CALLW 0
STLW -156
GLOBAL OMSPP.StatSequence
CALL 0
!         IF sym = S.until THEN
LINE 584
LDGW OMSPP.sym
CONST 57
JNEQ L772
!           S.Get(sym); expression(x); CheckBool(x); G.CBJump(x, L0)
LINE 585
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -44
LDGW OMSPP.expression
NCHECK 585
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckBool
CALL 2
LDLW -156
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.CBJump
CALL 3
JUMP L785
LABEL L772
!         ELSE S.Mark("missing UNTIL")
LINE 586
CONST 14
GLOBAL OMSPP.%62
GLOBAL OMSPS.Mark
CALL 2
JUMP L785
LABEL L769
!       ELSIF sym = S.for THEN
LINE 588
LDGW OMSPP.sym
CONST 37
JNEQ L774
!         S.Get(sym);
LINE 589
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!         IF sym = S.ident THEN
LINE 590
LDGW OMSPP.sym
CONST 31
JNEQ L777
!           qualident(obj); G.MakeItem(x, obj, level); CheckInt(x); CheckReadOnly(x);
LINE 591
LOCAL -4
GLOBAL OMSPP.qualident
CALL 1
LDGW OMSPP.level
LDLW -4
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.MakeItem
CALL 4
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPP.CheckReadOnly
CALL 2
!           IF sym = S.becomes THEN
LINE 592
LDGW OMSPP.sym
CONST 42
JNEQ L780
!             S.Get(sym); expression(y); CheckInt(y); G.For0(x, y); L0 := G.Here();
LINE 593
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -80
LDGW OMSPP.expression
NCHECK 593
CALL 2
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.For0
CALL 4
GLOBAL OMSPG.Here
CALLW 0
STLW -156
!             Check(S.to, "no TO"); expression(z); CheckInt(z); obj.rdo := TRUE;
LINE 594
CONST 6
GLOBAL OMSPP.%63
CONST 50
GLOBAL OMSPP.Check
CALL 3
GLOBAL OMSPG.Item
LOCAL -116
LDGW OMSPP.expression
NCHECK 594
CALL 2
GLOBAL OMSPG.Item
LOCAL -116
GLOBAL OMSPP.CheckInt
CALL 2
CONST 1
LDLW -4
NCHECK 594
CONST 5
STIC
!             IF sym = S.by THEN S.Get(sym); expression(w); CheckConst(w); CheckInt(w)
LINE 595
LDGW OMSPP.sym
CONST 51
JNEQ L783
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -152
LDGW OMSPP.expression
NCHECK 595
CALL 2
GLOBAL OMSPG.Item
LOCAL -152
GLOBAL OMSPP.CheckConst
CALL 2
GLOBAL OMSPG.Item
LOCAL -152
GLOBAL OMSPP.CheckInt
CALL 2
JUMP L781
LABEL L783
!             ELSE G.MakeConstItem(w, B.intType, 1)
LINE 596
CONST 1
LDGW OMSPB.intType
GLOBAL OMSPG.Item
LOCAL -152
GLOBAL OMSPG.MakeConstItem
CALL 4
LABEL L781
!             Check(S.do, "no DO"); G.For1(x, y, z, w, L1);
LINE 598
CONST 6
GLOBAL OMSPP.%61
CONST 49
GLOBAL OMSPP.Check
CALL 3
LOCAL -160
GLOBAL OMSPG.Item
LOCAL -152
GLOBAL OMSPG.Item
LOCAL -116
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.For1
CALL 9
!             StatSequence; Check(S.end, "no END");
LINE 599
GLOBAL OMSPP.StatSequence
CALL 0
CONST 7
GLOBAL OMSPP.%60
CONST 53
GLOBAL OMSPP.Check
CALL 3
!             G.For2(x, y, w); G.BJump(L0); G.FixLink(L1); obj.rdo := FALSE
LINE 600
GLOBAL OMSPG.Item
LOCAL -152
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.For2
CALL 6
LDLW -156
GLOBAL OMSPG.BJump
CALL 1
LDLW -160
GLOBAL OMSPG.FixLink
CALL 1
CONST 0
LDLW -4
NCHECK 600
CONST 5
STIC
JUMP L785
LABEL L780
!           ELSE S.Mark(":= expected")
LINE 601
CONST 12
GLOBAL OMSPP.%64
GLOBAL OMSPS.Mark
CALL 2
JUMP L785
LABEL L777
!         ELSE S.Mark("identifier expected")
LINE 603
CONST 20
GLOBAL OMSPP.%2
GLOBAL OMSPS.Mark
CALL 2
JUMP L785
LABEL L774
!       ELSIF sym = S.case THEN
LINE 605
LDGW OMSPP.sym
CONST 36
JNEQ L785
!         S.Get(sym);
LINE 606
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!         IF sym = S.ident THEN
LINE 607
LDGW OMSPP.sym
CONST 31
JNEQ L788
!           qualident(obj); orgtype := obj.type;
LINE 608
LOCAL -4
GLOBAL OMSPP.qualident
CALL 1
LDLW -4
NCHECK 608
LDNW 24
STLW -8
!           IF (orgtype.form = B.Pointer) OR (orgtype.form = B.Record) & (obj.class = B.Par) THEN
LINE 609
LDLW -8
NCHECK 609
LOADW
CONST 7
JEQ L793
LDLW -8
NCHECK 609
LOADW
CONST 13
JNEQ L794
LDLW -4
NCHECK 609
LOADC
CONST 3
JNEQ L794
LABEL L793
!             Check(S.of, "OF expected"); TypeCase(obj, x); L0 := 0;
LINE 610
CONST 12
GLOBAL OMSPP.%65
CONST 48
GLOBAL OMSPP.Check
CALL 3
GLOBAL OMSPG.Item
LOCAL -44
LDLW -4
LOCAL 0
STATLINK
GLOBAL OMSPP.%119.TypeCase
CALL 3
CONST 0
STLW -156
LABEL L795
!             WHILE sym = S.bar DO
LINE 611
LDGW OMSPP.sym
CONST 54
JNEQ L797
!               S.Get(sym); G.FJump(L0); G.Fixup(x); obj.type := orgtype; TypeCase(obj, x)
LINE 612
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LOCAL -156
GLOBAL OMSPG.FJump
CALL 1
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.Fixup
CALL 2
LDLW -8
LDLW -4
NCHECK 612
STNW 24
GLOBAL OMSPG.Item
LOCAL -44
LDLW -4
LOCAL 0
STATLINK
GLOBAL OMSPP.%119.TypeCase
CALL 3
JUMP L795
LABEL L797
!             G.Fixup(x); G.FixLink(L0); obj.type := orgtype
LINE 614
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.Fixup
CALL 2
LDLW -156
GLOBAL OMSPG.FixLink
CALL 1
LDLW -8
LDLW -4
NCHECK 614
STNW 24
JUMP L786
LABEL L794
!           ELSE S.Mark("numeric case not implemented");
LINE 615
CONST 29
GLOBAL OMSPP.%66
GLOBAL OMSPS.Mark
CALL 2
!             Check(S.of, "OF expected"); SkipCase;
LINE 616
CONST 12
GLOBAL OMSPP.%65
CONST 48
GLOBAL OMSPP.Check
CALL 3
LOCAL 0
STATLINK
GLOBAL OMSPP.%120.SkipCase
CALL 0
LABEL L790
!             WHILE sym = S.bar DO SkipCase END
LINE 617
LDGW OMSPP.sym
CONST 54
JNEQ L786
LOCAL 0
STATLINK
GLOBAL OMSPP.%120.SkipCase
CALL 0
JUMP L790
LABEL L788
!         ELSE S.Mark("ident expected")
LINE 619
CONST 15
GLOBAL OMSPP.%67
GLOBAL OMSPS.Mark
CALL 2
LABEL L786
!         Check(S.end, "no END")
LINE 621
CONST 7
GLOBAL OMSPP.%60
CONST 53
GLOBAL OMSPP.Check
CALL 3
LABEL L785
!       G.CheckRegs;
LINE 623
GLOBAL OMSPG.CheckRegs
CALL 0
!       IF sym = S.semicolon THEN S.Get(sym)
LINE 624
LDGW OMSPP.sym
CONST 52
JNEQ L802
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
JUMP L804
LABEL L802
!       ELSIF sym < S.semicolon THEN S.Mark("missing semicolon?")
LINE 625
LDGW OMSPP.sym
CONST 52
JGEQ L804
CONST 19
GLOBAL OMSPP.%68
GLOBAL OMSPS.Mark
CALL 2
LABEL L804
!     UNTIL sym > S.semicolon
LINE 627
LDGW OMSPP.sym
CONST 52
JLEQ L683
RETURN
END

PROC OMSPP.IdentList 4 4 0x00210001
!   PROCEDURE IdentList(class: INTEGER; VAR first: B.Object);
LINE 632
!     IF sym = S.ident THEN
LINE 635
LDGW OMSPP.sym
CONST 31
JNEQ L807
!       B.NewObj(first, S.id, class); S.Get(sym); CheckExport(first.expo); CheckUnsafeMarking(first.unsafe);
LINE 636
LDLW 12
GLOBAL OMSPS.id
LDLW 16
GLOBAL OMSPB.NewObj
CALL 3
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW 16
LOADW
NCHECK 636
CONST 3
OFFSET
GLOBAL OMSPP.CheckExport
CALL 1
LDLW 16
LOADW
NCHECK 636
CONST 4
OFFSET
GLOBAL OMSPP.CheckUnsafeMarking
CALL 1
LABEL L808
!       WHILE sym = S.comma DO
LINE 637
LDGW OMSPP.sym
CONST 40
JNEQ L810
!         S.Get(sym);
LINE 638
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!         IF sym = S.ident THEN B.NewObj(obj, S.id, class); S.Get(sym); CheckExport(obj.expo); CheckUnsafeMarking(obj.unsafe)
LINE 639
LDGW OMSPP.sym
CONST 31
JNEQ L813
LDLW 12
GLOBAL OMSPS.id
LOCAL -4
GLOBAL OMSPB.NewObj
CALL 3
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW -4
NCHECK 639
CONST 3
OFFSET
GLOBAL OMSPP.CheckExport
CALL 1
LDLW -4
NCHECK 639
CONST 4
OFFSET
GLOBAL OMSPP.CheckUnsafeMarking
CALL 1
JUMP L808
LABEL L813
!         ELSE S.Mark("ident?")
LINE 640
CONST 7
GLOBAL OMSPP.%25
GLOBAL OMSPS.Mark
CALL 2
JUMP L808
LABEL L810
!       IF sym = S.colon THEN S.Get(sym) ELSE S.Mark(":?") END
LINE 643
LDGW OMSPP.sym
CONST 41
JNEQ L816
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
RETURN
LABEL L816
CONST 3
GLOBAL OMSPP.%69
GLOBAL OMSPS.Mark
CALL 2
RETURN
LABEL L807
!     ELSE first := NIL
LINE 644
CONST 0
LDLW 16
STOREW
RETURN
END

PROC OMSPP.ArrayType 44 3 0x00101881
!   PROCEDURE ArrayType(VAR type: B.Type);
LINE 648
!   BEGIN NEW(typ); typ.form := B.NoTyp;
LINE 650
CONST 44
GLOBAL OMSPB.TypeDesc
GLOBAL NEW
CALLW 2
STLW -40
CONST 9
LDLW -40
NCHECK 650
STOREW
!     expression(x);
LINE 651
GLOBAL OMSPG.Item
LOCAL -36
LDGW OMSPP.expression
NCHECK 651
CALL 2
!     IF (x.mode = B.Const) & (x.type.form = B.Int) & (x.a >= 0) THEN len := x.a
LINE 652
LDLW -28
CONST 1
JNEQ L819
LDLW -24
NCHECK 652
LOADW
CONST 4
JNEQ L819
LDLW -16
JLTZ L819
LDLW -16
STLW -44
JUMP L817
LABEL L819
!     ELSE len := 1; S.Mark("not a valid length")
LINE 653
CONST 1
STLW -44
CONST 19
GLOBAL OMSPP.%70
GLOBAL OMSPS.Mark
CALL 2
LABEL L817
!     IF sym = S.of THEN S.Get(sym); Type(typ.base);
LINE 655
LDGW OMSPP.sym
CONST 48
JNEQ L824
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW -40
NCHECK 655
CONST 28
OFFSET
LDGW OMSPP.Type
NCHECK 655
CALL 1
!       IF (typ.base.form = B.Array) & (typ.base.len < 0) THEN S.Mark("dyn array not allowed") END
LINE 656
LDLW -40
NCHECK 656
LDNW 28
NCHECK 656
LOADW
CONST 12
JNEQ L822
LDLW -40
NCHECK 656
LDNW 28
NCHECK 656
LDNW 16
JGEQZ L822
CONST 22
GLOBAL OMSPP.%71
GLOBAL OMSPS.Mark
CALL 2
JUMP L822
LABEL L824
!     ELSIF sym = S.comma THEN S.Get(sym); ArrayType(typ.base)
LINE 657
LDGW OMSPP.sym
CONST 40
JNEQ L830
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW -40
NCHECK 657
CONST 28
OFFSET
GLOBAL OMSPP.ArrayType
CALL 1
JUMP L822
LABEL L830
!     ELSE S.Mark("missing OF"); typ.base := B.intType
LINE 658
CONST 11
GLOBAL OMSPP.%72
GLOBAL OMSPS.Mark
CALL 2
LDGW OMSPB.intType
LDLW -40
NCHECK 658
STNW 28
LABEL L822
!     typ.size := (len * typ.base.size + (G.WordSize - 1)) DIV G.WordSize * G.WordSize;
LINE 660
LDLW -44
LDLW -40
NCHECK 660
LDNW 28
NCHECK 660
LDNW 32
TIMES
INC
CONST 2
DIV
CONST 2
TIMES
LDLW -40
NCHECK 660
STNW 32
!     typ.form := B.Array; typ.len := len; type := typ
LINE 661
CONST 12
LDLW -40
NCHECK 661
STOREW
LDLW -44
LDLW -40
NCHECK 661
STNW 16
LDLW -40
LDLW 12
STOREW
RETURN
END

PROC OMSPP.RecordType 40 5 0x0011fc01
!   PROCEDURE RecordType(VAR type: B.Type);
LINE 664
!   BEGIN NEW(typ); typ.form := B.NoTyp; typ.base := NIL; typ.mno := -level; typ.nofpar := 0; offset := 0; bot := NIL;
LINE 668
CONST 44
GLOBAL OMSPB.TypeDesc
GLOBAL NEW
CALLW 2
STLW -24
CONST 9
LDLW -24
NCHECK 668
STOREW
CONST 0
LDLW -24
NCHECK 668
STNW 28
LDGW OMSPP.level
UMINUS
LDLW -24
NCHECK 668
STNW 8
CONST 0
LDLW -24
NCHECK 668
STNW 12
CONST 0
STLW -32
CONST 0
STLW -16
!     IF sym = S.lparen THEN
LINE 669
LDGW OMSPP.sym
CONST 28
JNEQ L833
!       S.Get(sym); (*record extension*)
LINE 670
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!       IF level # 0 THEN S.Mark("extension of local types not implemented") END ;
LINE 671
LDGW OMSPP.level
JEQZ L836
CONST 41
GLOBAL OMSPP.%73
GLOBAL OMSPS.Mark
CALL 2
LABEL L836
!       IF sym = S.ident THEN
LINE 672
LDGW OMSPP.sym
CONST 31
JNEQ L839
!         qualident(base);
LINE 673
LOCAL -20
GLOBAL OMSPP.qualident
CALL 1
!         IF base.class = B.Typ THEN
LINE 674
LDLW -20
NCHECK 674
LOADC
CONST 5
JNEQ L842
!           IF base.type.form = B.Record THEN typ.base := base.type
LINE 675
LDLW -20
NCHECK 675
LDNW 24
NCHECK 675
LOADW
CONST 13
JNEQ L845
LDLW -20
NCHECK 675
LDNW 24
LDLW -24
NCHECK 675
STNW 28
JUMP L843
LABEL L845
!           ELSE typ.base := B.intType; S.Mark("invalid extension")
LINE 676
LDGW OMSPB.intType
LDLW -24
NCHECK 676
STNW 28
CONST 18
GLOBAL OMSPP.%74
GLOBAL OMSPS.Mark
CALL 2
LABEL L843
!           typ.nofpar := typ.base.nofpar + 1; (*"nofpar" here abused for extension level*)
LINE 678
LDLW -24
NCHECK 678
LDNW 28
NCHECK 678
LDNW 12
INC
LDLW -24
NCHECK 678
STNW 12
!           bot := typ.base.dsc; offset := typ.base.size
LINE 679
LDLW -24
NCHECK 679
LDNW 28
NCHECK 679
LDNW 20
STLW -16
LDLW -24
NCHECK 679
LDNW 28
NCHECK 679
LDNW 32
STLW -32
JUMP L837
LABEL L842
!         ELSE S.Mark("type expected")
LINE 680
CONST 14
GLOBAL OMSPP.%75
GLOBAL OMSPS.Mark
CALL 2
JUMP L837
LABEL L839
!       ELSE S.Mark("ident expected")
LINE 682
CONST 15
GLOBAL OMSPP.%67
GLOBAL OMSPS.Mark
CALL 2
LABEL L837
!       Check(S.rparen, "no )")
LINE 684
CONST 5
GLOBAL OMSPP.%16
CONST 44
GLOBAL OMSPP.Check
CALL 3
LABEL L833
!     WHILE sym = S.ident DO  (*fields*)
LINE 686
LDGW OMSPP.sym
CONST 31
JNEQ L848
!       n := 0; obj := bot;
LINE 687
CONST 0
STLW -40
LDLW -16
STLW -4
LABEL L849
!       WHILE sym = S.ident DO
LINE 688
LDGW OMSPP.sym
CONST 31
JNEQ L851
!         obj0 := obj;
LINE 689
LDLW -4
STLW -8
LABEL L852
!         WHILE (obj0 # NIL) & (obj0.name # S.id) DO obj0 := obj0.next END ;
LINE 690
LDLW -8
JEQZ L854
CONST 32
GLOBAL OMSPS.id
LDLW -8
NCHECK 690
CONST 28
OFFSET
CONST 32
SWAP
GLOBAL COMPARE
CALLW 4
JEQZ L854
LDLW -8
NCHECK 690
LDNW 16
STLW -8
JUMP L852
LABEL L854
!         IF obj0 # NIL THEN S.Mark("mult def") END ;
LINE 691
LDLW -8
JEQZ L858
CONST 9
GLOBAL OMSPP.%76
GLOBAL OMSPS.Mark
CALL 2
LABEL L858
!         NEW(new); S.CopyId(new.name); new.class := B.Fld; new.next := obj; obj := new; INC(n);
LINE 692
CONST 64
GLOBAL OMSPB.ObjDesc
GLOBAL NEW
CALLW 2
STLW -12
LDLW -12
NCHECK 692
CONST 28
OFFSET
GLOBAL OMSPS.CopyId
CALL 1
CONST 4
LDLW -12
NCHECK 692
STOREC
LDLW -4
LDLW -12
NCHECK 692
STNW 16
LDLW -12
STLW -4
INCL -40
!         S.Get(sym); CheckExport(new.expo);
LINE 693
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW -12
NCHECK 693
CONST 3
OFFSET
GLOBAL OMSPP.CheckExport
CALL 1
!         IF (sym # S.comma) & (sym # S.colon) THEN S.Mark("comma expected")
LINE 694
LDGW OMSPP.sym
CONST 40
JEQ L861
LDGW OMSPP.sym
CONST 41
JEQ L861
CONST 15
GLOBAL OMSPP.%77
GLOBAL OMSPS.Mark
CALL 2
JUMP L849
LABEL L861
!         ELSIF sym = S.comma THEN S.Get(sym)
LINE 695
LDGW OMSPP.sym
CONST 40
JNEQ L849
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
JUMP L849
LABEL L851
!       Check(S.colon, "colon expected"); Type(tp);
LINE 698
CONST 15
GLOBAL OMSPP.%78
CONST 41
GLOBAL OMSPP.Check
CALL 3
LOCAL -28
LDGW OMSPP.Type
NCHECK 698
CALL 1
!       IF (tp.form = B.Array) & (tp.len < 0) THEN S.Mark("dyn array not allowed") END ;
LINE 699
LDLW -28
NCHECK 699
LOADW
CONST 12
JNEQ L867
LDLW -28
NCHECK 699
LDNW 16
JGEQZ L867
CONST 22
GLOBAL OMSPP.%71
GLOBAL OMSPS.Mark
CALL 2
LABEL L867
!       IF tp.size > 1 THEN offset := (offset + (G.WordSize-1)) DIV G.WordSize * G.WordSize END ;
LINE 700
LDLW -28
NCHECK 700
LDNW 32
CONST 1
JLEQ L871
LDLW -32
INC
CONST 2
DIV
CONST 2
TIMES
STLW -32
LABEL L871
!       offset := offset + n * tp.size; off := offset; obj0 := obj;
LINE 701
LDLW -32
LDLW -40
LDLW -28
NCHECK 701
LDNW 32
TIMES
PLUS
STLW -32
LDLW -32
STLW -36
LDLW -4
STLW -8
LABEL L872
!       WHILE obj0 # bot DO obj0.type := tp; obj0.lev := 0; off := off - tp.size; obj0.val := off; obj0 := obj0.next END ;
LINE 702
LDLW -8
LDLW -16
JEQ L874
LDLW -28
LDLW -8
NCHECK 702
STNW 24
CONST 0
LDLW -8
NCHECK 702
STNW 8
LDLW -36
LDLW -28
NCHECK 702
LDNW 32
MINUS
STLW -36
LDLW -36
LDLW -8
NCHECK 702
STNW 60
LDLW -8
NCHECK 702
LDNW 16
STLW -8
JUMP L872
LABEL L874
!       bot := obj;
LINE 703
LDLW -4
STLW -16
!       IF sym = S.semicolon THEN S.Get(sym) ELSIF sym # S.end THEN S.Mark(" ; or END") END
LINE 704
LDGW OMSPP.sym
CONST 52
JNEQ L877
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
JUMP L833
LABEL L877
LDGW OMSPP.sym
CONST 53
JEQ L833
CONST 10
GLOBAL OMSPP.%79
GLOBAL OMSPS.Mark
CALL 2
JUMP L833
LABEL L848
!     typ.form := B.Record; typ.dsc := bot;
LINE 706
CONST 13
LDLW -24
NCHECK 706
STOREW
LDLW -16
LDLW -24
NCHECK 706
STNW 20
!     typ.size := (offset + (G.WordSize - 1)) DIV G.WordSize * G.WordSize;
LINE 707
LDLW -32
INC
CONST 2
DIV
CONST 2
TIMES
LDLW -24
NCHECK 707
STNW 32
!     type := typ
LINE 708
LDLW -24
LDLW 12
STOREW
RETURN
END

PROC OMSPP.FPSection 32 3 0x0071c001
!   PROCEDURE FPSection(VAR adr: INTEGER; VAR nofpar: INTEGER; VAR inreg: BOOLEAN);
LINE 711
!   BEGIN inreg := FALSE;
LINE 714
CONST 0
LDLW 20
STOREC
!     IF sym = S.var THEN S.Get(sym); cl := B.Par ELSE cl := B.Var END ;
LINE 715
LDGW OMSPP.sym
CONST 65
JNEQ L882
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
CONST 3
STLW -28
JUMP L880
LABEL L882
CONST 2
STLW -28
LABEL L880
!     IdentList(cl, first); FormalType(tp, 0); rdo := FALSE;
LINE 716
LOCAL -8
LDLW -28
GLOBAL OMSPP.IdentList
CALL 2
CONST 0
LOCAL -12
LDGW OMSPP.FormalType
NCHECK 716
CALL 2
CONST 0
STLC -29
!     IF sym = S.times THEN inreg := TRUE; G.SetAllocationMode(G.Register); S.Get(sym) END;
LINE 717
LDGW OMSPP.sym
CONST 1
JNEQ L885
CONST 1
LDLW 20
STOREC
CONST 1
ALIGNC
GLOBAL OMSPG.SetAllocationMode
CALL 1
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LABEL L885
!     IF (cl = B.Var) & (tp.form IN {B.Array, B.Record}) THEN cl := B.Par; rdo := TRUE END ;
LINE 718
LDLW -28
CONST 2
JNEQ L888
CONST 1
LDLW -12
NCHECK 718
LOADW
CONST 32
BOUND 718
LSL
CONST 12288
BITAND
JEQZ L888
CONST 3
STLW -28
CONST 1
STLC -29
LABEL L888
!     IF (tp.form = B.Array) & (tp.len < 0) OR (tp.form = B.Record) THEN
LINE 719
LDLW -12
NCHECK 719
LOADW
CONST 12
JNEQ L893
LDLW -12
NCHECK 719
LDNW 16
JLTZ L891
LABEL L893
LDLW -12
NCHECK 719
LOADW
CONST 13
JNEQ L892
LABEL L891
!       parsize := 2*G.WordSize  (*open array or record, needs second word for length or type tag*)
LINE 720
CONST 4
STLW -16
JUMP L890
LABEL L892
!     ELSE parsize := G.WordSize
LINE 721
CONST 2
STLW -16
LABEL L890
!     obj := first;
LINE 723
LDLW -8
STLW -4
LABEL L895
!     WHILE obj # NIL DO
LINE 724
LDLW -4
JEQZ L897
!       INC(nofpar); obj.class := cl; obj.type := tp; obj.rdo := rdo; obj.lev := level; 
LINE 725
LDLW 16
DUP 0
LOADW
INC
SWAP
STOREW
LDLW -28
CONVNC
LDLW -4
NCHECK 725
STOREC
LDLW -12
LDLW -4
NCHECK 725
STNW 24
LDLC -29
LDLW -4
NCHECK 725
CONST 5
STIC
LDGW OMSPP.level
LDLW -4
NCHECK 725
STNW 8
!       IF inreg THEN obj.register := G.AllocR(); nbregs := parsize DIV G.WordSize;
LINE 726
LDLW 20
LOADC
JEQZ L900
GLOBAL OMSPG.AllocR
CALLW 0
CONVNC
LDLW -4
NCHECK 726
CONST 2
STIC
LDLW -16
CONST 2
DIV
STLW -24
LABEL L901
!         WHILE nbregs > 1 DO dummy := G.AllocR(); DEC(nbregs) END
LINE 727
LDLW -24
CONST 1
JLEQ L898
GLOBAL OMSPG.AllocR
CALLW 0
STLW -20
DECL -24
JUMP L901
LABEL L900
!       ELSE obj.register := 0FFH; INC(adr, parsize); obj.val := G.WordSize - adr
LINE 728
CONST 255
LDLW -4
NCHECK 728
CONST 2
STIC
LDLW 12
DUP 0
LOADW
LDLW -16
PLUS
SWAP
STOREW
CONST 2
LDLW 12
LOADW
MINUS
LDLW -4
NCHECK 728
STNW 60
LABEL L898
!       obj := obj.next
LINE 730
LDLW -4
NCHECK 730
LDNW 16
STLW -4
JUMP L895
LABEL L897
!     IF adr >= 26 THEN S.Mark("too many parameters") END
LINE 732
LDLW 12
LOADW
CONST 26
JLT L906
CONST 20
GLOBAL OMSPP.%80
GLOBAL OMSPS.Mark
CALL 2
LABEL L906
RETURN
END

PROC OMSPP.InsertResultRegister 52 3 0x00104311
!   PROCEDURE InsertResultRegister(VAR type: B.Type);
LINE 735
!     IF type.leaf & (type.base.form # B.NoTyp) THEN (*make room for the returned value*)
LINE 738
LDLW 12
LOADW
NCHECK 738
CONST 36
LDIC
JEQZ L909
LDLW 12
LOADW
NCHECK 738
LDNW 28
NCHECK 738
LOADW
CONST 9
JEQ L909
!       G.SetRIU({}); G.resultRegister(x); L := G.AllocR(); ASSERT(L = x.reg); (*reserve result register*)
LINE 739
CONST 0
GLOBAL OMSPG.SetRIU
CALL 1
GLOBAL OMSPG.Item
LOCAL -48
GLOBAL OMSPG.resultRegister
CALL 2
GLOBAL OMSPG.AllocR
CALLW 0
STLW -4
LDLW -4
LDLC -48
JEQ L911
CONST 0
CONST 739
GLOBAL EASSERT
CALL 2
LABEL L911
!         loc := type.dsc; L := 0;
LINE 740
LDLW 12
LOADW
NCHECK 740
LDNW 20
STLW -12
CONST 0
STLW -4
LABEL L912
!         WHILE (loc # NIL) & (L < type.nofpar) DO (*allocate registers to parameters, avoiding the result register*)
LINE 741
LDLW -12
JEQZ L914
LDLW -4
LDLW 12
LOADW
NCHECK 741
LDNW 12
JGEQ L914
!           IF (loc.class IN {B.Var, B.Par}) & (loc.register # 0FFH) THEN loc.register := G.AllocR(); (*allocate next free register to param or variable*)
LINE 742
CONST 1
LDLW -12
NCHECK 742
LOADC
CONST 32
BOUND 742
LSL
CONST 12
BITAND
JEQZ L917
LDLW -12
NCHECK 742
CONST 2
LDIC
CONST 255
JEQ L917
GLOBAL OMSPG.AllocR
CALLW 0
CONVNC
LDLW -12
NCHECK 742
CONST 2
STIC
!             tp := loc.type; IF (tp.form = B.Array) & (tp.len < 0) OR (tp.form = B.Record) THEN dummy := G.AllocR() END; (*allocate extra register*)
LINE 743
LDLW -12
NCHECK 743
LDNW 24
STLW -52
LDLW -52
NCHECK 743
LOADW
CONST 12
JNEQ L921
LDLW -52
NCHECK 743
LDNW 16
JLTZ L919
LABEL L921
LDLW -52
NCHECK 743
LOADW
CONST 13
JNEQ L917
LABEL L919
GLOBAL OMSPG.AllocR
CALLW 0
STLW -8
LABEL L917
!           loc := loc.next; INC(L)
LINE 745
LDLW -12
NCHECK 745
LDNW 16
STLW -12
INCL -4
JUMP L912
LABEL L914
!         END; G.freeR(x.reg); (*free sesult register*)
LINE 746
LDLC -48
GLOBAL OMSPG.freeR
CALL 1
LABEL L925
!         WHILE loc # NIL DO (*allocate registers to local variables, including the result register*)
LINE 747
LDLW -12
JEQZ L909
!           IF (loc.class IN {B.Var, B.Par}) & (loc.register # 0FFH) THEN loc.register := G.AllocR() END; (*allocate next free register to param or variable*)
LINE 748
CONST 1
LDLW -12
NCHECK 748
LOADC
CONST 32
BOUND 748
LSL
CONST 12
BITAND
JEQZ L930
LDLW -12
NCHECK 748
CONST 2
LDIC
CONST 255
JEQ L930
GLOBAL OMSPG.AllocR
CALLW 0
CONVNC
LDLW -12
NCHECK 748
CONST 2
STIC
LABEL L930
!           loc := loc.next
LINE 749
LDLW -12
NCHECK 749
LDNW 16
STLW -12
JUMP L925
LABEL L909
RETURN
END

PROC OMSPP.ProcedureType 88 5 OMSPP.ProcedureType.%map
!   PROCEDURE ProcedureType(ptype: B.Type; VAR parblksize: INTEGER);
LINE 754
!   BEGIN ptype.base := B.noType; size := parblksize; nofpar := 0; ptype.dsc := NIL; leaf := FALSE;
LINE 756
LDGW OMSPB.noType
LDLW 12
NCHECK 756
STNW 28
LDLW 16
LOADW
STLW -8
CONST 0
STLW -12
CONST 0
LDLW 12
NCHECK 756
STNW 20
CONST 0
STLC -13
!     ptype.ur := {4..15}; (*all non saved registers can be destroyed for dynamic procedures*)
LINE 757
CONST 65520
LDLW 12
NCHECK 757
STNW 40
!     IF sym = S.lbrace THEN S.Get(sym); set(sr); CheckConst(sr); Check(S.rbrace, "no }"); ptype.ur := ptype.ur - SYSTEM.VAL(SET, sr.a) END;
LINE 758
LDGW OMSPP.sym
CONST 30
JNEQ L935
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -88
GLOBAL OMSPP.set
CALL 2
GLOBAL OMSPG.Item
LOCAL -88
GLOBAL OMSPP.CheckConst
CALL 2
CONST 5
GLOBAL OMSPP.%43
CONST 46
GLOBAL OMSPP.Check
CALL 3
LDLW 12
NCHECK 758
LDNW 40
LDLW -68
BITNOT
BITAND
LDLW 12
NCHECK 758
STNW 40
LABEL L935
!     IF sym = S.lparen THEN
LINE 759
LDGW OMSPP.sym
CONST 28
JNEQ L938
!       S.Get(sym);
LINE 760
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!       IF sym = S.rparen THEN S.Get(sym)
LINE 761
LDGW OMSPP.sym
CONST 44
JNEQ L950
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
JUMP L939
LABEL L950
!       ELSE FPSection(size, nofpar, inreg); IF inreg THEN leaf := TRUE END;
LINE 762
LOCAL -14
LOCAL -12
LOCAL -8
GLOBAL OMSPP.FPSection
CALL 3
LDLC -14
JEQZ L942
CONST 1
STLC -13
LABEL L942
!         WHILE sym = S.semicolon DO S.Get(sym); FPSection(size, nofpar, inreg); IF inreg THEN leaf := TRUE END END ;
LINE 763
LDGW OMSPP.sym
CONST 52
JNEQ L945
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LOCAL -14
LOCAL -12
LOCAL -8
GLOBAL OMSPP.FPSection
CALL 3
LDLC -14
JEQZ L942
CONST 1
STLC -13
JUMP L942
LABEL L945
!         Check(S.rparen, "no )")
LINE 764
CONST 5
GLOBAL OMSPP.%16
CONST 44
GLOBAL OMSPP.Check
CALL 3
LABEL L939
!       IF sym = S.colon THEN  (*function*)
LINE 766
LDGW OMSPP.sym
CONST 41
JNEQ L938
!         S.Get(sym);
LINE 767
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!         IF sym = S.ident THEN
LINE 768
LDGW OMSPP.sym
CONST 31
JNEQ L956
!           qualident(obj); ptype.base := obj.type;
LINE 769
LOCAL -4
GLOBAL OMSPP.qualident
CALL 1
LDLW -4
NCHECK 769
LDNW 24
LDLW 12
NCHECK 769
STNW 28
!           IF ~((obj.class = B.Typ) & (obj.type.form IN {B.Byte .. B.Pointer, B.Proc})) THEN
LINE 770
LDLW -4
NCHECK 770
LOADC
CONST 5
JNEQ L958
CONST 1
LDLW -4
NCHECK 770
LDNW 24
NCHECK 770
LOADW
CONST 32
BOUND 770
LSL
CONST 1278
BITAND
JNEQZ L954
LABEL L958
!             S.Mark("illegal function type")
LINE 771
CONST 22
GLOBAL OMSPP.%81
GLOBAL OMSPS.Mark
CALL 2
JUMP L954
LABEL L956
!         ELSE S.Mark("type identifier expected")
LINE 773
CONST 25
GLOBAL OMSPP.%82
GLOBAL OMSPS.Mark
CALL 2
LABEL L954
!         G.resultRegister(x); INCL(ptype.ur, x.reg) (*include return register in the list of used registers*)
LINE 775
GLOBAL OMSPG.Item
LOCAL -52
GLOBAL OMSPG.resultRegister
CALL 2
LDLW 12
NCHECK 775
CONST 40
OFFSET
DUP 0
LOADW
CONST 1
LDLC -52
CONST 32
BOUND 775
LSL
BITOR
SWAP
STOREW
LABEL L938
!     ptype.nofpar := nofpar; ptype.leaf := leaf; ptype.size := G.WordSize; isLeaf := leaf; parblksize := size
LINE 778
LDLW -12
LDLW 12
NCHECK 778
STNW 12
LDLC -13
LDLW 12
NCHECK 778
CONST 36
STIC
CONST 2
LDLW 12
NCHECK 778
STNW 32
LDLC -13
STGC OMSPP.isLeaf
LDLW -8
LDLW 16
STOREW
RETURN
END

PROC OMSPP.FormalType0 8 4 0x00110001
!   PROCEDURE FormalType0(VAR typ: B.Type; dim: INTEGER);
LINE 781
!     IF sym = S.ident THEN
LINE 784
LDGW OMSPP.sym
CONST 31
JNEQ L963
!       qualident(obj);
LINE 785
LOCAL -4
GLOBAL OMSPP.qualident
CALL 1
!       IF obj.class = B.Typ THEN typ := obj.type ELSE S.Mark("not a type"); typ := B.intType END
LINE 786
LDLW -4
NCHECK 786
LOADC
CONST 5
JNEQ L966
LDLW -4
NCHECK 786
LDNW 24
LDLW 12
STOREW
RETURN
LABEL L966
CONST 11
GLOBAL OMSPP.%50
GLOBAL OMSPS.Mark
CALL 2
LDGW OMSPB.intType
LDLW 12
STOREW
RETURN
LABEL L963
!     ELSIF sym = S.array THEN
LINE 787
LDGW OMSPP.sym
CONST 60
JNEQ L968
!       S.Get(sym); Check(S.of, "OF ?");
LINE 788
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
CONST 5
GLOBAL OMSPP.%83
CONST 48
GLOBAL OMSPP.Check
CALL 3
!       IF dim >= 1 THEN S.Mark("multi-dimensional open arrays not implemented") END ;
LINE 789
LDLW 16
CONST 1
JLT L971
CONST 46
GLOBAL OMSPP.%84
GLOBAL OMSPS.Mark
CALL 2
LABEL L971
!       NEW(typ); typ.form := B.Array; typ.len := -1; typ.size := 2*G.WordSize; 
LINE 790
CONST 44
GLOBAL OMSPB.TypeDesc
GLOBAL NEW
CALLW 2
LDLW 12
STOREW
CONST 12
LDLW 12
LOADW
NCHECK 790
STOREW
CONST -1
LDLW 12
LOADW
NCHECK 790
STNW 16
CONST 4
LDLW 12
LOADW
NCHECK 790
STNW 32
!       FormalType(typ.base, dim+1)
LINE 791
LDLW 16
INC
LDLW 12
LOADW
NCHECK 791
CONST 28
OFFSET
LDGW OMSPP.FormalType
NCHECK 791
CALL 2
RETURN
LABEL L968
!     ELSIF sym = S.procedure THEN
LINE 792
LDGW OMSPP.sym
CONST 66
JNEQ L973
!       S.Get(sym); B.OpenScope;
LINE 793
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPB.OpenScope
CALL 0
!       NEW(typ); typ.form := B.Proc; dmy := 0; ProcedureType(typ, dmy);
LINE 794
CONST 44
GLOBAL OMSPB.TypeDesc
GLOBAL NEW
CALLW 2
LDLW 12
STOREW
CONST 10
LDLW 12
LOADW
NCHECK 794
STOREW
CONST 0
STLW -8
LOCAL -8
LDLW 12
LOADW
GLOBAL OMSPP.ProcedureType
CALL 2
!       typ.dsc := B.topScope.next; InsertResultRegister(typ); B.CloseScope
LINE 795
LDGW OMSPB.topScope
NCHECK 795
LDNW 16
LDLW 12
LOADW
NCHECK 795
STNW 20
LDLW 12
GLOBAL OMSPP.InsertResultRegister
CALL 1
GLOBAL OMSPB.CloseScope
CALL 0
RETURN
LABEL L973
!     ELSE S.Mark("identifier expected"); typ := B.noType
LINE 796
CONST 20
GLOBAL OMSPP.%2
GLOBAL OMSPS.Mark
CALL 2
LDGW OMSPB.noType
LDLW 12
STOREW
RETURN
END

PROC OMSPP.CheckRecLevel 0 3 0
!   PROCEDURE CheckRecLevel(lev: INTEGER);
LINE 800
!     IF lev # 0 THEN S.Mark("ptr base must be global") END
LINE 802
LDLW 12
JEQZ L976
CONST 24
GLOBAL OMSPP.%85
GLOBAL OMSPS.Mark
CALL 2
LABEL L976
RETURN
END

PROC OMSPP.Type0 12 4 0x0010c001
!   PROCEDURE Type0(VAR type: B.Type);
LINE 805
!   BEGIN type := B.intType; (*sync*)
LINE 807
LDGW OMSPB.intType
LDLW 12
STOREW
!     IF (sym # S.ident) & (sym < S.array) THEN S.Mark("not a type");
LINE 808
LDGW OMSPP.sym
CONST 31
JEQ L979
LDGW OMSPP.sym
CONST 60
JGEQ L979
CONST 11
GLOBAL OMSPP.%50
GLOBAL OMSPS.Mark
CALL 2
LABEL L980
!       REPEAT S.Get(sym) UNTIL (sym = S.ident) OR (sym >= S.array)
LINE 809
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDGW OMSPP.sym
CONST 31
JEQ L979
LDGW OMSPP.sym
CONST 60
JLT L980
LABEL L979
!     IF sym = S.ident THEN
LINE 811
LDGW OMSPP.sym
CONST 31
JNEQ L986
!       qualident(obj);
LINE 812
LOCAL -8
GLOBAL OMSPP.qualident
CALL 1
!       IF obj.class = B.Typ THEN
LINE 813
LDLW -8
NCHECK 813
LOADC
CONST 5
JNEQ L989
!         IF (obj.type # NIL) & (obj.type.form # B.NoTyp) THEN type := obj.type END
LINE 814
LDLW -8
NCHECK 814
LDNW 24
JEQZ L984
LDLW -8
NCHECK 814
LDNW 24
NCHECK 814
LOADW
CONST 9
JEQ L984
LDLW -8
NCHECK 814
LDNW 24
LDLW 12
STOREW
RETURN
LABEL L989
!       ELSE S.Mark("not a type or undefined")
LINE 815
CONST 24
GLOBAL OMSPP.%86
GLOBAL OMSPS.Mark
CALL 2
RETURN
LABEL L986
!     ELSIF sym = S.array THEN S.Get(sym); ArrayType(type)
LINE 817
LDGW OMSPP.sym
CONST 60
JNEQ L995
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW 12
GLOBAL OMSPP.ArrayType
CALL 1
RETURN
LABEL L995
!     ELSIF sym = S.record THEN
LINE 818
LDGW OMSPP.sym
CONST 61
JNEQ L997
!       S.Get(sym); RecordType(type); Check(S.end, "no END")
LINE 819
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDLW 12
GLOBAL OMSPP.RecordType
CALL 1
CONST 7
GLOBAL OMSPP.%60
CONST 53
GLOBAL OMSPP.Check
CALL 3
RETURN
LABEL L997
!     ELSIF sym = S.pointer THEN
LINE 820
LDGW OMSPP.sym
CONST 62
JNEQ L999
!       S.Get(sym); Check(S.to, "no TO");
LINE 821
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
CONST 6
GLOBAL OMSPP.%63
CONST 50
GLOBAL OMSPP.Check
CALL 3
!       NEW(type);  type.form := B.Pointer; type.size := G.WordSize; type.base := B.intType;
LINE 822
CONST 44
GLOBAL OMSPB.TypeDesc
GLOBAL NEW
CALLW 2
LDLW 12
STOREW
CONST 7
LDLW 12
LOADW
NCHECK 822
STOREW
CONST 2
LDLW 12
LOADW
NCHECK 822
STNW 32
LDGW OMSPB.intType
LDLW 12
LOADW
NCHECK 822
STNW 28
!       IF sym = S.ident THEN
LINE 823
LDGW OMSPP.sym
CONST 31
JNEQ L1006
!         obj := B.thisObj();
LINE 824
GLOBAL OMSPB.thisObj
CALLW 0
STLW -8
!         IF obj # NIL THEN
LINE 825
LDLW -8
JEQZ L1009
!           IF (obj.class = B.Typ) & (obj.type.form IN {B.Record, B.NoTyp}) THEN
LINE 826
LDLW -8
NCHECK 826
LOADC
CONST 5
JNEQ L1012
CONST 1
LDLW -8
NCHECK 826
LDNW 24
NCHECK 826
LOADW
CONST 32
BOUND 826
LSL
CONST 8704
BITAND
JEQZ L1012
!             CheckRecLevel(obj.lev); type.base := obj.type
LINE 827
LDLW -8
NCHECK 827
LDNW 8
GLOBAL OMSPP.CheckRecLevel
CALL 1
LDLW -8
NCHECK 827
LDNW 24
LDLW 12
LOADW
NCHECK 827
STNW 28
JUMP L1007
LABEL L1012
!           ELSIF obj.class = B.Mod THEN S.Mark("external base type not implemented")
LINE 828
LDLW -8
NCHECK 828
LOADC
CONST 8
JNEQ L1015
CONST 35
GLOBAL OMSPP.%87
GLOBAL OMSPS.Mark
CALL 2
JUMP L1007
LABEL L1015
!           ELSE S.Mark("no valid base type")
LINE 829
CONST 19
GLOBAL OMSPP.%88
GLOBAL OMSPS.Mark
CALL 2
JUMP L1007
LABEL L1009
!         ELSE CheckRecLevel(level); (*enter into list of forward references to be fixed in Declarations*)
LINE 831
LDGW OMSPP.level
GLOBAL OMSPP.CheckRecLevel
CALL 1
!           NEW(ptbase); S.CopyId(ptbase.name); ptbase.type := type; ptbase.next := pbsList; pbsList := ptbase
LINE 832
CONST 40
GLOBAL OMSPP.PtrBaseDesc
GLOBAL NEW
CALLW 2
STLW -12
LDLW -12
NCHECK 832
GLOBAL OMSPS.CopyId
CALL 1
LDLW 12
LOADW
LDLW -12
NCHECK 832
STNW 32
LDGW OMSPP.pbsList
LDLW -12
NCHECK 832
STNW 36
LDLW -12
STGW OMSPP.pbsList
LABEL L1007
!         S.Get(sym)
LINE 834
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
RETURN
LABEL L1006
!       ELSE Type(type.base);
LINE 835
LDLW 12
LOADW
NCHECK 835
CONST 28
OFFSET
LDGW OMSPP.Type
NCHECK 835
CALL 1
!         IF (type.base.form # B.Record) OR (type.base.typobj = NIL) THEN S.Mark("must point to named record") END ;
LINE 836
LDLW 12
LOADW
NCHECK 836
LDNW 28
NCHECK 836
LOADW
CONST 13
JNEQ L1002
LDLW 12
LOADW
NCHECK 836
LDNW 28
NCHECK 836
LDNW 24
JNEQZ L1003
LABEL L1002
CONST 27
GLOBAL OMSPP.%89
GLOBAL OMSPS.Mark
CALL 2
LABEL L1003
!         CheckRecLevel(level)
LINE 837
LDGW OMSPP.level
GLOBAL OMSPP.CheckRecLevel
CALL 1
RETURN
LABEL L999
!     ELSIF sym = S.procedure THEN
LINE 839
LDGW OMSPP.sym
CONST 66
JNEQ L1017
!       S.Get(sym); B.OpenScope;
LINE 840
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPB.OpenScope
CALL 0
!       NEW(type); type.form := B.Proc; dmy := 0;
LINE 841
CONST 44
GLOBAL OMSPB.TypeDesc
GLOBAL NEW
CALLW 2
LDLW 12
STOREW
CONST 10
LDLW 12
LOADW
NCHECK 841
STOREW
CONST 0
STLW -4
!       ProcedureType(type, dmy); type.dsc := B.topScope.next; InsertResultRegister(type); B.CloseScope
LINE 842
LOCAL -4
LDLW 12
LOADW
GLOBAL OMSPP.ProcedureType
CALL 2
LDGW OMSPB.topScope
NCHECK 842
LDNW 16
LDLW 12
LOADW
NCHECK 842
STNW 20
LDLW 12
GLOBAL OMSPP.InsertResultRegister
CALL 1
GLOBAL OMSPB.CloseScope
CALL 0
RETURN
LABEL L1017
!     ELSE S.Mark("illegal type")
LINE 843
CONST 13
GLOBAL OMSPP.%90
GLOBAL OMSPS.Mark
CALL 2
LABEL L984
RETURN
END

PROC OMSPP.containsPointer 8 2 0x00110001
!   PROCEDURE containsPointer(type: B.Type): BOOLEAN;
LINE 847
!   BEGIN res := FALSE;
LINE 849
CONST 0
STLC -5
!     IF type.form = B.Pointer THEN res := TRUE
LINE 850
LDLW 12
NCHECK 850
LOADW
CONST 7
JNEQ L1020
CONST 1
STLC -5
JUMP L1031
LABEL L1020
!     ELSIF type.form = B.Record THEN obj := type.dsc;
LINE 851
LDLW 12
NCHECK 851
LOADW
CONST 13
JNEQ L1022
LDLW 12
NCHECK 851
LDNW 20
STLW -4
LABEL L1023
!       WHILE ~res & (obj # NIL) DO 
LINE 852
LDLC -5
JNEQZ L1031
LDLW -4
JEQZ L1031
!         IF obj.type.form = B.NilTyp (*hidden pointer*) THEN res := TRUE
LINE 853
LDLW -4
NCHECK 853
LDNW 24
NCHECK 853
LOADW
CONST 8
JNEQ L1028
CONST 1
STLC -5
JUMP L1026
LABEL L1028
!         ELSE res := containsPointer(obj.type)
LINE 854
LDLW -4
NCHECK 854
LDNW 24
GLOBAL OMSPP.containsPointer
CALLW 1
STLC -5
LABEL L1026
!         obj := obj.next
LINE 856
LDLW -4
NCHECK 856
LDNW 16
STLW -4
JUMP L1023
LABEL L1022
!     ELSIF type.form = B.Array THEN res := containsPointer(type.base)
LINE 858
LDLW 12
NCHECK 858
LOADW
CONST 12
JNEQ L1031
LDLW 12
NCHECK 858
LDNW 28
GLOBAL OMSPP.containsPointer
CALLW 1
STLC -5
LABEL L1031
!     RETURN res
LINE 860
LDLC -5
RETURN
END

PROC OMSPP.Declarations 100 5 0x00318631
!   PROCEDURE Declarations(VAR varsize: INTEGER; VAR haveinregs: BOOLEAN);
LINE 863
!   BEGIN (*sync*) pbsList := NIL; haveinregs := FALSE;
LINE 868
CONST 0
STGW OMSPP.pbsList
CONST 0
LDLW 16
STOREC
!     IF (sym < S.const) & (sym # S.end) & (sym # S.return) THEN S.Mark("declaration?");
LINE 869
LDGW OMSPP.sym
CONST 63
JGEQ L1034
LDGW OMSPP.sym
CONST 53
JEQ L1034
LDGW OMSPP.sym
CONST 58
JEQ L1034
CONST 13
GLOBAL OMSPP.%91
GLOBAL OMSPS.Mark
CALL 2
LABEL L1035
!       REPEAT S.Get(sym) UNTIL (sym >= S.const) OR (sym = S.end) OR (sym = S.return)
LINE 870
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDGW OMSPP.sym
CONST 63
JGEQ L1034
LDGW OMSPP.sym
CONST 53
JEQ L1034
LDGW OMSPP.sym
CONST 58
JNEQ L1035
LABEL L1034
!     IF sym = S.const THEN
LINE 872
LDGW OMSPP.sym
CONST 63
JNEQ L1043
!       S.Get(sym);
LINE 873
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LABEL L1044
!       WHILE sym = S.ident DO
LINE 874
LDGW OMSPP.sym
CONST 31
JNEQ L1043
!         S.CopyId(id); S.Get(sym); CheckExport(expo);
LINE 875
LOCAL -90
GLOBAL OMSPS.CopyId
CALL 1
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LOCAL -53
GLOBAL OMSPP.CheckExport
CALL 1
!         IF sym = S.eql THEN S.Get(sym) ELSE S.Mark("= ?") END;
LINE 876
LDGW OMSPP.sym
CONST 9
JNEQ L1049
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
JUMP L1047
LABEL L1049
CONST 4
GLOBAL OMSPP.%92
GLOBAL OMSPS.Mark
CALL 2
LABEL L1047
!         expression(x);
LINE 877
GLOBAL OMSPG.Item
LOCAL -44
LDGW OMSPP.expression
NCHECK 877
CALL 2
!         IF (x.type.form = B.String) & (G.Length(x) = 2) THEN G.StrToChar(x) END ;
LINE 878
LDLW -32
NCHECK 878
LOADW
CONST 11
JNEQ L1052
LOCAL -44
GLOBAL OMSPG.Length
CALLW 1
CONST 2
JNEQ L1052
GLOBAL OMSPG.Item
LOCAL -44
GLOBAL OMSPG.StrToChar
CALL 2
LABEL L1052
!         B.NewObj(obj, id, B.Const); obj.expo := expo;
LINE 879
CONST 1
LOCAL -90
LOCAL -4
GLOBAL OMSPB.NewObj
CALL 3
LDLC -53
LDLW -4
NCHECK 879
CONST 3
STIC
!         IF x.mode = B.Const THEN
LINE 880
LDLW -36
CONST 1
JNEQ L1056
!           IF x.type.form = B.String THEN ASSERT(x.a < 10000H); IF obj.expo THEN obj.exno := exno; INC(exno) END;
LINE 881
LDLW -32
NCHECK 881
LOADW
CONST 11
JNEQ L1059
LDLW -24
CONST 65536
JLT L1061
CONST 0
CONST 881
GLOBAL EASSERT
CALL 2
LABEL L1061
LDLW -4
NCHECK 881
CONST 3
LDIC
JEQZ L1064
LDGW OMSPP.exno
CONVNC
LDLW -4
NCHECK 881
CONST 1
STIC
LDGW OMSPP.exno
INC
STGW OMSPP.exno
LABEL L1064
!             obj.val := x.a + G.Length(x)*10000H; (*for string constants, encode address and length in obj.val*)
LINE 882
LDLW -24
LOCAL -44
GLOBAL OMSPG.Length
CALLW 1
CONST 65536
TIMES
PLUS
LDLW -4
NCHECK 882
STNW 60
JUMP L1057
LABEL L1059
!           ELSE obj.val := x.a
LINE 883
LDLW -24
LDLW -4
NCHECK 883
STNW 60
LABEL L1057
!           END; obj.type := x.type; obj.lev := x.c; obj.rdo := TRUE
LINE 884
LDLW -32
LDLW -4
NCHECK 884
STNW 24
LDLW -16
LDLW -4
NCHECK 884
STNW 8
CONST 1
LDLW -4
NCHECK 884
CONST 5
STIC
JUMP L1054
LABEL L1056
!         ELSE S.Mark("expression not constant"); obj.type := B.intType
LINE 885
CONST 24
GLOBAL OMSPP.%93
GLOBAL OMSPS.Mark
CALL 2
LDGW OMSPB.intType
LDLW -4
NCHECK 885
STNW 24
LABEL L1054
!         Check(S.semicolon, "; missing")
LINE 887
CONST 10
GLOBAL OMSPP.%94
CONST 52
GLOBAL OMSPP.Check
CALL 3
JUMP L1044
LABEL L1043
!     IF sym = S.type THEN
LINE 890
LDGW OMSPP.sym
CONST 64
JNEQ L1067
!       S.Get(sym);
LINE 891
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LABEL L1068
!       WHILE sym = S.ident DO
LINE 892
LDGW OMSPP.sym
CONST 31
JNEQ L1067
!         S.CopyId(id); S.Get(sym); CheckExport(expo);
LINE 893
LOCAL -90
GLOBAL OMSPS.CopyId
CALL 1
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LOCAL -53
GLOBAL OMSPP.CheckExport
CALL 1
!         IF sym = S.eql THEN S.Get(sym) ELSE S.Mark("=?") END ;
LINE 894
LDGW OMSPP.sym
CONST 9
JNEQ L1073
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
JUMP L1071
LABEL L1073
CONST 3
GLOBAL OMSPP.%95
GLOBAL OMSPS.Mark
CALL 2
LABEL L1071
!         Type(tp);
LINE 895
LOCAL -48
LDGW OMSPP.Type
NCHECK 895
CALL 1
!         B.NewObj(obj, id, B.Typ); obj.type := tp; obj.expo := expo; obj.lev := level;
LINE 896
CONST 5
LOCAL -90
LOCAL -4
GLOBAL OMSPB.NewObj
CALL 3
LDLW -48
LDLW -4
NCHECK 896
STNW 24
LDLC -53
LDLW -4
NCHECK 896
CONST 3
STIC
LDGW OMSPP.level
LDLW -4
NCHECK 896
STNW 8
!         IF tp.typobj = NIL THEN tp.typobj := obj END ;
LINE 897
LDLW -48
NCHECK 897
LDNW 24
JNEQZ L1076
LDLW -4
LDLW -48
NCHECK 897
STNW 24
LABEL L1076
!         IF expo & (obj.type.form = B.Record) THEN obj.exno := exno; INC(exno) ELSE obj.exno := 0 END ;
LINE 898
LDLC -53
JEQZ L1079
LDLW -4
NCHECK 898
LDNW 24
NCHECK 898
LOADW
CONST 13
JNEQ L1079
LDGW OMSPP.exno
CONVNC
LDLW -4
NCHECK 898
CONST 1
STIC
LDGW OMSPP.exno
INC
STGW OMSPP.exno
JUMP L1077
LABEL L1079
CONST 0
LDLW -4
NCHECK 898
CONST 1
STIC
LABEL L1077
!         IF tp.form = B.Record THEN
LINE 899
LDLW -48
NCHECK 899
LOADW
CONST 13
JNEQ L1083
!           ptbase := pbsList;  (*check whether this is base of a pointer type; search and fixup*)
LINE 900
LDGW OMSPP.pbsList
STLW -52
LABEL L1084
!           WHILE ptbase # NIL DO
LINE 901
LDLW -52
JEQZ L1086
!             IF obj.name = ptbase.name THEN ptbase.type.base := obj.type END ;
LINE 902
CONST 32
LDLW -52
NCHECK 902
LDLW -4
NCHECK 902
CONST 28
OFFSET
CONST 32
SWAP
GLOBAL COMPARE
CALLW 4
JNEQZ L1089
LDLW -4
NCHECK 902
LDNW 24
LDLW -52
NCHECK 902
LDNW 32
NCHECK 902
STNW 28
LABEL L1089
!             ptbase := ptbase.next
LINE 903
LDLW -52
NCHECK 903
LDNW 36
STLW -52
JUMP L1084
LABEL L1086
!           IF level = 0 THEN G.BuildTD(tp) END    (*type descriptor; len used as its address*)
LINE 905
LDGW OMSPP.level
JNEQZ L1083
LDLW -48
GLOBAL OMSPG.BuildTD
CALL 1
LABEL L1083
!         Check(S.semicolon, "; missing")
LINE 907
CONST 10
GLOBAL OMSPP.%94
CONST 52
GLOBAL OMSPP.Check
CALL 3
JUMP L1068
LABEL L1067
!     IF sym = S.var THEN
LINE 910
LDGW OMSPP.sym
CONST 65
JNEQ L1095
!       S.Get(sym);
LINE 911
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LABEL L1096
!       WHILE sym = S.ident DO inreg := FALSE; onetimeinit := FALSE;
LINE 912
LDGW OMSPP.sym
CONST 31
JNEQ L1095
CONST 0
STLC -57
CONST 0
STLC -58
!         IdentList(B.Var, first); Type(tp);
LINE 913
LOCAL -8
CONST 2
GLOBAL OMSPP.IdentList
CALL 2
LOCAL -48
LDGW OMSPP.Type
NCHECK 913
CALL 1
!         IF sym = S.times THEN
LINE 914
LDGW OMSPP.sym
CONST 1
JNEQ L1101
!           IF level # 0 THEN haveinregs := TRUE; inreg := TRUE; G.SetAllocationMode(G.Register)
LINE 915
LDGW OMSPP.level
JEQZ L1104
CONST 1
LDLW 16
STOREC
CONST 1
STLC -57
CONST 1
ALIGNC
GLOBAL OMSPG.SetAllocationMode
CALL 1
JUMP L1102
LABEL L1104
!           ELSE S.Mark("remove asterisk")
LINE 916
CONST 16
GLOBAL OMSPP.%10
GLOBAL OMSPS.Mark
CALL 2
LABEL L1102
!           END; S.Get(sym) 
LINE 917
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LABEL L1101
!         IF sym = S.minus THEN
LINE 919
LDGW OMSPP.sym
CONST 7
JNEQ L1107
!           IF level = 0 THEN onetimeinit := TRUE
LINE 920
LDGW OMSPP.level
JNEQZ L1110
CONST 1
STLC -58
JUMP L1108
LABEL L1110
!           ELSE S.Mark("remove hyphen")
LINE 921
CONST 14
GLOBAL OMSPP.%96
GLOBAL OMSPS.Mark
CALL 2
LABEL L1108
!           END; S.Get(sym) 
LINE 922
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LABEL L1107
!         IF level = 0 THEN unsafe := FALSE ELSE unsafe := containsPointer(tp) END; (*check for unsafe pointers*)
LINE 924
LDGW OMSPP.level
JNEQZ L1113
CONST 0
STLC -54
JUMP L1111
LABEL L1113
LDLW -48
GLOBAL OMSPP.containsPointer
CALLW 1
STLC -54
LABEL L1111
!         obj := first; umm := FALSE; umf := FALSE;
LINE 925
LDLW -8
STLW -4
CONST 0
STLC -55
CONST 0
STLC -56
LABEL L1114
!         WHILE obj # NIL DO
LINE 926
LDLW -4
JEQZ L1116
!           obj.type := tp; obj.lev := level;
LINE 927
LDLW -48
LDLW -4
NCHECK 927
STNW 24
LDGW OMSPP.level
LDLW -4
NCHECK 927
STNW 8
!           IF onetimeinit THEN obj.rdo := TRUE; obj.class := B.StoredConst;
LINE 928
LDLC -58
JEQZ L1140
CONST 1
LDLW -4
NCHECK 928
CONST 5
STIC
CONST 9
LDLW -4
NCHECK 928
STOREC
!             obj.register := 0FFH; G.MakeConstObject(obj);
LINE 929
CONST 255
LDLW -4
NCHECK 929
CONST 2
STIC
LOCAL -4
GLOBAL OMSPG.MakeConstObject
CALL 1
JUMP L1130
LABEL L1140
!             IF unsafe & ~obj.unsafe THEN umm := TRUE END;
LINE 931
LDLC -54
JEQZ L1120
LDLW -4
NCHECK 931
CONST 4
LDIC
JNEQZ L1120
CONST 1
STLC -55
LABEL L1120
!             IF ~unsafe & obj.unsafe THEN umf := TRUE END;
LINE 932
LDLC -54
JNEQZ L1124
LDLW -4
NCHECK 932
CONST 4
LDIC
JEQZ L1124
CONST 1
STLC -56
LABEL L1124
!             IF inreg & (tp.size > 4) THEN S.Mark("reg alloc forbidden"); inreg := FALSE END;
LINE 933
LDLC -57
JEQZ L1128
LDLW -48
NCHECK 933
LDNW 32
CONST 4
JLEQ L1128
CONST 20
GLOBAL OMSPP.%97
GLOBAL OMSPS.Mark
CALL 2
CONST 0
STLC -57
LABEL L1128
!             IF inreg THEN obj.register := G.AllocR(); nbregs := tp.size DIV G.WordSize;
LINE 934
LDLC -57
JEQZ L1135
GLOBAL OMSPG.AllocR
CALLW 0
CONVNC
LDLW -4
NCHECK 934
CONST 2
STIC
LDLW -48
NCHECK 934
LDNW 32
CONST 2
DIV
STLW -96
LABEL L1136
!               WHILE nbregs > 1 DO dummy := G.AllocR(); DEC(nbregs) END
LINE 935
LDLW -96
CONST 1
JLEQ L1130
GLOBAL OMSPG.AllocR
CALLW 0
STLW -100
DECL -96
JUMP L1136
LABEL L1135
!             ELSE IF tp.size > 1 THEN varsize := (varsize + (G.WordSize - 1)) DIV G.WordSize * G.WordSize (*align*) END;
LINE 936
LDLW -48
NCHECK 936
LDNW 32
CONST 1
JLEQ L1133
LDLW 12
LOADW
INC
CONST 2
DIV
CONST 2
TIMES
LDLW 12
STOREW
LABEL L1133
!               obj.register := 0FFH; obj.val := varsize; INC(varsize, tp.size)
LINE 937
CONST 255
LDLW -4
NCHECK 937
CONST 2
STIC
LDLW 12
LOADW
LDLW -4
NCHECK 937
STNW 60
LDLW 12
DUP 0
LOADW
LDLW -48
NCHECK 937
LDNW 32
PLUS
SWAP
STOREW
LABEL L1130
!           IF obj.expo THEN obj.exno := exno; INC(exno) END;
LINE 940
LDLW -4
NCHECK 940
CONST 3
LDIC
JEQZ L1143
LDGW OMSPP.exno
CONVNC
LDLW -4
NCHECK 940
CONST 1
STIC
LDGW OMSPP.exno
INC
STGW OMSPP.exno
LABEL L1143
!           obj := obj.next
LINE 941
LDLW -4
NCHECK 941
LDNW 16
STLW -4
JUMP L1114
LABEL L1116
!         IF umm THEN S.Mark("mark unsafe vars with an exclamation mark") 
LINE 943
LDLC -55
JEQZ L1146
CONST 42
GLOBAL OMSPP.%98
GLOBAL OMSPS.Mark
CALL 2
JUMP L1148
LABEL L1146
!         ELSIF umf THEN S.Mark("remove exclamation mark") END;
LINE 944
LDLC -56
JEQZ L1148
CONST 24
GLOBAL OMSPP.%11
GLOBAL OMSPS.Mark
CALL 2
LABEL L1148
!         Check(S.semicolon, "; missing")
LINE 945
CONST 10
GLOBAL OMSPP.%94
CONST 52
GLOBAL OMSPP.Check
CALL 3
JUMP L1096
LABEL L1095
!     varsize := (varsize + (G.WordSize - 1)) DIV G.WordSize * G.WordSize;
LINE 948
LDLW 12
LOADW
INC
CONST 2
DIV
CONST 2
TIMES
LDLW 12
STOREW
!     ptbase := pbsList;
LINE 949
LDGW OMSPP.pbsList
STLW -52
LABEL L1149
!     WHILE ptbase # NIL DO
LINE 950
LDLW -52
JEQZ L1151
!       IF ptbase.type.base.form = B.Int THEN S.Mark("undefined pointer base of") END ;
LINE 951
LDLW -52
NCHECK 951
LDNW 32
NCHECK 951
LDNW 28
NCHECK 951
LOADW
CONST 4
JNEQ L1154
CONST 26
GLOBAL OMSPP.%99
GLOBAL OMSPS.Mark
CALL 2
LABEL L1154
!       ptbase := ptbase.next
LINE 952
LDLW -52
NCHECK 952
LDNW 36
STLW -52
JUMP L1149
LABEL L1151
!     IF (sym >= S.const) & (sym <= S.var) THEN S.Mark("declaration in bad order") END
LINE 954
LDGW OMSPP.sym
CONST 63
JLT L1157
LDGW OMSPP.sym
CONST 65
JGT L1157
CONST 25
GLOBAL OMSPP.%100
GLOBAL OMSPS.Mark
CALL 2
LABEL L1157
RETURN
END

PROC OMSPP.ProcedureDecl 148 7 OMSPP.ProcedureDecl.%map
!   PROCEDURE ProcedureDecl;
LINE 957
!   BEGIN (* ProcedureDecl *) int := FALSE; L := 0; S.Get(sym);
LINE 966
CONST 0
STLC -129
CONST 0
STLW -128
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!     IF sym = S.times THEN IF level # 0 THEN S.Mark("interrupt handler must be global") END;
LINE 967
LDGW OMSPP.sym
CONST 1
JNEQ L1161
LDGW OMSPP.level
JEQZ L1164
CONST 33
GLOBAL OMSPP.%101
GLOBAL OMSPS.Mark
CALL 2
LABEL L1164
!       int := TRUE; S.Get(sym); IF sym # S.lparen THEN S.Mark("no (") END;
LINE 968
CONST 1
STLC -129
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
LDGW OMSPP.sym
CONST 28
JEQ L1167
CONST 5
GLOBAL OMSPP.%15
GLOBAL OMSPS.Mark
CALL 2
LABEL L1167
!       REPEAT S.Get(sym); expression(x); CheckInt(x); CheckConst(x); v[L] := x.a; INC(L); UNTIL sym # S.comma;
LINE 969
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -80
LDGW OMSPP.expression
NCHECK 969
CALL 2
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPP.CheckInt
CALL 2
GLOBAL OMSPG.Item
LOCAL -80
GLOBAL OMSPP.CheckConst
CALL 2
LDLW -60
CONVNC
LOCAL -148
LDLW -128
CONST 8
BOUND 969
OFFSET
STOREC
INCL -128
LDGW OMSPP.sym
CONST 40
JEQ L1167
!       Check(S.rparen, "no )")
LINE 970
CONST 5
GLOBAL OMSPP.%16
CONST 44
GLOBAL OMSPP.Check
CALL 3
LABEL L1161
!     END; isInt := int;
LINE 971
LDLC -129
STGC OMSPP.isInt
!     IF sym = S.lbrace THEN S.Get(sym); set(sr); CheckConst(sr); Check(S.rbrace, "no }"); savedregs := SYSTEM.VAL(SET, sr.a)
LINE 972
LDGW OMSPP.sym
CONST 30
JNEQ L1172
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -116
GLOBAL OMSPP.set
CALL 2
GLOBAL OMSPG.Item
LOCAL -116
GLOBAL OMSPP.CheckConst
CALL 2
CONST 5
GLOBAL OMSPP.%43
CONST 46
GLOBAL OMSPP.Check
CALL 3
LDLW -96
STLW -140
JUMP L1170
LABEL L1172
!     ELSE savedregs := {}
LINE 973
CONST 0
STLW -140
LABEL L1170
!     IF sym = S.ident THEN
LINE 975
LDGW OMSPP.sym
CONST 31
JNEQ L1175
!       S.CopyId(procid); S.Get(sym); B.NewObj(proc, S.id, B.Const);
LINE 976
LOCAL -44
GLOBAL OMSPS.CopyId
CALL 1
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
CONST 1
GLOBAL OMSPS.id
LOCAL -4
GLOBAL OMSPB.NewObj
CALL 3
!       parblksize := 0; NEW(type);
LINE 977
CONST 0
STLW -124
CONST 44
GLOBAL OMSPB.TypeDesc
GLOBAL NEW
CALLW 2
STLW -12
!       IF int THEN type.form := B.Handler; WHILE L > 0 DO DEC(L); G.SetVector(v[L], proc) END
LINE 978
LDLC -129
JEQZ L1178
CONST 15
LDLW -12
NCHECK 978
STOREW
LABEL L1179
LDLW -128
JLEQZ L1176
DECL -128
LOCAL -4
LOCAL -148
LDLW -128
CONST 8
BOUND 978
OFFSET
LOADC
GLOBAL OMSPG.SetVector
CALL 2
JUMP L1179
LABEL L1178
!       ELSE type.form := B.Proc 
LINE 979
CONST 10
LDLW -12
NCHECK 979
STOREW
LABEL L1176
!       G.SetRIU({}); G.SetPRU({}); proc.type := type; proc.val := -1; proc.lev := level; 
LINE 981
CONST 0
GLOBAL OMSPG.SetRIU
CALL 1
CONST 0
GLOBAL OMSPG.SetPRU
CALL 1
LDLW -12
LDLW -4
NCHECK 981
STNW 24
CONST -1
LDLW -4
NCHECK 981
STNW 60
LDGW OMSPP.level
LDLW -4
NCHECK 981
STNW 8
!       CheckExport(proc.expo);
LINE 982
LDLW -4
NCHECK 982
CONST 3
OFFSET
GLOBAL OMSPP.CheckExport
CALL 1
!       IF int & proc.expo THEN proc.expo := FALSE; S.Mark("remove asterisk") END;
LINE 983
LDLC -129
JEQZ L1184
LDLW -4
NCHECK 983
CONST 3
LDIC
JEQZ L1184
CONST 0
LDLW -4
NCHECK 983
CONST 3
STIC
CONST 16
GLOBAL OMSPP.%10
GLOBAL OMSPS.Mark
CALL 2
LABEL L1184
!       IF proc.expo THEN proc.exno := exno; INC(exno) END ;
LINE 984
LDLW -4
NCHECK 984
CONST 3
LDIC
JEQZ L1188
LDGW OMSPP.exno
CONVNC
LDLW -4
NCHECK 984
CONST 1
STIC
LDGW OMSPP.exno
INC
STGW OMSPP.exno
LABEL L1188
!       B.OpenScope; INC(level); type.base := B.noType;
LINE 985
GLOBAL OMSPB.OpenScope
CALL 0
LDGW OMSPP.level
INC
STGW OMSPP.level
LDGW OMSPB.noType
LDLW -12
NCHECK 985
STNW 28
!       ProcedureType(type, parblksize); (*formal parameter list*)
LINE 986
LOCAL -124
LDLW -12
GLOBAL OMSPP.ProcedureType
CALL 2
!       IF int & (parblksize # 0) THEN S.Mark("remove params") END;
LINE 987
LDLC -129
JEQZ L1191
LDLW -124
JEQZ L1191
CONST 14
GLOBAL OMSPP.%102
GLOBAL OMSPS.Mark
CALL 2
LABEL L1191
!       Check(S.semicolon, "no ;");
LINE 988
CONST 5
GLOBAL OMSPP.%103
CONST 52
GLOBAL OMSPP.Check
CALL 3
!       locblksize := 0; (*local variables are located immediately after return address/status register copy*)
LINE 989
CONST 0
STLW -120
!       Declarations(locblksize, haveinregs); IF haveinregs THEN type.leaf := TRUE; isLeaf := TRUE END;
LINE 990
LOCAL -130
LOCAL -120
GLOBAL OMSPP.Declarations
CALL 2
LDLC -130
JEQZ L1195
CONST 1
LDLW -12
NCHECK 990
CONST 36
STIC
CONST 1
STGC OMSPP.isLeaf
LABEL L1195
!       loc := B.topScope.next; L := 0; (*fix .val offsets of parameters*)
LINE 996
LDGW OMSPB.topScope
NCHECK 996
LDNW 16
STLW -8
CONST 0
STLW -128
LABEL L1196
!       WHILE loc # NIL DO (*fix .val offsets of parameters and local variables*)
LINE 997
LDLW -8
JEQZ L1198
!         IF (loc.class IN {B.Var, B.Par}) & (loc.register = 0FFH) THEN (*stored in stack*)
LINE 998
CONST 1
LDLW -8
NCHECK 998
LOADC
CONST 32
BOUND 998
LSL
CONST 12
BITAND
JEQZ L1201
LDLW -8
NCHECK 998
CONST 2
LDIC
CONST 255
JNEQ L1201
!           IF L < type.nofpar THEN (*parameter*) INC(loc.val, parblksize)
LINE 999
LDLW -128
LDLW -12
NCHECK 999
LDNW 12
JGEQ L1204
LDLW -8
NCHECK 999
CONST 60
OFFSET
DUP 0
LOADW
LDLW -124
PLUS
SWAP
STOREW
JUMP L1201
LABEL L1204
!           ELSE (*local variable*) DEC(loc.val, locblksize)
LINE 1000
LDLW -8
NCHECK 1000
CONST 60
OFFSET
DUP 0
LOADW
LDLW -120
MINUS
SWAP
STOREW
LABEL L1201
!         loc := loc.next; INC(L)
LINE 1003
LDLW -8
NCHECK 1003
LDNW 16
STLW -8
INCL -128
JUMP L1196
LABEL L1198
!       proc.val := G.Here(); 
LINE 1006
GLOBAL OMSPG.Here
CALLW 0
LDLW -4
NCHECK 1006
STNW 60
!       proc.type.dsc := B.topScope.next;
LINE 1007
LDGW OMSPB.topScope
NCHECK 1007
LDNW 16
LDLW -4
NCHECK 1007
LDNW 24
NCHECK 1007
STNW 20
!       InsertResultRegister(type);
LINE 1008
LOCAL -12
GLOBAL OMSPP.InsertResultRegister
CALL 1
!       IF sym = S.procedure THEN
LINE 1010
LDGW OMSPP.sym
CONST 66
JNEQ L1208
!         riu := G.RIU; proc.type.ur := G.PRU; L := 0; G.FJump(L);
LINE 1011
LDGW OMSPG.RIU
STLW -136
LDGW OMSPG.PRU
LDLW -4
NCHECK 1011
LDNW 24
NCHECK 1011
STNW 40
CONST 0
STLW -128
LOCAL -128
GLOBAL OMSPG.FJump
CALL 1
LABEL L1209
!         REPEAT ProcedureDecl; Check(S.semicolon, "no ;") UNTIL sym # S.procedure;
LINE 1012
GLOBAL OMSPP.ProcedureDecl
CALL 0
CONST 5
GLOBAL OMSPP.%103
CONST 52
GLOBAL OMSPP.Check
CALL 3
LDGW OMSPP.sym
CONST 66
JEQ L1209
!         G.FixOne(L); proc.val := G.Here(); proc.type.dsc := B.topScope.next;
LINE 1013
LDLW -128
GLOBAL OMSPG.FixOne
CALL 1
GLOBAL OMSPG.Here
CALLW 0
LDLW -4
NCHECK 1013
STNW 60
LDGW OMSPB.topScope
NCHECK 1013
LDNW 16
LDLW -4
NCHECK 1013
LDNW 24
NCHECK 1013
STNW 20
!         G.SetRIU(riu); G.SetPRU(proc.type.ur); (*restore current procedure RIU and PRU*)
LINE 1014
LDLW -136
GLOBAL OMSPG.SetRIU
CALL 1
LDLW -4
NCHECK 1014
LDNW 24
NCHECK 1014
LDNW 40
GLOBAL OMSPG.SetPRU
CALL 1
!         isInt := int
LINE 1015
LDLC -129
STGC OMSPP.isInt
LABEL L1208
!       IF isLeaf THEN G.SetAllocationMode(G.Register) ELSE G.SetAllocationMode(G.Stack) END;
LINE 1017
LDGC OMSPP.isLeaf
JEQZ L1213
CONST 1
ALIGNC
GLOBAL OMSPG.SetAllocationMode
CALL 1
JUMP L1211
LABEL L1213
CONST 0
ALIGNC
GLOBAL OMSPG.SetAllocationMode
CALL 1
LABEL L1211
!       IF int THEN G.LimitRegisters(savedregs) END;
LINE 1018
LDLC -129
JEQZ L1216
LDLW -140
GLOBAL OMSPG.LimitRegisters
CALL 1
LABEL L1216
!       G.Enter(locblksize, int, savedregs);
LINE 1019
LDLW -140
LDLC -129
ALIGNC
LDLW -120
GLOBAL OMSPG.Enter
CALL 3
!       IF sym = S.begin THEN S.Get(sym); StatSequence END;
LINE 1020
LDGW OMSPP.sym
CONST 67
JNEQ L1219
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPP.StatSequence
CALL 0
LABEL L1219
!       IF sym = S.return THEN
LINE 1021
LDGW OMSPP.sym
CONST 58
JNEQ L1222
!         S.Get(sym); expression(x);
LINE 1022
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPG.Item
LOCAL -80
LDGW OMSPP.expression
NCHECK 1022
CALL 2
!         IF type.base = B.noType THEN S.Mark("this is not a function")
LINE 1023
LDLW -12
NCHECK 1023
LDNW 28
LDGW OMSPB.noType
JNEQ L1225
CONST 23
GLOBAL OMSPP.%104
GLOBAL OMSPS.Mark
CALL 2
JUMP L1229
LABEL L1225
!         ELSIF ~CompTypes(type.base, x.type, FALSE) THEN S.Mark("wrong result type")
LINE 1024
CONST 0
ALIGNC
LDLW -68
LDLW -12
NCHECK 1024
LDNW 28
GLOBAL OMSPP.CompTypes
CALLW 3
JNEQZ L1229
CONST 18
GLOBAL OMSPP.%105
GLOBAL OMSPS.Mark
CALL 2
JUMP L1229
LABEL L1222
!       ELSIF type.base.form # B.NoTyp THEN
LINE 1026
LDLW -12
NCHECK 1026
LDNW 28
NCHECK 1026
LOADW
CONST 9
JEQ L1229
!         S.Mark("function without result"); type.base := B.noType
LINE 1027
CONST 24
GLOBAL OMSPP.%106
GLOBAL OMSPS.Mark
CALL 2
LDGW OMSPB.noType
LDLW -12
NCHECK 1027
STNW 28
LABEL L1229
!       G.Return(type.base.form, x, locblksize, int, savedregs);
LINE 1029
LDLW -140
LDLC -129
ALIGNC
LDLW -120
GLOBAL OMSPG.Item
LOCAL -80
LDLW -12
NCHECK 1029
LDNW 28
NCHECK 1029
LOADW
GLOBAL OMSPG.Return
CALL 6
!       proc.type.ur := G.PRU;
LINE 1030
LDGW OMSPG.PRU
LDLW -4
NCHECK 1030
LDNW 24
NCHECK 1030
STNW 40
!       B.CloseScope; DEC(level); Check(S.end, "no END");
LINE 1031
GLOBAL OMSPB.CloseScope
CALL 0
LDGW OMSPP.level
DEC
STGW OMSPP.level
CONST 7
GLOBAL OMSPP.%60
CONST 53
GLOBAL OMSPP.Check
CALL 3
!       isLeaf := FALSE; isInt := FALSE;
LINE 1032
CONST 0
STGC OMSPP.isLeaf
CONST 0
STGC OMSPP.isInt
!       IF sym = S.ident THEN
LINE 1033
LDGW OMSPP.sym
CONST 31
JNEQ L1232
!         IF S.id # procid THEN S.Mark("no match") END ;
LINE 1034
CONST 32
LOCAL -44
CONST 32
GLOBAL OMSPS.id
GLOBAL COMPARE
CALLW 4
JEQZ L1235
CONST 9
GLOBAL OMSPP.%107
GLOBAL OMSPS.Mark
CALL 2
LABEL L1235
!         S.Get(sym)
LINE 1035
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
RETURN
LABEL L1232
!       ELSE S.Mark("no proc id")
LINE 1036
CONST 11
GLOBAL OMSPP.%108
GLOBAL OMSPS.Mark
CALL 2
RETURN
LABEL L1175
!     ELSE S.Mark("proc id expected")
LINE 1038
CONST 17
GLOBAL OMSPP.%109
GLOBAL OMSPS.Mark
CALL 2
RETURN
END

PROC OMSPP.Import 64 3 0
!   PROCEDURE Import;
LINE 1042
!     IF sym = S.ident THEN
LINE 1045
LDGW OMSPP.sym
CONST 31
JNEQ L1238
!       S.CopyId(impid); S.Get(sym);
LINE 1046
LOCAL -32
GLOBAL OMSPS.CopyId
CALL 1
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!       IF sym = S.becomes THEN
LINE 1047
LDGW OMSPP.sym
CONST 42
JNEQ L1241
!         S.Get(sym);
LINE 1048
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!         IF sym = S.ident THEN S.CopyId(impid1); S.Get(sym)
LINE 1049
LDGW OMSPP.sym
CONST 31
JNEQ L1244
LOCAL -64
GLOBAL OMSPS.CopyId
CALL 1
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
JUMP L1239
LABEL L1244
!         ELSE S.Mark("id expected"); impid1 := impid
LINE 1050
CONST 12
GLOBAL OMSPP.%110
GLOBAL OMSPS.Mark
CALL 2
LOCAL -64
LOCAL -32
CONST 32
FIXCOPY
JUMP L1239
LABEL L1241
!       ELSE impid1 := impid
LINE 1052
LOCAL -64
LOCAL -32
CONST 32
FIXCOPY
LABEL L1239
!       END; G.CheckRTImport(impid1);
LINE 1053
LOCAL -64
GLOBAL OMSPG.CheckRTImport
CALL 1
!       B.Import(impid, impid1)
LINE 1054
LOCAL -64
LOCAL -32
GLOBAL OMSPB.Import
CALL 2
RETURN
LABEL L1238
!     ELSE S.Mark("id expected")
LINE 1055
CONST 12
GLOBAL OMSPP.%110
GLOBAL OMSPS.Mark
CALL 2
RETURN
END

PROC OMSPP.Module 12 5 0
!   PROCEDURE Module;
LINE 1059
!   BEGIN isLeaf := FALSE; isInt := FALSE; Texts.WriteString(W, "  compiling "); S.Get(sym);
LINE 1061
CONST 0
STGC OMSPP.isLeaf
CONST 0
STGC OMSPP.isInt
CONST 13
GLOBAL OMSPP.%111
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteString
CALL 4
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!     IF sym = S.module THEN S.Get(sym);
LINE 1062
LDGW OMSPP.sym
CONST 69
JNEQ L1247
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!       IF sym = S.times THEN codeseg := 1 (*execute from RAM*); Texts.Write(W, "*"); S.Get(sym)
LINE 1063
LDGW OMSPP.sym
CONST 1
JNEQ L1250
CONST 1
STGC OMSPP.codeseg
CONST 42
ALIGNC
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.Write
CALL 3
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
JUMP L1248
LABEL L1250
!       ELSE codeseg := 0 (*execute from Flash*) END;
LINE 1064
CONST 0
STGC OMSPP.codeseg
LABEL L1248
!       G.Open; dc := 0;
LINE 1065
GLOBAL OMSPG.Open
CALL 0
CONST 0
STGW OMSPP.dc
!       initmode := FALSE;
LINE 1066
CONST 0
STGC OMSPP.initmode
!       B.Init; B.OpenScope;
LINE 1067
GLOBAL OMSPB.Init
CALL 0
GLOBAL OMSPB.OpenScope
CALL 0
!       IF sym = S.ident THEN
LINE 1068
LDGW OMSPP.sym
CONST 31
JNEQ L1253
!         S.CopyId(modid); S.Get(sym);
LINE 1069
GLOBAL OMSPP.modid
GLOBAL OMSPS.CopyId
CALL 1
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
!         Texts.WriteString(W, modid); Texts.Append(Oberon.Log, W.buf)
LINE 1070
CONST 32
GLOBAL OMSPP.modid
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteString
CALL 4
LDGW OMSPP.W
LDGW Oberon.Log
GLOBAL Texts.Append
CALL 2
JUMP L1251
LABEL L1253
!       ELSE S.Mark("identifier expected")
LINE 1071
CONST 20
GLOBAL OMSPP.%2
GLOBAL OMSPS.Mark
CALL 2
LABEL L1251
!       Check(S.semicolon, "no ;"); level := 0; exno := 1; key := 0;
LINE 1073
CONST 5
GLOBAL OMSPP.%103
CONST 52
GLOBAL OMSPP.Check
CALL 3
CONST 0
STGW OMSPP.level
CONST 1
STGW OMSPP.exno
CONST 0
STLW -4
!       IF sym = S.import THEN
LINE 1074
LDGW OMSPP.sym
CONST 68
JNEQ L1256
!         S.Get(sym); Import;
LINE 1075
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPP.Import
CALL 0
LABEL L1257
!         WHILE sym = S.comma DO S.Get(sym); Import END ;
LINE 1076
LDGW OMSPP.sym
CONST 40
JNEQ L1259
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPP.Import
CALL 0
JUMP L1257
LABEL L1259
!         Check(S.semicolon, "; missing")
LINE 1077
CONST 10
GLOBAL OMSPP.%94
CONST 52
GLOBAL OMSPP.Check
CALL 3
LABEL L1256
!       Declarations(dc, dmy); G.SetDataSize((dc + (G.WordSize - 1)) DIV G.WordSize * G.WordSize);
LINE 1079
LOCAL -9
GLOBAL OMSPP.dc
GLOBAL OMSPP.Declarations
CALL 2
LDGW OMSPP.dc
INC
CONST 2
DIV
CONST 2
TIMES
GLOBAL OMSPG.SetDataSize
CALL 1
LABEL L1260
!       WHILE sym = S.procedure DO ProcedureDecl; Check(S.semicolon, "no ;") END ;
LINE 1080
LDGW OMSPP.sym
CONST 66
JNEQ L1262
GLOBAL OMSPP.ProcedureDecl
CALL 0
CONST 5
GLOBAL OMSPP.%103
CONST 52
GLOBAL OMSPP.Check
CALL 3
JUMP L1260
LABEL L1262
!       initmode := TRUE;
LINE 1081
CONST 1
STGC OMSPP.initmode
!       G.Header;
LINE 1082
GLOBAL OMSPG.Header
CALL 0
!       IF sym = S.begin THEN S.Get(sym); StatSequence END ;
LINE 1083
LDGW OMSPP.sym
CONST 67
JNEQ L1265
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
GLOBAL OMSPP.StatSequence
CALL 0
LABEL L1265
!       Check(S.end, "no END");
LINE 1084
CONST 7
GLOBAL OMSPP.%60
CONST 53
GLOBAL OMSPP.Check
CALL 3
!       IF sym = S.ident THEN
LINE 1085
LDGW OMSPP.sym
CONST 31
JNEQ L1268
!         IF S.id # modid THEN S.Mark("no match") END ;
LINE 1086
CONST 32
GLOBAL OMSPP.modid
CONST 32
GLOBAL OMSPS.id
GLOBAL COMPARE
CALLW 4
JEQZ L1271
CONST 9
GLOBAL OMSPP.%107
GLOBAL OMSPS.Mark
CALL 2
LABEL L1271
!         S.Get(sym)
LINE 1087
GLOBAL OMSPP.sym
GLOBAL OMSPS.Get
CALL 1
JUMP L1266
LABEL L1268
!       ELSE S.Mark("identifier missing")
LINE 1088
CONST 19
GLOBAL OMSPP.%112
GLOBAL OMSPS.Mark
CALL 2
LABEL L1266
!       IF sym # S.period THEN S.Mark("period missing") END ;
LINE 1090
LDGW OMSPP.sym
CONST 18
JEQ L1274
CONST 15
GLOBAL OMSPP.%113
GLOBAL OMSPS.Mark
CALL 2
LABEL L1274
!       IF S.errcnt = 0 THEN
LINE 1091
LDGW OMSPS.errcnt
JNEQZ L1277
!         B.Export(modid, newSF, key);
LINE 1092
LOCAL -4
GLOBAL OMSPP.newSF
GLOBAL OMSPP.modid
GLOBAL OMSPB.Export
CALL 3
!         IF newSF THEN Texts.WriteString(W, " new symbol file") END
LINE 1093
LDGC OMSPP.newSF
JEQZ L1277
CONST 17
GLOBAL OMSPP.%114
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteString
CALL 4
LABEL L1277
!       IF S.errcnt = 0 THEN G.Close(modid, key, exno, codeseg);
LINE 1095
LDGW OMSPS.errcnt
JNEQZ L1283
LDGC OMSPP.codeseg
LDGW OMSPP.exno
LDLW -4
GLOBAL OMSPP.modid
GLOBAL OMSPG.Close
CALL 4
!         Texts.WriteInt(W, G.Here(), 6); Texts.WriteInt(W, dc, 6); Texts.WriteHex(W, key)
LINE 1096
CONST 6
GLOBAL OMSPG.Here
CALLW 0
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteInt
CALL 4
CONST 6
LDGW OMSPP.dc
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteInt
CALL 4
LDLW -4
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteHex
CALL 3
JUMP L1281
LABEL L1283
!       ELSE Texts.WriteLn(W); oldCol := W.col; W.col := Display.red; Texts.WriteString(W, "compilation FAILED"); W.col := oldCol 
LINE 1097
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteLn
CALL 2
GLOBAL OMSPP.W
LDNW 4
STLW -8
CONST 224
GLOBAL OMSPP.W
STNW 4
CONST 19
GLOBAL OMSPP.%115
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteString
CALL 4
LDLW -8
GLOBAL OMSPP.W
STNW 4
LABEL L1281
!       Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf);
LINE 1099
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteLn
CALL 2
LDGW OMSPP.W
LDGW Oberon.Log
GLOBAL Texts.Append
CALL 2
!       B.CloseScope; pbsList := NIL
LINE 1100
GLOBAL OMSPB.CloseScope
CALL 0
CONST 0
STGW OMSPP.pbsList
RETURN
LABEL L1247
!     ELSE S.Mark("must start with MODULE")
LINE 1101
CONST 23
GLOBAL OMSPP.%116
GLOBAL OMSPS.Mark
CALL 2
RETURN
END

PROC OMSPP.Option 0 3 0x00100001
!   PROCEDURE Option(VAR S1: Texts.Scanner);
LINE 1105
!   BEGIN newSF := FALSE;
LINE 1106
CONST 0
STGC OMSPP.newSF
!     IF S1.nextCh = "/" THEN
LINE 1107
LDLW 12
CONST 32
LDIC
CONST 47
JNEQ L1286
!       Texts.Scan(S1); Texts.Scan(S1); 
LINE 1108
LDLW 16
LDLW 12
GLOBAL Texts.Scan
CALL 2
LDLW 16
LDLW 12
GLOBAL Texts.Scan
CALL 2
!       IF (S1.class = Texts.Name) & (S1.s[0] = "s") THEN newSF := TRUE END
LINE 1109
LDLW 12
LDNW 40
CONST 1
JNEQ L1286
LDLW 12
CONST 60
LDIC
CONST 115
JNEQ L1286
CONST 1
STGC OMSPP.newSF
LABEL L1286
RETURN
END

PROC OMSPP.Compile 108 5 OMSPP.Compile.%map
!   PROCEDURE Compile*;
LINE 1113
!   BEGIN Texts.OpenScanner(S1, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(S1);
LINE 1117
GLOBAL Oberon.Par
LDNW 4
LDGW Oberon.Par
GLOBAL Texts.Scanner
LOCAL -108
GLOBAL Texts.OpenScanner
CALL 4
GLOBAL Texts.Scanner
LOCAL -108
GLOBAL Texts.Scan
CALL 2
!     IF S1.class = Texts.Char THEN
LINE 1118
LDLW -68
CONST 6
JNEQ L1303
!       IF S1.c = "@" THEN
LINE 1119
LDLC -56
CONST 64
JNEQ L1306
!         Option(S1); Oberon.GetSelection(T, beg, end, time);
LINE 1120
GLOBAL Texts.Scanner
LOCAL -108
GLOBAL OMSPP.Option
CALL 2
LOCAL -12
LOCAL -8
LOCAL -4
LOCAL -16
GLOBAL Oberon.GetSelection
CALL 4
!         IF time >= 0 THEN S.Init(T, beg); Module END
LINE 1121
LDLW -12
JLTZ L1294
LDLW -4
LDLW -16
GLOBAL OMSPS.Init
CALL 2
GLOBAL OMSPP.Module
CALL 0
JUMP L1294
LABEL L1306
!       ELSIF S1.c = "^" THEN
LINE 1122
LDLC -56
CONST 94
JNEQ L1294
!         Option(S1); Oberon.GetSelection(T, beg, end, time);
LINE 1123
GLOBAL Texts.Scanner
LOCAL -108
GLOBAL OMSPP.Option
CALL 2
LOCAL -12
LOCAL -8
LOCAL -4
LOCAL -16
GLOBAL Oberon.GetSelection
CALL 4
!         IF time >= 0 THEN
LINE 1124
LDLW -12
JLTZ L1294
!           Texts.OpenScanner(S1, T, beg); Texts.Scan(S1);
LINE 1125
LDLW -4
LDLW -16
GLOBAL Texts.Scanner
LOCAL -108
GLOBAL Texts.OpenScanner
CALL 4
GLOBAL Texts.Scanner
LOCAL -108
GLOBAL Texts.Scan
CALL 2
!           IF S1.class = Texts.Name THEN
LINE 1126
LDLW -68
CONST 1
JNEQ L1294
!             Texts.WriteString(W, S1.s); NEW(T); Texts.Open(T, S1.s);
LINE 1127
CONST 32
LOCAL -48
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteString
CALL 4
CONST 24
GLOBAL Texts.TextDesc
GLOBAL NEW
CALLW 2
STLW -16
CONST 32
LOCAL -48
LDLW -16
GLOBAL Texts.Open
CALL 3
!             IF T.len > 0 THEN S.Init(T, 0); Module
LINE 1128
LDLW -16
NCHECK 1128
LOADW
JLEQZ L1320
CONST 0
LDLW -16
GLOBAL OMSPS.Init
CALL 2
GLOBAL OMSPP.Module
CALL 0
JUMP L1294
LABEL L1320
!             ELSE Texts.WriteString(W, " not found");
LINE 1129
CONST 11
GLOBAL OMSPP.%117
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteString
CALL 4
!               Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)
LINE 1130
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteLn
CALL 2
LDGW OMSPP.W
LDGW Oberon.Log
GLOBAL Texts.Append
CALL 2
JUMP L1294
LABEL L1303
!       WHILE S1.class = Texts.Name DO
LINE 1136
LDLW -68
CONST 1
JNEQ L1294
!         NEW(T); Texts.Open(T, S1.s);
LINE 1137
CONST 24
GLOBAL Texts.TextDesc
GLOBAL NEW
CALLW 2
STLW -16
CONST 32
LOCAL -48
LDLW -16
GLOBAL Texts.Open
CALL 3
!         IF T.len > 0 THEN Option(S1); S.Init(T, 0); Module
LINE 1138
LDLW -16
NCHECK 1138
LOADW
JLEQZ L1297
GLOBAL Texts.Scanner
LOCAL -108
GLOBAL OMSPP.Option
CALL 2
CONST 0
LDLW -16
GLOBAL OMSPS.Init
CALL 2
GLOBAL OMSPP.Module
CALL 0
JUMP L1295
LABEL L1297
!         ELSE Texts.WriteString(W, S1.s); Texts.WriteString(W, " not found");
LINE 1139
CONST 32
LOCAL -48
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteString
CALL 4
CONST 11
GLOBAL OMSPP.%117
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteString
CALL 4
!           Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)
LINE 1140
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteLn
CALL 2
LDGW OMSPP.W
LDGW Oberon.Log
GLOBAL Texts.Append
CALL 2
LABEL L1295
!         IF (T.len # 0) & (S.errcnt = 0) THEN Texts.Scan(S1) ELSE S1.class := 0 END
LINE 1142
LDLW -16
NCHECK 1142
LOADW
JEQZ L1300
LDGW OMSPS.errcnt
JNEQZ L1300
GLOBAL Texts.Scanner
LOCAL -108
GLOBAL Texts.Scan
CALL 2
JUMP L1303
LABEL L1300
CONST 0
STLW -68
JUMP L1303
LABEL L1294
!     Oberon.Collect(0)
LINE 1145
CONST 0
GLOBAL Oberon.Collect
CALL 1
RETURN
END

PROC OMSPP.%main 0 5 0
! BEGIN Texts.OpenWriter(W); Texts.WriteString(W, "OMSP Compiler 19.04.25");
LINE 1148
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.OpenWriter
CALL 2
CONST 23
GLOBAL OMSPP.%118
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteString
CALL 4
!   Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf);
LINE 1149
GLOBAL Texts.Writer
GLOBAL OMSPP.W
GLOBAL Texts.WriteLn
CALL 2
LDGW OMSPP.W
LDGW Oberon.Log
GLOBAL Texts.Append
CALL 2
!   NEW(dummy); dummy.class := B.Var; dummy.type := B.intType; dummy.val := 0;
LINE 1150
CONST 64
GLOBAL OMSPB.ObjDesc
GLOBAL NEW
CALLW 2
STGW OMSPP.dummy
CONST 2
LDGW OMSPP.dummy
NCHECK 1150
STOREC
LDGW OMSPB.intType
LDGW OMSPP.dummy
NCHECK 1150
STNW 24
CONST 0
LDGW OMSPP.dummy
NCHECK 1150
STNW 60
!   expression := expression0; Type := Type0; FormalType := FormalType0
LINE 1151
GLOBAL OMSPP.expression0
STGW OMSPP.expression
GLOBAL OMSPP.Type0
STGW OMSPP.Type
GLOBAL OMSPP.FormalType0
STGW OMSPP.FormalType
RETURN
END

! Global variables
GLOVAR OMSPP.sym 4
GLOVAR OMSPP.dc 4
GLOVAR OMSPP.level 4
GLOVAR OMSPP.exno 4
GLOVAR OMSPP.newSF 1
GLOVAR OMSPP.initmode 1
GLOVAR OMSPP.expression 4
GLOVAR OMSPP.Type 4
GLOVAR OMSPP.FormalType 4
GLOVAR OMSPP.modid 32
GLOVAR OMSPP.pbsList 4
GLOVAR OMSPP.dummy 4
GLOVAR OMSPP.isLeaf 1
GLOVAR OMSPP.isInt 1
GLOVAR OMSPP.codeseg 1
GLOVAR OMSPP.W 20

! Global pointer map
DEFINE OMSPP.%gcmap
WORD GC_POINTER
WORD OMSPP.pbsList
WORD GC_POINTER
WORD OMSPP.dummy
WORD GC_BASE
WORD OMSPP.W
WORD 0x00000023
WORD GC_END

! String "undef"
DEFINE OMSPP.%1
STRING 756E64656600

! String "identifier expected"
DEFINE OMSPP.%2
STRING 6964656E74696669657220657870656374656400

! String "not Boolean"
DEFINE OMSPP.%3
STRING 6E6F7420426F6F6C65616E00

! String "not Integer"
DEFINE OMSPP.%4
STRING 6E6F7420496E746567657200

! String "not Set"
DEFINE OMSPP.%5
STRING 6E6F742053657400

! String "not Int"
DEFINE OMSPP.%6
STRING 6E6F7420496E7400

! String "invalid set"
DEFINE OMSPP.%7
STRING 696E76616C69642073657400

! String "not a constant"
DEFINE OMSPP.%8
STRING 6E6F74206120636F6E7374616E7400

! String "read-only"
DEFINE OMSPP.%9
STRING 726561642D6F6E6C7900

! String "remove asterisk"
DEFINE OMSPP.%10
STRING 72656D6F766520617374657269736B00

! String "remove exclamation mark"
DEFINE OMSPP.%11
STRING 72656D6F7665206578636C616D6174696F6E206D61726B00

! String "not an extension"
DEFINE OMSPP.%12
STRING 6E6F7420616E20657874656E73696F6E00

! String "incompatible types"
DEFINE OMSPP.%13
STRING 696E636F6D70617469626C6520747970657300

! String "type mismatch"
DEFINE OMSPP.%14
STRING 74797065206D69736D6174636800

! String "no ("
DEFINE OMSPP.%15
STRING 6E6F202800

! String "no )"
DEFINE OMSPP.%16
STRING 6E6F202900

! String "bad type"
DEFINE OMSPP.%17
STRING 626164207479706500

! String "not an array"
DEFINE OMSPP.%18
STRING 6E6F7420616E20617272617900

! String "first op is not a type"
DEFINE OMSPP.%19
STRING 6669727374206F70206973206E6F742061207479706500

! String "casting not allowed"
DEFINE OMSPP.%20
STRING 63617374696E67206E6F7420616C6C6F77656400

! String "must be a type"
DEFINE OMSPP.%21
STRING 6D7573742062652061207479706500

! String "wrong nof params"
DEFINE OMSPP.%22
STRING 77726F6E67206E6F6620706172616D7300

! String "no ]"
DEFINE OMSPP.%23
STRING 6E6F205D00

! String "not a record"
DEFINE OMSPP.%24
STRING 6E6F742061207265636F726400

! String "ident?"
DEFINE OMSPP.%25
STRING 6964656E743F00

! String "not a pointer"
DEFINE OMSPP.%26
STRING 6E6F74206120706F696E74657200

! String "guard type expected"
DEFINE OMSPP.%27
STRING 6775617264207479706520657870656374656400

! String "not an identifier"
DEFINE OMSPP.%28
STRING 6E6F7420616E206964656E74696669657200

! String " ) missing"
DEFINE OMSPP.%29
STRING 2029206D697373696E6700

! String "regs destroyed: "
DEFINE OMSPP.%30
STRING 726567732064657374726F7965643A2000

! String ", "
DEFINE OMSPP.%31
STRING 2C2000

! String "incompatible leafness"
DEFINE OMSPP.%32
STRING 696E636F6D70617469626C65206C6561666E65737300

! String "incompatible parameters"
DEFINE OMSPP.%33
STRING 696E636F6D70617469626C6520706172616D657465727300

! String "comma?"
DEFINE OMSPP.%34
STRING 636F6D6D613F00

! String ") missing"
DEFINE OMSPP.%35
STRING 29206D697373696E6700

! String "too few params"
DEFINE OMSPP.%36
STRING 746F6F2066657720706172616D7300

! String "too many params"
DEFINE OMSPP.%37
STRING 746F6F206D616E7920706172616D7300

! String " } missing"
DEFINE OMSPP.%38
STRING 207D206D697373696E6700

! String "missing comma"
DEFINE OMSPP.%39
STRING 6D697373696E6720636F6D6D6100

! String "expression expected"
DEFINE OMSPP.%40
STRING 65787072657373696F6E20657870656374656400

! String "no call in leaf func"
DEFINE OMSPP.%41
STRING 6E6F2063616C6C20696E206C6561662066756E6300

! String "not a function"
DEFINE OMSPP.%42
STRING 6E6F7420612066756E6374696F6E00

! String "no }"
DEFINE OMSPP.%43
STRING 6E6F207D00

! String "not a factor"
DEFINE OMSPP.%44
STRING 6E6F74206120666163746F7200

! String "not String nor Char"
DEFINE OMSPP.%45
STRING 6E6F7420537472696E67206E6F72204368617200

! String "only = or #"
DEFINE OMSPP.%46
STRING 6F6E6C79203D206F72202300

! String "illegal comparison"
DEFINE OMSPP.%47
STRING 696C6C6567616C20636F6D70617269736F6E00

! String "not allowed here"
DEFINE OMSPP.%48
STRING 6E6F7420616C6C6F776564206865726500

! String "wrong nof parameters"
DEFINE OMSPP.%49
STRING 77726F6E67206E6F6620706172616D657465727300

! String "not a type"
DEFINE OMSPP.%50
STRING 6E6F742061207479706500

! String ": expected"
DEFINE OMSPP.%51
STRING 3A20657870656374656400

! String "type id expected"
DEFINE OMSPP.%52
STRING 7479706520696420657870656374656400

! String "statement expected"
DEFINE OMSPP.%53
STRING 73746174656D656E7420657870656374656400

! String "illegal assignment"
DEFINE OMSPP.%54
STRING 696C6C6567616C2061737369676E6D656E7400

! String "should be :="
DEFINE OMSPP.%55
STRING 73686F756C64206265203A3D00

! String "no call in leaf proc"
DEFINE OMSPP.%56
STRING 6E6F2063616C6C20696E206C6561662070726F6300

! String "not a procedure"
DEFINE OMSPP.%57
STRING 6E6F7420612070726F63656475726500

! String "missing parameters"
DEFINE OMSPP.%58
STRING 6D697373696E6720706172616D657465727300

! String "no THEN"
DEFINE OMSPP.%59
STRING 6E6F205448454E00

! String "no END"
DEFINE OMSPP.%60
STRING 6E6F20454E4400

! String "no DO"
DEFINE OMSPP.%61
STRING 6E6F20444F00

! String "missing UNTIL"
DEFINE OMSPP.%62
STRING 6D697373696E6720554E54494C00

! String "no TO"
DEFINE OMSPP.%63
STRING 6E6F20544F00

! String ":= expected"
DEFINE OMSPP.%64
STRING 3A3D20657870656374656400

! String "OF expected"
DEFINE OMSPP.%65
STRING 4F4620657870656374656400

! String "numeric case not implemented"
DEFINE OMSPP.%66
STRING 6E756D657269632063617365206E6F7420696D706C656D656E74656400

! String "ident expected"
DEFINE OMSPP.%67
STRING 6964656E7420657870656374656400

! String "missing semicolon?"
DEFINE OMSPP.%68
STRING 6D697373696E672073656D69636F6C6F6E3F00

! String ":?"
DEFINE OMSPP.%69
STRING 3A3F00

! String "not a valid length"
DEFINE OMSPP.%70
STRING 6E6F7420612076616C6964206C656E67746800

! String "dyn array not allowed"
DEFINE OMSPP.%71
STRING 64796E206172726179206E6F7420616C6C6F77656400

! String "missing OF"
DEFINE OMSPP.%72
STRING 6D697373696E67204F4600

! String "extension of local types not implemented"
DEFINE OMSPP.%73
STRING 657874656E73696F6E206F66206C6F63616C207479706573206E6F7420696D70
STRING 6C656D656E74656400

! String "invalid extension"
DEFINE OMSPP.%74
STRING 696E76616C696420657874656E73696F6E00

! String "type expected"
DEFINE OMSPP.%75
STRING 7479706520657870656374656400

! String "mult def"
DEFINE OMSPP.%76
STRING 6D756C742064656600

! String "comma expected"
DEFINE OMSPP.%77
STRING 636F6D6D6120657870656374656400

! String "colon expected"
DEFINE OMSPP.%78
STRING 636F6C6F6E20657870656374656400

! String " ; or END"
DEFINE OMSPP.%79
STRING 203B206F7220454E4400

! String "too many parameters"
DEFINE OMSPP.%80
STRING 746F6F206D616E7920706172616D657465727300

! String "illegal function type"
DEFINE OMSPP.%81
STRING 696C6C6567616C2066756E6374696F6E207479706500

! String "type identifier expected"
DEFINE OMSPP.%82
STRING 74797065206964656E74696669657220657870656374656400

! String "OF ?"
DEFINE OMSPP.%83
STRING 4F46203F00

! String "multi-dimensional open arrays not implemented"
DEFINE OMSPP.%84
STRING 6D756C74692D64696D656E73696F6E616C206F70656E20617272617973206E6F
STRING 7420696D706C656D656E74656400

! String "ptr base must be global"
DEFINE OMSPP.%85
STRING 7074722062617365206D75737420626520676C6F62616C00

! String "not a type or undefined"
DEFINE OMSPP.%86
STRING 6E6F7420612074797065206F7220756E646566696E656400

! String "external base type not implemented"
DEFINE OMSPP.%87
STRING 65787465726E616C20626173652074797065206E6F7420696D706C656D656E74
STRING 656400

! String "no valid base type"
DEFINE OMSPP.%88
STRING 6E6F2076616C69642062617365207479706500

! String "must point to named record"
DEFINE OMSPP.%89
STRING 6D75737420706F696E7420746F206E616D6564207265636F726400

! String "illegal type"
DEFINE OMSPP.%90
STRING 696C6C6567616C207479706500

! String "declaration?"
DEFINE OMSPP.%91
STRING 6465636C61726174696F6E3F00

! String "= ?"
DEFINE OMSPP.%92
STRING 3D203F00

! String "expression not constant"
DEFINE OMSPP.%93
STRING 65787072657373696F6E206E6F7420636F6E7374616E7400

! String "; missing"
DEFINE OMSPP.%94
STRING 3B206D697373696E6700

! String "=?"
DEFINE OMSPP.%95
STRING 3D3F00

! String "remove hyphen"
DEFINE OMSPP.%96
STRING 72656D6F76652068797068656E00

! String "reg alloc forbidden"
DEFINE OMSPP.%97
STRING 72656720616C6C6F6320666F7262696464656E00

! String "mark unsafe vars with an exclamation mark"
DEFINE OMSPP.%98
STRING 6D61726B20756E736166652076617273207769746820616E206578636C616D61
STRING 74696F6E206D61726B00

! String "undefined pointer base of"
DEFINE OMSPP.%99
STRING 756E646566696E656420706F696E7465722062617365206F6600

! String "declaration in bad order"
DEFINE OMSPP.%100
STRING 6465636C61726174696F6E20696E20626164206F7264657200

! String "interrupt handler must be global"
DEFINE OMSPP.%101
STRING 696E746572727570742068616E646C6572206D75737420626520676C6F62616C
STRING 00

! String "remove params"
DEFINE OMSPP.%102
STRING 72656D6F766520706172616D7300

! String "no ;"
DEFINE OMSPP.%103
STRING 6E6F203B00

! String "this is not a function"
DEFINE OMSPP.%104
STRING 74686973206973206E6F7420612066756E6374696F6E00

! String "wrong result type"
DEFINE OMSPP.%105
STRING 77726F6E6720726573756C74207479706500

! String "function without result"
DEFINE OMSPP.%106
STRING 66756E6374696F6E20776974686F757420726573756C7400

! String "no match"
DEFINE OMSPP.%107
STRING 6E6F206D6174636800

! String "no proc id"
DEFINE OMSPP.%108
STRING 6E6F2070726F6320696400

! String "proc id expected"
DEFINE OMSPP.%109
STRING 70726F6320696420657870656374656400

! String "id expected"
DEFINE OMSPP.%110
STRING 696420657870656374656400

! String "  compiling "
DEFINE OMSPP.%111
STRING 2020636F6D70696C696E672000

! String "identifier missing"
DEFINE OMSPP.%112
STRING 6964656E746966696572206D697373696E6700

! String "period missing"
DEFINE OMSPP.%113
STRING 706572696F64206D697373696E6700

! String " new symbol file"
DEFINE OMSPP.%114
STRING 206E65772073796D626F6C2066696C6500

! String "compilation FAILED"
DEFINE OMSPP.%115
STRING 636F6D70696C6174696F6E204641494C454400

! String "must start with MODULE"
DEFINE OMSPP.%116
STRING 6D7573742073746172742077697468204D4F44554C4500

! String " not found"
DEFINE OMSPP.%117
STRING 206E6F7420666F756E6400

! String "OMSP Compiler 19.04.25"
DEFINE OMSPP.%118
STRING 4F4D535020436F6D70696C65722031392E30342E323500

! Descriptor for PtrBaseDesc
DEFINE OMSPP.PtrBaseDesc
WORD 0x00000601
WORD 0
WORD OMSPP.PtrBaseDesc.%anc

DEFINE OMSPP.PtrBaseDesc.%anc
WORD OMSPP.PtrBaseDesc

! Pointer maps
DEFINE OMSPP.StandProc.%map
WORD -32
WORD -28
WORD -68
WORD -64
WORD -104
WORD -100
WORD GC_END

DEFINE OMSPP.StatSequence.%map
WORD -4
WORD -8
WORD -32
WORD -28
WORD -68
WORD -64
WORD -104
WORD -100
WORD -140
WORD -136
WORD GC_END

DEFINE OMSPP.ProcedureType.%map
WORD 12
WORD 16
WORD -4
WORD -40
WORD -36
WORD -76
WORD -72
WORD GC_END

DEFINE OMSPP.ProcedureDecl.%map
WORD -4
WORD -8
WORD -12
WORD -68
WORD -64
WORD -104
WORD -100
WORD GC_END

DEFINE OMSPP.Compile.%map
WORD -16
WORD -100
WORD -80
WORD GC_END

! End of file
